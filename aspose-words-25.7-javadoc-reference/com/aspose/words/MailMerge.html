<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 19 Jul 2025 -->
<TITLE>MailMerge</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class MailMerge</H2>
<PRE>
java.lang.Object
    <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.MailMerge</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>MailMerge </B><DT>extends java.lang.Object</DL>
</PRE>

<P>

<summary>
             Represents the mail merge functionality.
             <p>To learn more, visit the <a href="https://docs.aspose.com/words/net/mail-merge-and-reporting/">Mail Merge and Reporting</a> documentation article.</p></summary><remarks><p>For mail merge operation to work, the document should contain Word MERGEFIELD and
             optionally NEXT fields. During mail merge operation, merge fields in the document are
             replaced with values from your data source.</p><p>There are two distinct ways to use mail merge: with mail merge regions and without.</p><p>The simplest mail merge is without regions and it is very similar to how mail merge
             works in Word. Use <tt>Execute</tt> methods to merge information from some
             data source such as <b>DataTable</b>, <b>DataSet</b>
              or an array of objects into your document. The
             <cref><i>MailMerge</i></cref> object processes all records of the data source and copies and appends
             content of the whole document for each record.</p><p>Note that when <cref><i>MailMerge</i></cref> object encounters a NEXT field, it selects next record
             in the data source and continues merging without copying any content.</p><p>Use <cref><A HREF="#executeWithRegions(com.aspose.words.IMailMergeDataSource)" title="method in class com.aspose.words.MailMerge">executeWithRegions(com.aspose.words.IMailMergeDataSource)</A></cref> and other overloads to merge information into a
             document with mail merge regions defined. You can use
             <b>DataTable</b> or <b>DataSet</b>
             as data sources for this operation.</p><p>You need to use mail merge regions if you want to dynamically grow portions inside the
             document. Without mail merge regions whole document will be repeated for every record of
             the data source.</p></remarks><example><p><b>Example:</b></p>Shows how to execute a mail merge with data from a DataTable.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField(" MERGEFIELD CustomerName ");
builder.insertParagraph();
builder.insertField(" MERGEFIELD Address ");

// This example creates a table, but you would normally load table from a database
DataTable table = new DataTable("Test");
table.getColumns().add("CustomerName");
table.getColumns().add("Address");
table.getRows().add("Thomas Hardy", "120 Hanover Sq., London");
table.getRows().add("Paolo Accorti", "Via Monte Bianco 34, Torino");

// Field values from the table are inserted into the mail merge fields found in the document
doc.getMailMerge().execute(table);

doc.save(getArtifactsDir() + "MailMerge.ExecuteDataTable.docx");

// Create a copy of our document to perform another mail merge
doc = new Document();
builder = new DocumentBuilder(doc);
builder.insertField(" MERGEFIELD CustomerName ");
builder.insertParagraph();
builder.insertField(" MERGEFIELD Address ");

// We can also source values for a mail merge from a single row in the table
doc.getMailMerge().execute(table.getRows().get(1));

doc.save(getArtifactsDir() + "MailMerge.ExecuteDataTable.OneRow.docx");</pre></example><DL><DT><B>See Also:</B></DT><DD><cref seealso=""><A HREF="Document.html" title="class in com.aspose.words">Document</A></cref>, <cref seealso=""><A HREF="Document.html#MailMerge" title="property in class com.aspose.words.Document">Document.MailMerge</A></cref></DD></DL>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE RULES="GROUPS" BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Property Getters/Setters Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#CleanupOptions">getCleanupOptions</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#CleanupOptions">setCleanupOptions</A></B>(int&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a set of flags that specify what items should be removed during mail merge.
            The value of the property is <A HREF="MailMergeCleanupOptions.html" title="Utility class in com.aspose.words">MailMergeCleanupOptions</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#CleanupParagraphsWithPunctuationMarks">getCleanupParagraphsWithPunctuationMarks</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#CleanupParagraphsWithPunctuationMarks">setCleanupParagraphsWithPunctuationMarks</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a value indicating whether paragraphs with punctuation marks are considered as empty
            and should be removed if the <cref><A HREF="MailMergeCleanupOptions.html#REMOVE_EMPTY_PARAGRAPHS" title="field in class com.aspose.words.MailMergeCleanupOptions">MailMergeCleanupOptions.REMOVE_EMPTY_PARAGRAPHS</A></cref> option is specified.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="IFieldMergingCallback.html" title="interface in com.aspose.words">IFieldMergingCallback</A></CODE></TD><TD><CODE><B><A HREF="#FieldMergingCallback">getFieldMergingCallback</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#FieldMergingCallback">setFieldMergingCallback</A></B>(<A HREF="IFieldMergingCallback.html" title="interface in com.aspose.words">IFieldMergingCallback</A>&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Occurs during mail merge when a mail merge field is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="IMailMergeCallback.html" title="interface in com.aspose.words">IMailMergeCallback</A></CODE></TD><TD><CODE><B><A HREF="#MailMergeCallback">getMailMergeCallback</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#MailMergeCallback">setMailMergeCallback</A></B>(<A HREF="IMailMergeCallback.html" title="interface in com.aspose.words">IMailMergeCallback</A>&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Allows to handle particular events during mail merge.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="MappedDataFieldCollection.html" title="class in com.aspose.words">MappedDataFieldCollection</A></CODE></TD><TD><CODE><B><A HREF="#MappedDataFields">getMappedDataFields</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a collection that represents mapped data fields for the mail merge operation.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#MergeDuplicateRegions">getMergeDuplicateRegions</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#MergeDuplicateRegions">setMergeDuplicateRegions</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a value indicating whether all of the document mail merge regions with the name of a data source
            should be merged while executing of a mail merge with regions against the data source or just the first one.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#MergeWholeDocument">getMergeWholeDocument</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#MergeWholeDocument">setMergeWholeDocument</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a value indicating whether fields in whole document are updated while executing of a mail merge with regions.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#PreserveUnusedTags">getPreserveUnusedTags</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#PreserveUnusedTags">setPreserveUnusedTags</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a value indicating whether the unused "mustache" tags should be preserved.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#RegionEndTag">getRegionEndTag</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#RegionEndTag">setRegionEndTag</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a mail merge region end tag.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#RegionStartTag">getRegionStartTag</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#RegionStartTag">setRegionStartTag</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a mail merge region start tag.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#RestartListsAtEachSection">getRestartListsAtEachSection</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#RestartListsAtEachSection">setRestartListsAtEachSection</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a value indicating whether lists are restarted at each section after executing of a mail merge.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#RetainFirstSectionStart">getRetainFirstSectionStart</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#RetainFirstSectionStart">setRetainFirstSectionStart</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a value indicating whether the <cref><A HREF="PageSetup.html#SectionStart" title="property in class com.aspose.words.PageSetup">PageSetup.SectionStart</A></cref> of the first document section and its copies for subsequent data source rows
            are retained during mail merge or updated according to MS Word behaviour.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#TrimWhitespaces">getTrimWhitespaces</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#TrimWhitespaces">setTrimWhitespaces</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a value indicating whether trailing and leading whitespaces are trimmed from mail merge values.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#UnconditionalMergeFieldsAndRegions">getUnconditionalMergeFieldsAndRegions</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#UnconditionalMergeFieldsAndRegions">setUnconditionalMergeFieldsAndRegions</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a value indicating whether merge fields and merge regions are merged regardless of the parent IF field's condition.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#UseNonMergeFields">getUseNonMergeFields</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#UseNonMergeFields">setUseNonMergeFields</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             When <code>true</code>, specifies that in addition to MERGEFIELD fields, mail merge is performed into some other types of fields and
             also into "{{fieldName}}" tags.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#UseWholeParagraphAsRegion">getUseWholeParagraphAsRegion</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#UseWholeParagraphAsRegion">setUseWholeParagraphAsRegion</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a value indicating whether whole paragraph with <b>TableStart</b> or <b>TableEnd</b> field
            or particular range between <b>TableStart</b> and <b>TableEnd</b> fields should be included into mail merge region.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#deleteFields()">deleteFields</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Removes mail merge related fields from the document.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#execute(com.aspose.words.IMailMergeDataSource)">execute</A></B>(<A HREF="IMailMergeDataSource.html" title="interface in com.aspose.words">IMailMergeDataSource</A>&nbsp;dataSource)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Performs a mail merge from a custom data source.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#execute(com.aspose.words.net.System.Data.DataRow)">execute</A></B>(com.aspose.words.net.System.Data.DataRow&nbsp;row)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Performs mail merge from a <b>DataRow</b> into the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#execute(com.aspose.words.net.System.Data.DataTable)">execute</A></B>(com.aspose.words.net.System.Data.DataTable&nbsp;table)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Performs mail merge from a com.aspose.words.net.System.Data.DataTable into the document.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#execute(com.aspose.words.net.System.Data.DataView)">execute</A></B>(com.aspose.words.net.System.Data.DataView&nbsp;dataView)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Performs mail merge from a <b>DataView</b> into the document.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#execute(com.aspose.words.net.System.Data.IDataReader)">execute</A></B>(com.aspose.words.net.System.Data.IDataReader&nbsp;dataReader)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Performs mail merge from <b>IDataReader</b> into the document.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#execute(java.lang.String[],java.lang.Object[])">execute</A></B>(java.lang.String[]&nbsp;fieldNames, java.lang.Object[]&nbsp;values)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Performs a mail merge operation for a single record.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#executeWithRegions(com.aspose.words.IMailMergeDataSource)">executeWithRegions</A></B>(<A HREF="IMailMergeDataSource.html" title="interface in com.aspose.words">IMailMergeDataSource</A>&nbsp;dataSource)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Performs a mail merge from a custom data source with mail merge regions.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#executeWithRegions(com.aspose.words.IMailMergeDataSourceRoot)">executeWithRegions</A></B>(<A HREF="IMailMergeDataSourceRoot.html" title="interface in com.aspose.words">IMailMergeDataSourceRoot</A>&nbsp;dataSourceRoot)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Performs a mail merge from a custom data source with mail merge regions.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#executeWithRegions(com.aspose.words.net.System.Data.DataSet)">executeWithRegions</A></B>(com.aspose.words.net.System.Data.DataSet&nbsp;dataSet)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Performs mail merge from a <b>DataSet</b> into a document with mail merge regions.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#executeWithRegions(com.aspose.words.net.System.Data.DataTable)">executeWithRegions</A></B>(com.aspose.words.net.System.Data.DataTable&nbsp;dataTable)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Performs mail merge from a <b>DataTable</b> into the document with mail merge regions.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#executeWithRegions(com.aspose.words.net.System.Data.DataView)">executeWithRegions</A></B>(com.aspose.words.net.System.Data.DataView&nbsp;dataView)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Performs mail merge from a <b>DataView</b> into the document with mail merge regions.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#executeWithRegions(com.aspose.words.net.System.Data.IDataReader,java.lang.String)">executeWithRegions</A></B>(com.aspose.words.net.System.Data.IDataReader&nbsp;dataReader, java.lang.String&nbsp;tableName)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Performs mail merge from <b>IDataReader</b> into the document with mail merge regions.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String[]</CODE></TD><TD><CODE><B><A HREF="#getFieldNames()">getFieldNames</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a collection of mail merge field names available in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String[]</CODE></TD><TD><CODE><B><A HREF="#getFieldNamesForRegion(java.lang.String)">getFieldNamesForRegion</A></B>(java.lang.String&nbsp;regionName)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a collection of mail merge field names available in the region.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String[]</CODE></TD><TD><CODE><B><A HREF="#getFieldNamesForRegion(java.lang.String,int)">getFieldNamesForRegion</A></B>(java.lang.String&nbsp;regionName, int&nbsp;regionIndex)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a collection of mail merge field names available in the region.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.util.ArrayList&lt;<A HREF="MailMergeRegionInfo.html" title="class in com.aspose.words">MailMergeRegionInfo</A>&gt;</CODE></TD><TD><CODE><B><A HREF="#getRegionsByName(java.lang.String)">getRegionsByName</A></B>(java.lang.String&nbsp;regionName)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a collection of mail merge regions with the specified name.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="MailMergeRegionInfo.html" title="class in com.aspose.words">MailMergeRegionInfo</A></CODE></TD><TD><CODE><B><A HREF="#getRegionsHierarchy()">getRegionsHierarchy</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a full hierarchy of regions (with fields) available in the document.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ============ PROPERTY DETAIL ========== -->

<A NAME="property_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Property Getters/Setters Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="CleanupOptions"><!-- --></A><A NAME="getCleanupOptions()"><!-- --></A><A NAME="getCleanupOptions--"><!-- --></A><A NAME="setCleanupOptions(int)"><!-- --></A><A NAME="setCleanupOptions-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCleanupOptions/setCleanupOptions</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getCleanupOptions</B>()&nbsp;/&nbsp;public void&nbsp;<B>setCleanupOptions</B>(int&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a set of flags that specify what items should be removed during mail merge.
            The value of the property is <A HREF="MailMergeCleanupOptions.html" title="Utility class in com.aspose.words">MailMergeCleanupOptions</A> integer constant.</summary><example><p><b>Example:</b></p>Shows how to automatically remove unmerged merge fields during mail merge.<pre>
doc.getMailMerge().setCleanupOptions(MailMergeCleanupOptions.REMOVE_UNUSED_FIELDS);</pre></example><example><p><b>Example:</b></p>Shows how to make sure empty paragraphs that result from merging fields with no data are removed from the document.<pre>
doc.getMailMerge().setCleanupOptions(MailMergeCleanupOptions.REMOVE_EMPTY_PARAGRAPHS);</pre></example><example><p><b>Example:</b></p>Shows how to instruct the mail merge engine to remove any containing fields from around a merge field during mail merge.<pre>
doc.getMailMerge().setCleanupOptions(MailMergeCleanupOptions.REMOVE_CONTAINING_FIELDS);</pre></example>
</DL>
<HR>

<A NAME="CleanupParagraphsWithPunctuationMarks"><!-- --></A><A NAME="getCleanupParagraphsWithPunctuationMarks()"><!-- --></A><A NAME="getCleanupParagraphsWithPunctuationMarks--"><!-- --></A><A NAME="setCleanupParagraphsWithPunctuationMarks(boolean)"><!-- --></A><A NAME="setCleanupParagraphsWithPunctuationMarks-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCleanupParagraphsWithPunctuationMarks/setCleanupParagraphsWithPunctuationMarks</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getCleanupParagraphsWithPunctuationMarks</B>()&nbsp;/&nbsp;public void&nbsp;<B>setCleanupParagraphsWithPunctuationMarks</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a value indicating whether paragraphs with punctuation marks are considered as empty
            and should be removed if the <cref><A HREF="MailMergeCleanupOptions.html#REMOVE_EMPTY_PARAGRAPHS" title="field in class com.aspose.words.MailMergeCleanupOptions">MailMergeCleanupOptions.REMOVE_EMPTY_PARAGRAPHS</A></cref> option is specified.
            </summary><remarks>
            The default value is <code>true</code>.
            </remarks><remarks>
            Here is the complete list of cleanable punctuation marks:
            <ul><li><description>!</description></li><li><description>,</description></li><li><description>.</description></li><li><description>:</description></li><li><description>;</description></li><li><description>?</description></li><li><description>¡</description></li><li><description>¿</description></li></ul></remarks><example><p><b>Example:</b></p>Shows how to remove paragraphs with punctuation marks after mail merge operation.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

FieldMergeField mergeFieldOption1 = (FieldMergeField) builder.insertField("MERGEFIELD", "Option_1");
mergeFieldOption1.setFieldName("Option_1");

// Here is the complete list of cleanable punctuation marks:
// !
// ,
// .
// :
// ;
// ?
// ¡
// ¿
builder.write(punctuationMark);

FieldMergeField mergeFieldOption2 = (FieldMergeField) builder.insertField("MERGEFIELD", "Option_2");
mergeFieldOption2.setFieldName("Option_2");

doc.getMailMerge().setCleanupOptions(MailMergeCleanupOptions.REMOVE_EMPTY_PARAGRAPHS);
// The default value of the option is true which means that the behavior was changed to mimic MS Word
// If you rely on the old behavior are able to revert it by setting the option to false
doc.getMailMerge().setCleanupParagraphsWithPunctuationMarks(isCleanupParagraphsWithPunctuationMarks);

doc.getMailMerge().execute(new String[]{"Option_1", "Option_2"}, new Object[]{null, null});

doc.save(getArtifactsDir() + "MailMerge.RemoveColonBetweenEmptyMergeFields.docx");</pre></example>
</DL>
<HR>

<A NAME="FieldMergingCallback"><!-- --></A><A NAME="getFieldMergingCallback()"><!-- --></A><A NAME="getFieldMergingCallback--"><!-- --></A><A NAME="setFieldMergingCallback(com.aspose.words.IFieldMergingCallback)"><!-- --></A><A NAME="setFieldMergingCallback-com.aspose.words.IFieldMergingCallback-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFieldMergingCallback/setFieldMergingCallback</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="IFieldMergingCallback.html" title="interface in com.aspose.words">IFieldMergingCallback</A>&nbsp;<B>getFieldMergingCallback</B>()&nbsp;/&nbsp;public void&nbsp;<B>setFieldMergingCallback</B>(<A HREF="IFieldMergingCallback.html" title="interface in com.aspose.words">IFieldMergingCallback</A>&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Occurs during mail merge when a mail merge field is encountered in the document.
            </summary><example><p><b>Example:</b></p>Shows how to execute a mail merge with a custom callback that handles merge data in the form of HTML documents.<pre>
public void insertHtml() throws Exception {
    Document doc = new Document(getMyDir() + "Field sample - MERGEFIELD.docx");

    // Add a handler for the MergeField event
    doc.getMailMerge().setFieldMergingCallback(new HandleMergeFieldInsertHtml());

    final String htmlText = "&lt;html&gt;\r\n&lt;h1&gt;Hello world!&lt;/h1&gt;\r\n&lt;/html&gt;";

    // Execute mail merge
    doc.getMailMerge().execute(new String[]{"htmlField1"}, new String[]{htmlText});

    // Save resulting document with a new name
    doc.save(getArtifactsDir() + "MailMergeEvent.InsertHtml.docx");
}

private class HandleMergeFieldInsertHtml implements IFieldMergingCallback {
    // This is called when merge field is actually merged with data in the document.
    public void fieldMerging(final FieldMergingArgs args) throws Exception {
        // All merge fields that expect HTML data should be marked with some prefix, e.g. 'html'
        if (args.getDocumentFieldName().startsWith("html") &amp;&amp; args.getField().getFieldCode().contains("\\b")) {
            FieldMergeField field = args.getField();

            // Insert the text for this merge field as HTML data, using DocumentBuilder
            DocumentBuilder builder = new DocumentBuilder(args.getDocument());
            builder.moveToMergeField(args.getDocumentFieldName());
            builder.write(field.getTextBefore());
            builder.insertHtml((String) args.getFieldValue());

            // The HTML text itself should not be inserted
            // We have already inserted it as an HTML
            args.setText("");
        }
    }

    public void /*IFieldMergingCallback.*/imageFieldMerging(ImageFieldMergingArgs args) {
        // Do nothing
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to insert images stored in a database BLOB field into a report.<pre>
public void imageFromBlob() throws Exception {
    Document doc = new Document(getMyDir() + "Mail merge destination - Northwind employees.docx");

    // Set up the event handler for image fields
    doc.getMailMerge().setFieldMergingCallback(new HandleMergeImageFieldFromBlob());

    // Loads the driver
    Class.forName("net.ucanaccess.jdbc.UcanaccessDriver");

    // Open the database connection
    String connString = "jdbc:ucanaccess://" + getDatabaseDir() + "Northwind.accdb";

    // DSN-less DB connection
    java.sql.Connection conn = java.sql.DriverManager.getConnection(connString, "Admin", "");

    // Create and execute a command
    java.sql.Statement statement = conn.createStatement();
    java.sql.ResultSet resultSet = statement.executeQuery("SELECT * FROM Employees");

    DataTable table = new DataTable(resultSet, "Employees");

    // Perform mail merge
    doc.getMailMerge().executeWithRegions(table);

    // Close the database
    conn.close();

    doc.save(getArtifactsDir() + "MailMergeEvent.ImageFromBlob.docx");
}

private class HandleMergeImageFieldFromBlob implements IFieldMergingCallback {
    public void fieldMerging(final FieldMergingArgs args) {
        // Do nothing
    }

    // This is called when mail merge engine encounters Image:XXX merge field in the document.
    // You have a chance to return an Image object, file name or a stream that contains the image.
    public void imageFieldMerging(final ImageFieldMergingArgs e) {
        // The field value is a byte array, just cast it and create a stream on it
        ByteArrayInputStream imageStream = new ByteArrayInputStream((byte[]) e.getFieldValue());
        // Now the mail merge engine will retrieve the image from the stream
        e.setImageStream(imageStream);
    }
}</pre></example>
</DL>
<HR>

<A NAME="MailMergeCallback"><!-- --></A><A NAME="getMailMergeCallback()"><!-- --></A><A NAME="getMailMergeCallback--"><!-- --></A><A NAME="setMailMergeCallback(com.aspose.words.IMailMergeCallback)"><!-- --></A><A NAME="setMailMergeCallback-com.aspose.words.IMailMergeCallback-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getMailMergeCallback/setMailMergeCallback</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="IMailMergeCallback.html" title="interface in com.aspose.words">IMailMergeCallback</A>&nbsp;<B>getMailMergeCallback</B>()&nbsp;/&nbsp;public void&nbsp;<B>setMailMergeCallback</B>(<A HREF="IMailMergeCallback.html" title="interface in com.aspose.words">IMailMergeCallback</A>&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Allows to handle particular events during mail merge.
            </summary><example><p><b>Example:</b></p>Shows how to define custom logic for handling events during mail merge.<pre>
public void testTagsReplacedEventShouldRisedWithUseNonMergeFieldsOption() throws Exception {
    Document document = new Document();
    document.getMailMerge().setUseNonMergeFields(true);

    MailMergeCallbackStub mailMergeCallbackStub = new MailMergeCallbackStub();
    document.getMailMerge().setMailMergeCallback(mailMergeCallbackStub);

    document.getMailMerge().execute(new String[0], new Object[0]);

    Assert.assertEquals(mailMergeCallbackStub.getTagsReplacedCounter(), 1);
}

private static class MailMergeCallbackStub implements IMailMergeCallback {
    public void tagsReplaced() {
        mTagsReplacedCounter++;
    }

    public int getTagsReplacedCounter() {
        return mTagsReplacedCounter;
    }

    private int mTagsReplacedCounter;
}</pre></example>
</DL>
<HR>

<A NAME="MappedDataFields"><!-- --></A><A NAME="getMappedDataFields()"><!-- --></A><A NAME="getMappedDataFields--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getMappedDataFields</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="MappedDataFieldCollection.html" title="class in com.aspose.words">MappedDataFieldCollection</A>&nbsp;<B>getMappedDataFields</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a collection that represents mapped data fields for the mail merge operation.
            </summary><remarks><p>
            Mapped data fields allow to automatically map between names of fields in your data source
            and names of mail merge fields in the document.
            </p></remarks><example><p><b>Example:</b></p>Shows how to map data columns and MERGEFIELDs with different names so the data is transferred between them during a mail merge.<pre>
public void mappedDataFieldCollection() throws Exception {
    // Create a document and table that we will merge
    Document doc = createSourceDocMappedDataFields();
    DataTable dataTable = createSourceTableMappedDataFields();

    // We have a column "Column2" in the data table that doesn't have a respective MERGEFIELD in the document
    // Also, we have a MERGEFIELD named "Column3" that does not exist as a column in the data source
    // If data from "Column2" is suitable for the "Column3" MERGEFIELD,
    // we can map that column name to the MERGEFIELD in the "MappedDataFields" key/value pair
    MappedDataFieldCollection mappedDataFields = doc.getMailMerge().getMappedDataFields();

    // A data source column name is linked to a MERGEFIELD name by adding an element like this
    mappedDataFields.add("MergeFieldName", "DataSourceColumnName");

    // So, values from "Column2" will now go into MERGEFIELDs named "Column3" as well as "Column2", if there are any
    mappedDataFields.add("Column3", "Column2");

    // The MERGEFIELD name is the "key" to the respective data source column name "value"
    Assert.assertEquals(mappedDataFields.get("MergeFieldName"), "DataSourceColumnName");
    Assert.assertTrue(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertTrue(mappedDataFields.containsValue("DataSourceColumnName"));

    // Now if we run this mail merge, the "Column3" MERGEFIELDs will take data from "Column2" of the table
    doc.getMailMerge().execute(dataTable);

    // We can count and iterate over the mapped columns/fields
    Assert.assertEquals(mappedDataFields.getCount(), 2);

    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; enumerator = mappedDataFields.iterator();
    try {
        while (enumerator.hasNext()) {
            Map.Entry&lt;String, String&gt; dataField = enumerator.next();
            System.out.println(MessageFormat.format("Column named {0} is mapped to MERGEFIELDs named {1}", dataField.getValue(), dataField.getKey()));
        }
    } finally {
        if (enumerator != null) enumerator.remove();
    }

    // We can also remove some or all of the elements
    mappedDataFields.remove("MergeFieldName");
    Assert.assertFalse(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertFalse(mappedDataFields.containsValue("DataSourceColumnName"));

    mappedDataFields.clear();
    Assert.assertEquals(mappedDataFields.getCount(), 0);

    // Removing the mapped key/value pairs has no effect on the document because the merge was already done with them in place
    doc.save(getArtifactsDir() + "MailMerge.MappedDataFieldCollection.docx");
}

/// &lt;summary&gt;
/// Create a document with 2 MERGEFIELDs, one of which does not have a corresponding column in the data table.
/// &lt;/summary&gt;
private static Document createSourceDocMappedDataFields() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Insert two MERGEFIELDs that will accept data from that table
    builder.insertField(" MERGEFIELD Column1");
    builder.write(", ");
    builder.insertField(" MERGEFIELD Column3");

    return doc;
}

/// &lt;summary&gt;
/// Create a data table with 2 columns, one of which does not have a corresponding MERGEFIELD in our source document.
/// &lt;/summary&gt;
private static DataTable createSourceTableMappedDataFields() {
    // Create a data table that will be used in a mail merge
    DataTable dataTable = new DataTable("MyTable");
    dataTable.getColumns().add("Column1");
    dataTable.getColumns().add("Column2");
    dataTable.getRows().add("Value1", "Value2");

    return dataTable;
}</pre></example>
</DL>
<HR>

<A NAME="MergeDuplicateRegions"><!-- --></A><A NAME="getMergeDuplicateRegions()"><!-- --></A><A NAME="getMergeDuplicateRegions--"><!-- --></A><A NAME="setMergeDuplicateRegions(boolean)"><!-- --></A><A NAME="setMergeDuplicateRegions-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getMergeDuplicateRegions/setMergeDuplicateRegions</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getMergeDuplicateRegions</B>()&nbsp;/&nbsp;public void&nbsp;<B>setMergeDuplicateRegions</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a value indicating whether all of the document mail merge regions with the name of a data source
            should be merged while executing of a mail merge with regions against the data source or just the first one.
            </summary><remarks>
            The default value is <code>false</code>.
            </remarks><example><p><b>Example:</b></p>Shows how to work with duplicate mail merge regions.<pre>
public void mergeDuplicateRegions(boolean isMergeDuplicateRegions) throws Exception {
    // Create a document and table that we will merge
    Document doc = createSourceDocMergeDuplicateRegions();
    DataTable dataTable = createSourceTableMergeDuplicateRegions();

    // If this property is false, the first region will be merged
    // while the MERGEFIELDs of the second one will be left in the pre-merge state
    // To get both regions merged we would have to execute the mail merge twice, on a table of the same name
    // If this is set to true, both regions will be affected by the merge
    doc.getMailMerge().setMergeDuplicateRegions(isMergeDuplicateRegions);

    doc.getMailMerge().executeWithRegions(dataTable);
    doc.save(getArtifactsDir() + "MailMerge.MergeDuplicateRegions.docx");
}

public static Object[][] mergeDuplicateRegionsDataProvider() {
    return new Object[][]
            {
                    {true},
                    {false},
            };
}

/// &lt;summary&gt;
/// Return a document that contains two duplicate mail merge regions (sharing the same name in the "TableStart/End" tags).
/// &lt;/summary&gt;
private static Document createSourceDocMergeDuplicateRegions() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    builder.insertField(" MERGEFIELD TableStart:MergeRegion");
    builder.insertField(" MERGEFIELD Column1");
    builder.insertField(" MERGEFIELD TableEnd:MergeRegion");
    builder.insertParagraph();

    builder.insertField(" MERGEFIELD TableStart:MergeRegion");
    builder.insertField(" MERGEFIELD Column2");
    builder.insertField(" MERGEFIELD TableEnd:MergeRegion");

    return doc;
}

/// &lt;summary&gt;
/// Create a data table with one row and two columns.
/// &lt;/summary&gt;
private static DataTable createSourceTableMergeDuplicateRegions() {
    DataTable dataTable = new DataTable("MergeRegion");
    dataTable.getColumns().add("Column1");
    dataTable.getColumns().add("Column2");
    dataTable.getRows().add("Value 1", "Value 2");

    return dataTable;
}</pre></example>
</DL>
<HR>

<A NAME="MergeWholeDocument"><!-- --></A><A NAME="getMergeWholeDocument()"><!-- --></A><A NAME="getMergeWholeDocument--"><!-- --></A><A NAME="setMergeWholeDocument(boolean)"><!-- --></A><A NAME="setMergeWholeDocument-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getMergeWholeDocument/setMergeWholeDocument</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getMergeWholeDocument</B>()&nbsp;/&nbsp;public void&nbsp;<B>setMergeWholeDocument</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a value indicating whether fields in whole document are updated while executing of a mail merge with regions.
            </summary><remarks>
            The default value is <code>false</code>.
            </remarks><example><p><b>Example:</b></p>Shows the relationship between mail merges with regions and field updating.<pre>
public void mergeWholeDocument(boolean doMergeWholeDocument) throws Exception {
    // Create a document and data table that will both be merged
    Document doc = createSourceDocMergeWholeDocument();
    DataTable dataTable = createSourceTableMergeWholeDocument();

    // A regular mail merge will update all fields in the document as part of the procedure,
    // which will happen if this property is set to true
    // Otherwise, a mail merge with regions will only update fields
    // within a mail merge region which matches the name of the DataTable
    doc.getMailMerge().setMergeWholeDocument(doMergeWholeDocument);
    doc.getMailMerge().executeWithRegions(dataTable);

    // If true, all fields in the document will be updated upon merging
    // In this case that property is false, so the first QUOTE field will not be updated and will not show a value,
    // but the second one inside the region designated by the data table name will show the correct value
    doc.save(getArtifactsDir() + "MailMerge.MergeWholeDocument.docx");

    Assert.assertEquals(doMergeWholeDocument, doc.getText().contains("This QUOTE field is outside of the \"MyTable\" merge region."));
}

public static Object[][] mergeWholeDocumentDataProvider() throws Exception {
    return new Object[][]
            {
                    {false},
                    {true},
            };
}

/// &lt;summary&gt;
/// Create a document with a QUOTE field outside and one more inside a mail merge region called "MyTable"
/// &lt;/summary&gt;
private static Document createSourceDocMergeWholeDocument() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Insert QUOTE field outside of any mail merge regions
    FieldQuote field = (FieldQuote) builder.insertField(FieldType.FIELD_QUOTE, true);
    field.setText("This QUOTE field is outside of the \"MyTable\" merge region.");

    // Start "MyTable" merge region
    builder.insertParagraph();
    builder.insertField(" MERGEFIELD TableStart:MyTable");

    // Insert QUOTE field inside "MyTable" merge region
    field = (FieldQuote) builder.insertField(FieldType.FIELD_QUOTE, true);
    field.setText("This QUOTE field is inside the \"MyTable\" merge region.");
    builder.insertParagraph();

    // Add a MERGEFIELD for a column in the data table, end the "MyTable" region and return the document
    builder.insertField(" MERGEFIELD MyColumn");
    builder.insertField(" MERGEFIELD TableEnd:MyTable");

    return doc;
}

/// &lt;summary&gt;
/// Create a simple data table that will be used in a mail merge.
/// &lt;/summary&gt;
private static DataTable createSourceTableMergeWholeDocument() {
    DataTable dataTable = new DataTable("MyTable");
    dataTable.getColumns().add("MyColumn");
    dataTable.getRows().add("MyValue");

    return dataTable;
}</pre></example>
</DL>
<HR>

<A NAME="PreserveUnusedTags"><!-- --></A><A NAME="getPreserveUnusedTags()"><!-- --></A><A NAME="getPreserveUnusedTags--"><!-- --></A><A NAME="setPreserveUnusedTags(boolean)"><!-- --></A><A NAME="setPreserveUnusedTags-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPreserveUnusedTags/setPreserveUnusedTags</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getPreserveUnusedTags</B>()&nbsp;/&nbsp;public void&nbsp;<B>setPreserveUnusedTags</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a value indicating whether the unused "mustache" tags should be preserved.
            </summary><remarks>
            The default value is <code>false</code>.
            </remarks><example><p><b>Example:</b></p>Shows how to preserve the appearance of alternative mail merge tags that go unused during a mail merge.<pre>
public void preserveUnusedTags(boolean doPreserveUnusedTags) throws Exception {
    // Create a document and table that we will merge
    Document doc = createSourceDocWithAlternativeMergeFields();
    DataTable dataTable = createSourceTablePreserveUnusedTags();

    // By default, alternative merge tags that can't receive data because the data source has no columns with their name
    // are converted to and left on display as MERGEFIELDs after the mail merge
    // We can preserve their original appearance setting this attribute to true
    doc.getMailMerge().setPreserveUnusedTags(doPreserveUnusedTags);
    doc.getMailMerge().execute(dataTable);

    doc.save(getArtifactsDir() + "MailMerge.PreserveUnusedTags.docx");

    Assert.assertEquals(doc.getText().contains("{{ Column2 }}"), doPreserveUnusedTags);
}

public static Object[][] preserveUnusedTagsDataProvider() throws Exception {
    return new Object[][]
            {
                    {false},
                    {true},
            };
}

/// &lt;summary&gt;
/// Create a document and add two tags that can accept mail merge data that are not the traditional MERGEFIELDs.
/// &lt;/summary&gt;
private static Document createSourceDocWithAlternativeMergeFields() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    builder.writeln("{{ Column1 }}");
    builder.writeln("{{ Column2 }}");

    // Our tags will only register as destinations for mail merge data if we set this to true
    doc.getMailMerge().setUseNonMergeFields(true);

    return doc;
}

/// &lt;summary&gt;
/// Create a simple data table with one column.
/// &lt;/summary&gt;
private static DataTable createSourceTablePreserveUnusedTags() {
    DataTable dataTable = new DataTable("MyTable");
    dataTable.getColumns().add("Column1");
    dataTable.getRows().add("Value1");

    return dataTable;
}</pre></example><DL><DT><B>See Also:</B></DT><DD><cref seealso=""><A HREF="#UseNonMergeFields" title="property in class com.aspose.words.MailMerge">UseNonMergeFields</A></cref></DD></DL>
</DL>
<HR>

<A NAME="RegionEndTag"><!-- --></A><A NAME="getRegionEndTag()"><!-- --></A><A NAME="getRegionEndTag--"><!-- --></A><A NAME="setRegionEndTag(java.lang.String)"><!-- --></A><A NAME="setRegionEndTag-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRegionEndTag/setRegionEndTag</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getRegionEndTag</B>()&nbsp;/&nbsp;public void&nbsp;<B>setRegionEndTag</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a mail merge region end tag.
            </summary><example><p><b>Example:</b></p>Shows how to create, list, and read mail merge regions.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// These tags, which go inside MERGEFIELDs, denote the strings that signify the starts and ends of mail merge regions
Assert.assertEquals(doc.getMailMerge().getRegionStartTag(), "TableStart");
Assert.assertEquals(doc.getMailMerge().getRegionEndTag(), "TableEnd");

// By using these tags, we will start and end a "MailMergeRegion1", which will contain MERGEFIELDs for two columns
builder.insertField(" MERGEFIELD TableStart:MailMergeRegion1");
builder.insertField(" MERGEFIELD Column1");
builder.write(", ");
builder.insertField(" MERGEFIELD Column2");
builder.insertField(" MERGEFIELD TableEnd:MailMergeRegion1");

// We can keep track of merge regions and their columns by looking at these collections
ArrayList&lt;MailMergeRegionInfo&gt; regions = doc.getMailMerge().getRegionsByName("MailMergeRegion1");
Assert.assertEquals(regions.size(), 1);
Assert.assertEquals(regions.get(0).getName(), "MailMergeRegion1");

String[] mergeFieldNames = doc.getMailMerge().getFieldNamesForRegion("MailMergeRegion1");
Assert.assertEquals(mergeFieldNames[0], "Column1");
Assert.assertEquals(mergeFieldNames[1], "Column2");

// Insert a region with the same name inside the existing region, which will make it a parent.
// Now a "Column2" field will be inside a new region.
builder.moveToField(regions.get(0).getFields().get(1), false);
builder.insertField(" MERGEFIELD TableStart:MailMergeRegion1");
builder.moveToField(regions.get(0).getFields().get(1), true);
builder.insertField(" MERGEFIELD TableEnd:MailMergeRegion1");

// Regions that share the same name are still accounted for and can be accessed by index
regions = doc.getMailMerge().getRegionsByName("MailMergeRegion1");
Assert.assertEquals(regions.size(), 2);
// Check that the second region now has a parent region.
Assert.assertEquals("MailMergeRegion1", regions.get(1).getParentRegion().getName());

mergeFieldNames = doc.getMailMerge().getFieldNamesForRegion("MailMergeRegion1", 1);
Assert.assertEquals(mergeFieldNames[0], "Column2");</pre></example>
</DL>
<HR>

<A NAME="RegionStartTag"><!-- --></A><A NAME="getRegionStartTag()"><!-- --></A><A NAME="getRegionStartTag--"><!-- --></A><A NAME="setRegionStartTag(java.lang.String)"><!-- --></A><A NAME="setRegionStartTag-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRegionStartTag/setRegionStartTag</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getRegionStartTag</B>()&nbsp;/&nbsp;public void&nbsp;<B>setRegionStartTag</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a mail merge region start tag.
            </summary><example><p><b>Example:</b></p>Shows how to create, list, and read mail merge regions.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// These tags, which go inside MERGEFIELDs, denote the strings that signify the starts and ends of mail merge regions
Assert.assertEquals(doc.getMailMerge().getRegionStartTag(), "TableStart");
Assert.assertEquals(doc.getMailMerge().getRegionEndTag(), "TableEnd");

// By using these tags, we will start and end a "MailMergeRegion1", which will contain MERGEFIELDs for two columns
builder.insertField(" MERGEFIELD TableStart:MailMergeRegion1");
builder.insertField(" MERGEFIELD Column1");
builder.write(", ");
builder.insertField(" MERGEFIELD Column2");
builder.insertField(" MERGEFIELD TableEnd:MailMergeRegion1");

// We can keep track of merge regions and their columns by looking at these collections
ArrayList&lt;MailMergeRegionInfo&gt; regions = doc.getMailMerge().getRegionsByName("MailMergeRegion1");
Assert.assertEquals(regions.size(), 1);
Assert.assertEquals(regions.get(0).getName(), "MailMergeRegion1");

String[] mergeFieldNames = doc.getMailMerge().getFieldNamesForRegion("MailMergeRegion1");
Assert.assertEquals(mergeFieldNames[0], "Column1");
Assert.assertEquals(mergeFieldNames[1], "Column2");

// Insert a region with the same name inside the existing region, which will make it a parent.
// Now a "Column2" field will be inside a new region.
builder.moveToField(regions.get(0).getFields().get(1), false);
builder.insertField(" MERGEFIELD TableStart:MailMergeRegion1");
builder.moveToField(regions.get(0).getFields().get(1), true);
builder.insertField(" MERGEFIELD TableEnd:MailMergeRegion1");

// Regions that share the same name are still accounted for and can be accessed by index
regions = doc.getMailMerge().getRegionsByName("MailMergeRegion1");
Assert.assertEquals(regions.size(), 2);
// Check that the second region now has a parent region.
Assert.assertEquals("MailMergeRegion1", regions.get(1).getParentRegion().getName());

mergeFieldNames = doc.getMailMerge().getFieldNamesForRegion("MailMergeRegion1", 1);
Assert.assertEquals(mergeFieldNames[0], "Column2");</pre></example>
</DL>
<HR>

<A NAME="RestartListsAtEachSection"><!-- --></A><A NAME="getRestartListsAtEachSection()"><!-- --></A><A NAME="getRestartListsAtEachSection--"><!-- --></A><A NAME="setRestartListsAtEachSection(boolean)"><!-- --></A><A NAME="setRestartListsAtEachSection-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRestartListsAtEachSection/setRestartListsAtEachSection</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getRestartListsAtEachSection</B>()&nbsp;/&nbsp;public void&nbsp;<B>setRestartListsAtEachSection</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a value indicating whether lists are restarted at each section after executing of a mail merge.
            </summary><remarks>
            The default value is <code>true</code>.
            </remarks><example><p><b>Example:</b></p>Shows how to control whether or not list numbering is restarted at each section when mail merge is performed.<pre>
Document doc = new Document(getMyDir() + "Section breaks with numbering.docx");

doc.getMailMerge().setRestartListsAtEachSection(false);
doc.getMailMerge().execute(new String[0], new Object[0]);

doc.save(getArtifactsDir() + "MailMerge.RestartListsAtEachSection.pdf");</pre></example>
</DL>
<HR>

<A NAME="RetainFirstSectionStart"><!-- --></A><A NAME="getRetainFirstSectionStart()"><!-- --></A><A NAME="getRetainFirstSectionStart--"><!-- --></A><A NAME="setRetainFirstSectionStart(boolean)"><!-- --></A><A NAME="setRetainFirstSectionStart-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRetainFirstSectionStart/setRetainFirstSectionStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getRetainFirstSectionStart</B>()&nbsp;/&nbsp;public void&nbsp;<B>setRetainFirstSectionStart</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a value indicating whether the <cref><A HREF="PageSetup.html#SectionStart" title="property in class com.aspose.words.PageSetup">PageSetup.SectionStart</A></cref> of the first document section and its copies for subsequent data source rows
            are retained during mail merge or updated according to MS Word behaviour.
            </summary><remarks>
            The default value is <code>true</code>.
            </remarks>
</DL>
<HR>

<A NAME="TrimWhitespaces"><!-- --></A><A NAME="getTrimWhitespaces()"><!-- --></A><A NAME="getTrimWhitespaces--"><!-- --></A><A NAME="setTrimWhitespaces(boolean)"><!-- --></A><A NAME="setTrimWhitespaces-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getTrimWhitespaces/setTrimWhitespaces</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getTrimWhitespaces</B>()&nbsp;/&nbsp;public void&nbsp;<B>setTrimWhitespaces</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a value indicating whether trailing and leading whitespaces are trimmed from mail merge values.
            </summary><remarks>
            The default value is <code>true</code>.
            </remarks><example><p><b>Example:</b></p>Shows how to trimmed whitespaces from mail merge values.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.insertField("MERGEFIELD myMergeField", null);

doc.getMailMerge().setTrimWhitespaces(doTrimWhitespaces);
doc.getMailMerge().execute(new String[]{"myMergeField"}, new Object[]{"\t hello world! "});

if (doTrimWhitespaces)
    Assert.assertEquals("hello world!\f", doc.getText());
else
    Assert.assertEquals("\t hello world! \f", doc.getText());</pre></example>
</DL>
<HR>

<A NAME="UnconditionalMergeFieldsAndRegions"><!-- --></A><A NAME="getUnconditionalMergeFieldsAndRegions()"><!-- --></A><A NAME="getUnconditionalMergeFieldsAndRegions--"><!-- --></A><A NAME="setUnconditionalMergeFieldsAndRegions(boolean)"><!-- --></A><A NAME="setUnconditionalMergeFieldsAndRegions-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getUnconditionalMergeFieldsAndRegions/setUnconditionalMergeFieldsAndRegions</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getUnconditionalMergeFieldsAndRegions</B>()&nbsp;/&nbsp;public void&nbsp;<B>setUnconditionalMergeFieldsAndRegions</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a value indicating whether merge fields and merge regions are merged regardless of the parent IF field's condition.
            </summary><remarks>
            The default value is <code>false</code>.
            </remarks><example><p><b>Example:</b></p>Shows how to merge fields or regions regardless of the parent IF field's condition.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Insert a MERGEFIELD nested inside an IF field
// Since the statement of the IF field is false, the result of the inner MERGEFIELD will not be displayed
// and the MERGEFIELD will not receive any data during a mail merge
FieldIf fieldIf = (FieldIf) builder.insertField(" IF 1 = 2 ");
builder.moveTo(fieldIf.getSeparator());
builder.insertField(" MERGEFIELD  FullName ");

// We can still count MERGEFIELDs inside false-statement IF fields if we set this flag to true
doc.getMailMerge().setUnconditionalMergeFieldsAndRegions(doCountAllMergeFields);

DataTable dataTable = new DataTable();
dataTable.getColumns().add("FullName");
dataTable.getRows().add("James Bond");

// Execute the mail merge
doc.getMailMerge().execute(dataTable);

// The result will not be visible in the document because the IF field is false, but the inner MERGEFIELD did indeed receive data
doc.save(getArtifactsDir() + "MailMerge.UnconditionalMergeFieldsAndRegions.docx");

if (doCountAllMergeFields)
    Assert.assertEquals("IF 1 = 2 \"James Bond\"", doc.getText().trim());
else
    Assert.assertEquals("IF 1 = 2 \u0013 MERGEFIELD  FullName \u0014«FullName»", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="UseNonMergeFields"><!-- --></A><A NAME="getUseNonMergeFields()"><!-- --></A><A NAME="getUseNonMergeFields--"><!-- --></A><A NAME="setUseNonMergeFields(boolean)"><!-- --></A><A NAME="setUseNonMergeFields-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getUseNonMergeFields/setUseNonMergeFields</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getUseNonMergeFields</B>()&nbsp;/&nbsp;public void&nbsp;<B>setUseNonMergeFields</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
             When <code>true</code>, specifies that in addition to MERGEFIELD fields, mail merge is performed into some other types of fields and
             also into "{{fieldName}}" tags.
             </summary><remarks><p>Normally, mail merge is only performed into MERGEFIELD fields, but several customers had their reporting
             built using other fields and had many documents created this way. To simplify migration (and because this
             approach was independently used by several customers) the ability to mail merge into other fields was introduced.</p><p>When <cref><i>UseNonMergeFields</i></cref> is set to <code>true</code>, Aspose.Words will perform mail merge into the following fields:</p><p>MERGEFIELD FieldName</p><p>MACROBUTTON NOMACRO FieldName</p><p>IF 0 = 0 "{FieldName}" ""</p><p>Also, when <cref><i>UseNonMergeFields</i></cref> is set to <code>true</code>, Aspose.Words will perform mail merge into text tags
             "{{fieldName}}". These are not fields, but just text tags.</p></remarks><example><p><b>Example:</b></p>Shows how to perform mail merge into merge fields and into additional fields types.<pre>
doc.getMailMerge().setUseNonMergeFields(true);</pre></example>
</DL>
<HR>

<A NAME="UseWholeParagraphAsRegion"><!-- --></A><A NAME="getUseWholeParagraphAsRegion()"><!-- --></A><A NAME="getUseWholeParagraphAsRegion--"><!-- --></A><A NAME="setUseWholeParagraphAsRegion(boolean)"><!-- --></A><A NAME="setUseWholeParagraphAsRegion-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getUseWholeParagraphAsRegion/setUseWholeParagraphAsRegion</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getUseWholeParagraphAsRegion</B>()&nbsp;/&nbsp;public void&nbsp;<B>setUseWholeParagraphAsRegion</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a value indicating whether whole paragraph with <b>TableStart</b> or <b>TableEnd</b> field
            or particular range between <b>TableStart</b> and <b>TableEnd</b> fields should be included into mail merge region.
            </summary><remarks>
            The default value is <code>true</code>.
            </remarks><example><p><b>Example:</b></p>Shows the relationship between mail merge regions and paragraphs.<pre>
public void useWholeParagraphAsRegion() throws Exception {
    // Create a document with 2 mail merge regions in one paragraph and a table to which can fill one of the regions during a mail merge
    Document doc = createSourceDocWithNestedMergeRegions();
    DataTable dataTable = createSourceTableDataTableForOneRegion();

    // By default, a paragraph can belong to no more than one mail merge region
    // Our document breaks this rule so executing a mail merge with regions now will cause an exception to be thrown
    Assert.assertTrue(doc.getMailMerge().getUseWholeParagraphAsRegion());
    Assert.assertThrows(IllegalStateException.class, () -&gt; doc.getMailMerge().executeWithRegions(dataTable));

    // If we set this variable to false, paragraphs and mail merge regions are independent so we can safely run our mail merge
    doc.getMailMerge().setUseWholeParagraphAsRegion(false);
    doc.getMailMerge().executeWithRegions(dataTable);

    // Our first region is populated, while our second is safely displayed as unused all across one paragraph
    doc.save(getArtifactsDir() + "MailMerge.UseWholeParagraphAsRegion.docx");
}

/// &lt;summary&gt;
/// Create a document with two mail merge regions sharing one paragraph.
/// &lt;/summary&gt;
private static Document createSourceDocWithNestedMergeRegions() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    builder.write("Region 1: ");
    builder.insertField(" MERGEFIELD TableStart:MyTable");
    builder.insertField(" MERGEFIELD Column1");
    builder.write(", ");
    builder.insertField(" MERGEFIELD Column2");
    builder.insertField(" MERGEFIELD TableEnd:MyTable");

    builder.write(", Region 2: ");
    builder.insertField(" MERGEFIELD TableStart:MyOtherTable");
    builder.insertField(" MERGEFIELD TableEnd:MyOtherTable");

    return doc;
}

/// &lt;summary&gt;
/// Create a data table that can populate one region during a mail merge.
/// &lt;/summary&gt;
private static DataTable createSourceTableDataTableForOneRegion() {
    DataTable dataTable = new DataTable("MyTable");
    dataTable.getColumns().add("Column1");
    dataTable.getColumns().add("Column2");
    dataTable.getRows().add("Value 1", "Value 2");

    return dataTable;
}</pre></example>
</DL>
<HR>



<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="deleteFields()"><!-- --></A><A NAME="deleteFields--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>deleteFields</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>deleteFields</B>()
                 throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Removes mail merge related fields from the document.
             </summary><remarks><p>This method removes MERGEFIELD and NEXT fields from the document.</p><p>This method could be useful if your mail merge operation does not always need
             to populate all fields in the document. Use this method to remove all remaining
             mail merge fields.</p></remarks><example><p><b>Example:</b></p>Shows how to delete all merge fields from a document without executing mail merge.<pre>
doc.getMailMerge().deleteFields();</pre></example>
</DL>
<HR>

<A NAME="execute(com.aspose.words.IMailMergeDataSource)"><!-- --></A><A NAME="execute-com.aspose.words.IMailMergeDataSource-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>execute</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>execute</B>(<A HREF="IMailMergeDataSource.html" title="interface in com.aspose.words">IMailMergeDataSource</A>&nbsp;dataSource)
            throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Performs a mail merge from a custom data source.
            </summary><remarks><p>Use this method to fill mail merge fields in the document with values from
            any data source such as a list or hashtable or objects. You need to write your
            own class that implements the <cref><A HREF="IMailMergeDataSource.html" title="interface in com.aspose.words">IMailMergeDataSource</A></cref> interface.</p><p>You can use this method only when <cref><A HREF="FieldOptions.html#IsBidiTextSupportedOnUpdate" title="property in class com.aspose.words.FieldOptions">FieldOptions.IsBidiTextSupportedOnUpdate</A></cref> is <code>false</code>,
            that is you do not need Right-To-Left language (such as Arabic or Hebrew) compatibility.</p><p>This method ignores the <cref><A HREF="MailMergeCleanupOptions.html#REMOVE_UNUSED_REGIONS" title="field in class com.aspose.words.MailMergeCleanupOptions">MailMergeCleanupOptions.REMOVE_UNUSED_REGIONS</A></cref> option.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="dataSource"><CODE>dataSource</CODE> - An object that implements the custom mail merge data source interface.</DD></DL><example><p><b>Example:</b></p>Shows how to execute a mail merge with a data source in the form of a custom object.<pre>
public void customDataSource() throws Exception {
    // Create a destination document for the mail merge
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);
    builder.insertField(" MERGEFIELD FullName ");
    builder.insertParagraph();
    builder.insertField(" MERGEFIELD Address ");

    // Create some data that we will use in the mail merge
    CustomerList customers = new CustomerList();
    customers.add(new Customer("Thomas Hardy", "120 Hanover Sq., London"));
    customers.add(new Customer("Paolo Accorti", "Via Monte Bianco 34, Torino"));

    // To be able to mail merge from your own data source, it must be wrapped
    // into an object that implements the IMailMergeDataSource interface
    CustomerMailMergeDataSource customersDataSource = new CustomerMailMergeDataSource(customers);

    // Now you can pass your data source into Aspose.Words
    doc.getMailMerge().execute(customersDataSource);

    doc.save(getArtifactsDir() + "MailMergeCustom.CustomDataSource.docx");
}

// An example of a "data entity" class in your application.
public class Customer {
    public Customer(final String aFullName, final String anAddress) {
        mFullName = aFullName;
        mAddress = anAddress;
    }

    public String getFullName() {
        return mFullName;
    }

    public void setFullName(final String value) {
        mFullName = value;
    }

    public String getAddress() {
        return mAddress;
    }

    public void setAddress(final String value) {
        mAddress = value;
    }

    private String mFullName;
    private String mAddress;
}

// An example of a typed collection that contains your "data" objects.
public class CustomerList extends ArrayList {
    public Customer get(final int index) {
        return (Customer) super.get(index);
    }

    public void set(final int index, final Customer value) {
        super.set(index, value);
    }
}

// A custom mail merge data source that you implement to allow Aspose.Words
// to mail merge data from your Customer objects into Microsoft Word documents.
public class CustomerMailMergeDataSource implements IMailMergeDataSource {
    public CustomerMailMergeDataSource(final CustomerList customers) {
        mCustomers = customers;

        // When the data source is initialized, it must be positioned before the first record.
        mRecordIndex = -1;
    }

    // The name of the data source. Used by Aspose.Words only when executing mail merge with repeatable regions.
    public String getTableName() {
        return "Customer";
    }

    // Aspose.Words calls this method to get a value for every data field.
    public boolean getValue(final String fieldName, final Ref&lt;Object&gt; fieldValue) throws Exception {
        if (fieldName.equals("FullName")) {
            fieldValue.set(mCustomers.get(mRecordIndex).getFullName());
            return true;
        } else if (fieldName.equals("Address")) {
            fieldValue.set(mCustomers.get(mRecordIndex).getAddress());
            return true;
        } else {
            // A field with this name was not found,
            // return false to the Aspose.Words mail merge engine
            fieldValue.set(null);
            return false;
        }
    }

    // A standard implementation for moving to a next record in a collection.
    public boolean moveNext() {
        if (!isEof()) mRecordIndex++;

        return (!isEof());
    }

    public IMailMergeDataSource getChildDataSource(final String tableName) {
        return null;
    }

    private boolean isEof() {
        return (mRecordIndex &gt;= mCustomers.size());
    }

    private final CustomerList mCustomers;
    private int mRecordIndex;
}</pre></example>
</DL>
<HR>

<A NAME="execute(com.aspose.words.net.System.Data.DataRow)"><!-- --></A><A NAME="execute-com.aspose.words.net.System.Data.DataRow-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>execute</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>execute</B>(com.aspose.words.net.System.Data.DataRow&nbsp;row)
            throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Performs mail merge from a <b>DataRow</b> into the document.
            </summary><remarks><p>Use this method to fill mail merge fields in the document with values from a <b>DataRow</b>.</p><p>This method ignores the <cref><A HREF="MailMergeCleanupOptions.html#REMOVE_UNUSED_REGIONS" title="field in class com.aspose.words.MailMergeCleanupOptions">MailMergeCleanupOptions.REMOVE_UNUSED_REGIONS</A></cref> option.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="row"><CODE>row</CODE> - Row that contains data to be inserted into mail merge fields.
            Field names are not case sensitive.
            If a field name that is not found in the document is encountered, it is ignored.</DD></DL><example><p><b>Example:</b></p>Shows how to execute a mail merge with data from a DataTable.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField(" MERGEFIELD CustomerName ");
builder.insertParagraph();
builder.insertField(" MERGEFIELD Address ");

// This example creates a table, but you would normally load table from a database
DataTable table = new DataTable("Test");
table.getColumns().add("CustomerName");
table.getColumns().add("Address");
table.getRows().add("Thomas Hardy", "120 Hanover Sq., London");
table.getRows().add("Paolo Accorti", "Via Monte Bianco 34, Torino");

// Field values from the table are inserted into the mail merge fields found in the document
doc.getMailMerge().execute(table);

doc.save(getArtifactsDir() + "MailMerge.ExecuteDataTable.docx");

// Create a copy of our document to perform another mail merge
doc = new Document();
builder = new DocumentBuilder(doc);
builder.insertField(" MERGEFIELD CustomerName ");
builder.insertParagraph();
builder.insertField(" MERGEFIELD Address ");

// We can also source values for a mail merge from a single row in the table
doc.getMailMerge().execute(table.getRows().get(1));

doc.save(getArtifactsDir() + "MailMerge.ExecuteDataTable.OneRow.docx");</pre></example>
</DL>
<HR>

<A NAME="execute(com.aspose.words.net.System.Data.DataTable)"><!-- --></A><A NAME="execute-com.aspose.words.net.System.Data.DataTable-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>execute</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>execute</B>(com.aspose.words.net.System.Data.DataTable&nbsp;table)
            throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Performs mail merge from a com.aspose.words.net.System.Data.DataTable into the document.
             </summary><remarks><p>Use this method to fill mail merge fields in the document with values from a
             <b>DataTable</b>.</p><p>All records from the table are merged into the document.</p><p>You can use NEXT field in the Word document to cause <cref><i>MailMerge</i></cref> object to select
             next record from the <b>DataTable</b> and continue merging.
             This can be used when creating  documents such as mailing labels.</p><p>When <cref><i>MailMerge</i></cref> object reaches end of the main document and there are still more
             rows in the <b>DataTable</b>, it copies entire content of
             the main document and appends it to the end of the destination document using a section
             break as a separator.</p><p>This method ignores the <cref><A HREF="MailMergeCleanupOptions.html#REMOVE_UNUSED_REGIONS" title="field in class com.aspose.words.MailMergeCleanupOptions">MailMergeCleanupOptions.REMOVE_UNUSED_REGIONS</A></cref> option.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="table"><CODE>table</CODE> - Table that contains data to be inserted into mail merge fields.
             Field names are not case sensitive.
             If a field name that is not found in the document is encountered, it is ignored.</DD></DL><example><p><b>Example:</b></p>Shows how to execute a mail merge with data from a DataTable.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField(" MERGEFIELD CustomerName ");
builder.insertParagraph();
builder.insertField(" MERGEFIELD Address ");

// This example creates a table, but you would normally load table from a database
DataTable table = new DataTable("Test");
table.getColumns().add("CustomerName");
table.getColumns().add("Address");
table.getRows().add("Thomas Hardy", "120 Hanover Sq., London");
table.getRows().add("Paolo Accorti", "Via Monte Bianco 34, Torino");

// Field values from the table are inserted into the mail merge fields found in the document
doc.getMailMerge().execute(table);

doc.save(getArtifactsDir() + "MailMerge.ExecuteDataTable.docx");

// Create a copy of our document to perform another mail merge
doc = new Document();
builder = new DocumentBuilder(doc);
builder.insertField(" MERGEFIELD CustomerName ");
builder.insertParagraph();
builder.insertField(" MERGEFIELD Address ");

// We can also source values for a mail merge from a single row in the table
doc.getMailMerge().execute(table.getRows().get(1));

doc.save(getArtifactsDir() + "MailMerge.ExecuteDataTable.OneRow.docx");</pre></example>
</DL>
<HR>

<A NAME="execute(com.aspose.words.net.System.Data.DataView)"><!-- --></A><A NAME="execute-com.aspose.words.net.System.Data.DataView-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>execute</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>execute</B>(com.aspose.words.net.System.Data.DataView&nbsp;dataView)
            throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Performs mail merge from a <b>DataView</b> into the document.
             </summary><remarks><p>This method is useful if you retrieve data into a <b>DataTable</b> but then
             need to apply a filter or sort before the mail merge.</p><p>Note this method does not use mail merge regions and for multiple records the
             document will grow by repeating the whole document.</p><p>This method ignores the <cref><A HREF="MailMergeCleanupOptions.html#REMOVE_UNUSED_REGIONS" title="field in class com.aspose.words.MailMergeCleanupOptions">MailMergeCleanupOptions.REMOVE_UNUSED_REGIONS</A></cref> option.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="dataView"><CODE>dataView</CODE> - Data source for the mail merge operation.</DD></DL>
</DL>
<HR>

<A NAME="execute(com.aspose.words.net.System.Data.IDataReader)"><!-- --></A><A NAME="execute-com.aspose.words.net.System.Data.IDataReader-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>execute</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>execute</B>(com.aspose.words.net.System.Data.IDataReader&nbsp;dataReader)
            throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Performs mail merge from <b>IDataReader</b> into the document.
             </summary><remarks><p>You can pass <b>SqlDataReader</b> or <b>OleDbDataReader</b> object into this
             method as a parameter because they both implemented <b>IDataReader</b> interface.</p><p>Note this method does not use mail merge regions and for multiple records the
             document will grow by repeating the whole document.</p><p>This method ignores the <cref><A HREF="MailMergeCleanupOptions.html#REMOVE_UNUSED_REGIONS" title="field in class com.aspose.words.MailMergeCleanupOptions">MailMergeCleanupOptions.REMOVE_UNUSED_REGIONS</A></cref> option.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="dataReader"><CODE>dataReader</CODE> - Data source for the mail merge operation.</DD></DL><example><p><b>Example:</b></p>Shows how to run a mail merge using data from a data reader.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.write("Product:\t");
builder.insertField(" MERGEFIELD ProductName");
builder.write("\nSupplier:\t");
builder.insertField(" MERGEFIELD CompanyName");
builder.writeln();
builder.insertField(" MERGEFIELD QuantityPerUnit");
builder.write(" for $");
builder.insertField(" MERGEFIELD UnitPrice");

// "DocumentHelper.executeDataTable" is utility function that creates a connection, command,
// executes the command and return the result in a DataTable.
ResultSet resultSet = DocumentHelper.executeDataTable(
        "SELECT Products.ProductName, Suppliers.CompanyName, Products.QuantityPerUnit, " +
                "{fn ROUND(Products.UnitPrice,2)} as UnitPrice " +
                "FROM Products INNER JOIN Suppliers ON Products.SupplierID = Suppliers.SupplierID");
DataTable dataTable = new DataTable(resultSet, "OrderDetails");
IDataReader dataReader = new DataTableReader(dataTable);

// Now we can take the data from the reader and use it in the mail merge.
doc.getMailMerge().execute(dataReader);

doc.save(getArtifactsDir() + "MailMerge.ExecuteDataReader.docx");</pre></example>
</DL>
<HR>

<A NAME="execute(java.lang.String[],java.lang.Object[])"><!-- --></A><A NAME="execute-java.lang.String:A-java.lang.Object:A-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>execute</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>execute</B>(java.lang.String[]&nbsp;fieldNames, java.lang.Object[]&nbsp;values)
            throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Performs a mail merge operation for a single record.
             </summary><remarks><p>Use this method to fill mail merge fields in the document with values from
             an array of objects.</p><p>This method merges data for one record only. The array of field names
             and the array of values represent the data of a single record.</p><p>This method does not use mail merge regions.</p><p>This method ignores the <cref><A HREF="MailMergeCleanupOptions.html#REMOVE_UNUSED_REGIONS" title="field in class com.aspose.words.MailMergeCleanupOptions">MailMergeCleanupOptions.REMOVE_UNUSED_REGIONS</A></cref> option.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="fieldNames"><CODE>fieldNames</CODE> - Array of merge field names. Field names are not case sensitive.
             If a field name that is not found in the document is encountered, it is ignored.</DD><DD param="values"><CODE>values</CODE> - Array of values to be inserted into the merge fields.
             Number of elements in this array must be the same as the number of elements in <i>fieldNames</i>.</DD></DL><example><p><b>Example:</b></p>Shows how to perform a mail merge, and then save the document to the client browser.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.insertField(" MERGEFIELD FullName ");
builder.insertParagraph();
builder.insertField(" MERGEFIELD Company ");
builder.insertParagraph();
builder.insertField(" MERGEFIELD Address ");
builder.insertParagraph();
builder.insertField(" MERGEFIELD City ");

doc.getMailMerge().execute(new String[]{"FullName", "Company", "Address", "City"},
        new Object[]{"James Bond", "MI5 Headquarters", "Milbank", "London"});</pre></example><example><p><b>Example:</b></p>Demonstrates how to merge an image from a web address using an Image field.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField("MERGEFIELD  Image:Logo ");

// Pass a URL which points to the image to merge into the document
doc.getMailMerge().execute(new String[]{"Logo"}, new Object[]{DocumentHelper.getBytesFromStream(getAsposelogoUri().toURL().openStream())});

doc.save(getArtifactsDir() + "MailMergeEvent.ImageFromUrl.doc");</pre></example>
</DL>
<HR>

<A NAME="executeWithRegions(com.aspose.words.IMailMergeDataSource)"><!-- --></A><A NAME="executeWithRegions-com.aspose.words.IMailMergeDataSource-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>executeWithRegions</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>executeWithRegions</B>(<A HREF="IMailMergeDataSource.html" title="interface in com.aspose.words">IMailMergeDataSource</A>&nbsp;dataSource)
                       throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Performs a mail merge from a custom data source with mail merge regions.
            </summary><remarks><p>Use this method to fill mail merge fields in the document with values from
            any custom data source such as an XML file or collections of business objects. You need to write your
            own class that implements the <cref><A HREF="IMailMergeDataSource.html" title="interface in com.aspose.words">IMailMergeDataSource</A></cref> interface.</p><p>You can use this method only when <cref><A HREF="FieldOptions.html#IsBidiTextSupportedOnUpdate" title="property in class com.aspose.words.FieldOptions">FieldOptions.IsBidiTextSupportedOnUpdate</A></cref> is <code>false</code>,
            that is you do not need Right-To-Left language (such as Arabic or Hebrew) compatibility.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="dataSource"><CODE>dataSource</CODE> - An object that implements the custom mail merge data source interface.</DD></DL>
</DL>
<HR>

<A NAME="executeWithRegions(com.aspose.words.IMailMergeDataSourceRoot)"><!-- --></A><A NAME="executeWithRegions-com.aspose.words.IMailMergeDataSourceRoot-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>executeWithRegions</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>executeWithRegions</B>(<A HREF="IMailMergeDataSourceRoot.html" title="interface in com.aspose.words">IMailMergeDataSourceRoot</A>&nbsp;dataSourceRoot)
                       throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Performs a mail merge from a custom data source with mail merge regions.
            </summary><remarks><p>Use this method to fill mail merge fields in the document with values from
            any custom data source such as an XML file or collections of business objects. You need to write your own classes
            that implement the <cref><A HREF="IMailMergeDataSourceRoot.html" title="interface in com.aspose.words">IMailMergeDataSourceRoot</A></cref> and <cref><A HREF="IMailMergeDataSource.html" title="interface in com.aspose.words">IMailMergeDataSource</A></cref> interfaces.</p><p>You can use this method only when <cref><A HREF="FieldOptions.html#IsBidiTextSupportedOnUpdate" title="property in class com.aspose.words.FieldOptions">FieldOptions.IsBidiTextSupportedOnUpdate</A></cref> is <code>false</code>,
            that is you do not need Right-To-Left language (such as Arabic or Hebrew) compatibility.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="dataSourceRoot"><CODE>dataSourceRoot</CODE> - An object that implements the custom mail merge data source root interface.</DD></DL><example><p><b>Example:</b></p>Performs mail merge from a custom data source with master-detail data.<pre>
public void customDataSourceRoot() throws Exception {
    // Create a document with two mail merge regions named "Washington" and "Seattle"
    Document doc = createSourceDocumentWithMailMergeRegions(new String[]{"Washington", "Seattle"});

    // Create two data sources
    EmployeeList employeesWashingtonBranch = new EmployeeList();
    employeesWashingtonBranch.add(new Employee("John Doe", "Sales"));
    employeesWashingtonBranch.add(new Employee("Jane Doe", "Management"));

    EmployeeList employeesSeattleBranch = new EmployeeList();
    employeesWashingtonBranch.add(new Employee("John Cardholder", "Management"));
    employeesWashingtonBranch.add(new Employee("Joe Bloggs", "Sales"));

    // Register our data sources by name in a data source root
    DataSourceRoot sourceRoot = new DataSourceRoot();
    sourceRoot.registerSource("Washington", new EmployeeListMailMergeSource(employeesWashingtonBranch));
    sourceRoot.registerSource("Seattle", new EmployeeListMailMergeSource(employeesSeattleBranch));

    // Since we have consecutive mail merge regions, we would normally have to perform two mail merges
    // However, one mail merge source data root call every relevant data source and merge automatically
    doc.getMailMerge().executeWithRegions(sourceRoot);

    doc.save(getArtifactsDir() + "MailMergeCustom.CustomDataSourceRoot.docx");
}

/// &lt;summary&gt;
/// Create document that contains consecutive mail merge regions, with names designated by the input array,
/// for a data table of employees.
/// &lt;/summary&gt;
private static Document createSourceDocumentWithMailMergeRegions(String[] regions) throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    for (String s : regions) {
        builder.writeln("\n" + s + " branch: ");
        builder.insertField(" MERGEFIELD TableStart:" + s);
        builder.insertField(" MERGEFIELD FullName");
        builder.write(", ");
        builder.insertField(" MERGEFIELD Department");
        builder.insertField(" MERGEFIELD TableEnd:" + s);
    }

    return doc;
}

/// &lt;summary&gt;
/// An example of a "data entity" class in your application.
/// &lt;/summary&gt;
private static class Employee {
    public Employee(String aFullName, String aDepartment) {
        mFullName = aFullName;
        mDepartment = aDepartment;
    }

    public String getFullName() {
        return mFullName;
    }

    private final String mFullName;

    public String getDepartment() {
        return mDepartment;
    }

    private final String mDepartment;
}

/// &lt;summary&gt;
/// An example of a typed collection that contains your "data" objects.
/// &lt;/summary&gt;
private static class EmployeeList extends ArrayList {
    public Employee get(int index) {
        return (Employee) super.get(index);
    }

    public void set(int index, Employee value) {
        super.set(index, value);
    }
}

/// &lt;summary&gt;
/// Data source root that can be passed directly into a mail merge which can register and contain many child data sources.
/// These sources must all implement IMailMergeDataSource, and are registered and differentiated by a name
/// which corresponds to a mail merge region that will read the respective data.
/// &lt;/summary&gt;
private static class DataSourceRoot implements IMailMergeDataSourceRoot {
    public IMailMergeDataSource getDataSource(String tableName) {
        EmployeeListMailMergeSource source = mSources.get(tableName);
        source.reset();
        return mSources.get(tableName);
    }

    public void registerSource(String sourceName, EmployeeListMailMergeSource source) {
        mSources.put(sourceName, source);
    }

    private final HashMap&lt;String, EmployeeListMailMergeSource&gt; mSources = new HashMap&lt;&gt;();
}

/// &lt;summary&gt;
/// Custom mail merge data source.
/// &lt;/summary&gt;
private static class EmployeeListMailMergeSource implements IMailMergeDataSource {
    public EmployeeListMailMergeSource(EmployeeList employees) {
        mEmployees = employees;
        mRecordIndex = -1;
    }

    /// &lt;summary&gt;
    /// A standard implementation for moving to a next record in a collection.
    /// &lt;/summary&gt;
    public boolean moveNext() {
        if (!isEof())
            mRecordIndex++;

        return (!isEof());
    }

    private boolean isEof() {
        return (mRecordIndex &gt;= mEmployees.size());
    }

    public void reset() {
        mRecordIndex = -1;
    }

    /// &lt;summary&gt;
    /// The name of the data source. Used by Aspose.Words only when executing mail merge with repeatable regions.
    /// &lt;/summary&gt;
    public String getTableName() {
        return "Employees";
    }

    /// &lt;summary&gt;
    /// Aspose.Words calls this method to get a value for every data field.
    /// &lt;/summary&gt;
    public boolean getValue(String fieldName, Ref&lt;Object&gt; fieldValue) {
        switch (fieldName) {
            case "FullName":
                fieldValue.set(mEmployees.get(mRecordIndex).getFullName());
                return true;
            case "Department":
                fieldValue.set(mEmployees.get(mRecordIndex).getDepartment());
                return true;
            default:
                // A field with this name was not found,
                // return false to the Aspose.Words mail merge engine
                fieldValue.set(null);
                return false;
        }
    }

    /// &lt;summary&gt;
    /// Child data sources are for nested mail merges.
    /// &lt;/summary&gt;
    public IMailMergeDataSource getChildDataSource(String tableName) {
        throw new UnsupportedOperationException();
    }

    private final EmployeeList mEmployees;
    private int mRecordIndex;
}</pre></example>
</DL>
<HR>

<A NAME="executeWithRegions(com.aspose.words.net.System.Data.DataSet)"><!-- --></A><A NAME="executeWithRegions-com.aspose.words.net.System.Data.DataSet-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>executeWithRegions</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>executeWithRegions</B>(com.aspose.words.net.System.Data.DataSet&nbsp;dataSet)
                       throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Performs mail merge from a <b>DataSet</b> into a document with mail merge regions.
             </summary><remarks><p>Use this method to perform mail merge from one or more tables into repeatable mail
             merge regions in the document. The mail merge regions inside the document will dynamically
             grow to accommodate records in the corresponding tables.</p><p>The document must have mail merge regions defined with names that refer to the tables
             in the <b>DataSet</b>.</p><p>To specify a mail merge region in the document you need to insert two mail merge fields
             to mark beginning and end of the mail merge region.</p><p>All document content that is included inside a mail merge region will be automatically
             repeated for every record in the <b>DataTable</b>.</p><p>To mark beginning of a mail merge region insert a MERGEFIELD with name TableStart:MyTable,
             where MyTable corresponds to one of the table names in your <b>DataSet</b>.</p><p>To mark the end of the mail merge region insert another MERGEFIELD with name TableEnd:MyTable.</p><p>To insert a MERGEFIELD in Word use Insert/Field command and select MergeField then type the
             name of the field.</p><p>The <b>TableStart</b> and <b>TableEnd</b> fields must be inside the same section in your document.</p><p>If used inside a table, <b>TableStart</b> and <b>TableEnd</b> must be inside the same row in the table.</p><p>Mail merge regions in a document should be well formed (there always needs to be a pair of matching
             <b>TableStart</b> and <b>TableEnd</b> merge fields with the same table name).</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="dataSet"><CODE>dataSet</CODE> - <b>DataSet</b> that contains data to be inserted into mail merge fields.</DD></DL><example><p><b>Example:</b></p>Shows how to execute a nested mail merge with two merge regions and two data tables.<pre>
public void executeWithRegionsNested() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Normally, MERGEFIELDs contain the name of a column of a mail merge data source.
    // Instead, we can use "TableStart:" and "TableEnd:" prefixes to begin/end a mail merge region.
    // Each region will belong to a table with a name that matches the string immediately after the prefix's colon.
    builder.insertField(" MERGEFIELD TableStart:Customers");

    // This MERGEFIELD is inside the mail merge region of the "Customers" table.
    // When we execute the mail merge, this field will receive data from rows in a data source named "Customers".
    builder.write("Orders for ");
    builder.insertField(" MERGEFIELD CustomerName");
    builder.write(":");

    // Create column headers for a table that will contain values from a second inner region.
    builder.startTable();
    builder.insertCell();
    builder.write("Item");
    builder.insertCell();
    builder.write("Quantity");
    builder.endRow();

    // Create a second mail merge region inside the outer region for a table named "Orders".
    // The "Orders" table has a many-to-one relationship with the "Customers" table on the "CustomerID" column.
    builder.insertCell();
    builder.insertField(" MERGEFIELD TableStart:Orders");
    builder.insertField(" MERGEFIELD ItemName");
    builder.insertCell();
    builder.insertField(" MERGEFIELD Quantity");

    // End the inner region
    // One stipulation of using regions and tables is that the opening and closing of a mail merge region must
    // only happen over one row of a document's table
    builder.insertField(" MERGEFIELD TableEnd:Orders");
    builder.endTable();

    builder.insertField(" MERGEFIELD TableEnd:Customers");

    // Create a dataset that contains the two tables with the required names and relationships.
    // Each merge document for each row of the "Customers" table of the outer merge region will perform its mail merge on the "Orders" table.
    // Each merge document will display all rows of the latter table whose "CustomerID" column values match the current "Customers" table row.
    DataSet customersAndOrders = createDataSet();
    doc.getMailMerge().executeWithRegions(customersAndOrders);

    doc.save(getArtifactsDir() + "MailMerge.ExecuteWithRegionsNested.docx");
}

/// &lt;summary&gt;
/// Generates a data set which has two data tables named "Customers" and "Orders",
/// with a one-to-many relationship between the former and latter on the "CustomerID" column.
/// &lt;/summary&gt;
private static DataSet createDataSet() {
    // Create the outer mail merge
    DataTable tableCustomers = new DataTable("Customers");
    tableCustomers.getColumns().add("CustomerID");
    tableCustomers.getColumns().add("CustomerName");
    tableCustomers.getRows().add(1, "John Doe");
    tableCustomers.getRows().add(2, "Jane Doe");

    // Create the table for the inner merge
    DataTable tableOrders = new DataTable("Orders");
    tableOrders.getColumns().add("CustomerID");
    tableOrders.getColumns().add("ItemName");
    tableOrders.getColumns().add("Quantity");
    tableOrders.getRows().add(1, "Hawaiian", 2);
    tableOrders.getRows().add(2, "Pepperoni", 1);
    tableOrders.getRows().add(2, "Chicago", 1);

    // Add both tables to a data set
    DataSet dataSet = new DataSet();
    dataSet.getTables().add(tableCustomers);
    dataSet.getTables().add(tableOrders);

    // The "CustomerID" column, also the primary key of the customers table is the foreign key for the Orders table
    dataSet.getRelations().add(tableCustomers.getColumns().get("CustomerID"), tableOrders.getColumns().get("CustomerID"));

    return dataSet;
}</pre></example>
</DL>
<HR>

<A NAME="executeWithRegions(com.aspose.words.net.System.Data.DataTable)"><!-- --></A><A NAME="executeWithRegions-com.aspose.words.net.System.Data.DataTable-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>executeWithRegions</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>executeWithRegions</B>(com.aspose.words.net.System.Data.DataTable&nbsp;dataTable)
                       throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Performs mail merge from a <b>DataTable</b> into the document with mail merge regions.
             </summary><remarks><p>If there are other mail merge regions defined in the document they are left intact.
             This allows to perform several mail merge operations.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="dataTable"><CODE>dataTable</CODE> - Data source for the mail merge operation. The table must
             have its <cref><B>TableName</B> </cref> property set.</DD></DL><example><p><b>Example:</b></p>Demonstrates how to implement custom logic in the MergeField event to apply cell formatting.<pre>
public void alternatingRows() throws Exception {
    Document doc = new Document(getMyDir() + "Mail merge destination - Northwind suppliers.docx");

    // Add a handler for the MergeField event
    doc.getMailMerge().setFieldMergingCallback(new HandleMergeFieldAlternatingRows());

    // Execute mail merge with regions
    DataTable dataTable = getSuppliersDataTable();
    doc.getMailMerge().executeWithRegions(dataTable);

    doc.save(getArtifactsDir() + "MailMergeEvent.AlternatingRows.docx");
}

private class HandleMergeFieldAlternatingRows implements IFieldMergingCallback {
    // Called for every merge field encountered in the document.
    // We can either return some data to the mail merge engine or do something
    // else with the document. In this case we modify cell formatting.
    public void fieldMerging(final FieldMergingArgs args) throws Exception {
        if (mBuilder == null) {
            mBuilder = new DocumentBuilder(args.getDocument());
        }

        // This way we catch the beginning of a new row
        if (args.getFieldName().equals("CompanyName")) {
            // Select the color depending on whether the row number is even or odd
            Color rowColor;
            if (isOdd(mRowIdx)) rowColor = new Color(213, 227, 235);
            else rowColor = new Color(242, 242, 242);

            // There is no way to set cell properties for the whole row at the moment,
            // so we have to iterate over all cells in the row
            for (int colIdx = 0; colIdx &lt; 4; colIdx++) {
                mBuilder.moveToCell(0, mRowIdx, colIdx, 0);
                mBuilder.getCellFormat().getShading().setBackgroundPatternColor(rowColor);
            }

            mRowIdx++;
        }
    }

    public void imageFieldMerging(final ImageFieldMergingArgs args) {
        // Do nothing
    }

    private DocumentBuilder mBuilder;
    private int mRowIdx;
}

/*
// Returns true if the value is odd; false if the value is even.
 */

private static boolean isOdd(final int value) {
    return (value % 2 != 0);
}

// Create DataTable and fill it with data.
// In real life this DataTable should be filled from a database.
private static DataTable getSuppliersDataTable() throws Exception {
    DataTable dataTable = new DataTable("Suppliers");
    dataTable.getColumns().add("CompanyName");
    dataTable.getColumns().add("ContactName");
    for (int i = 0; i &lt; 10; i++) {
        DataRow datarow = dataTable.newRow();
        dataTable.getRows().add(datarow);
        datarow.set(0, "Company " + i);
        datarow.set(1, "Contact " + i);
    }

    return dataTable;
}</pre></example><example><p><b>Example:</b></p>Shows how to use regions to execute two separate mail merges in one document.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// If we want to perform two consecutive mail merges on one document while taking data from two tables
// related to each other in any way, we can separate the mail merges with regions.
// Normally, MERGEFIELDs contain the name of a column of a mail merge data source.
// Instead, we can use "TableStart:" and "TableEnd:" prefixes to begin/end a mail merge region.
// Each region will belong to a table with a name that matches the string immediately after the prefix's colon.
// These regions are separate for unrelated data, while they can be nested for hierarchical data.
builder.writeln("\tCities: ");
builder.insertField(" MERGEFIELD TableStart:Cities");
builder.insertField(" MERGEFIELD Name");
builder.insertField(" MERGEFIELD TableEnd:Cities");
builder.insertParagraph();

// Both MERGEFIELDs refer to the same column name, but values for each will come from different data tables.
builder.writeln("\tFruit: ");
builder.insertField(" MERGEFIELD TableStart:Fruit");
builder.insertField(" MERGEFIELD Name");
builder.insertField(" MERGEFIELD TableEnd:Fruit");

// Create two unrelated data tables.
DataTable tableCities = new DataTable("Cities");
tableCities.getColumns().add("Name");
tableCities.getRows().add("Washington");
tableCities.getRows().add("London");
tableCities.getRows().add("New York");

DataTable tableFruit = new DataTable("Fruit");
tableFruit.getColumns().add("Name");
tableFruit.getRows().add("Cherry");
tableFruit.getRows().add("Apple");
tableFruit.getRows().add("Watermelon");
tableFruit.getRows().add("Banana");

// We will need to run one mail merge per table. The first mail merge will populate the MERGEFIELDs
// in the "Cities" range while leaving the fields the "Fruit" range unfilled.
doc.getMailMerge().executeWithRegions(tableCities);

doc.save(getArtifactsDir() + "MailMerge.ExecuteWithRegionsConcurrent.docx");</pre></example>
</DL>
<HR>

<A NAME="executeWithRegions(com.aspose.words.net.System.Data.DataView)"><!-- --></A><A NAME="executeWithRegions-com.aspose.words.net.System.Data.DataView-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>executeWithRegions</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>executeWithRegions</B>(com.aspose.words.net.System.Data.DataView&nbsp;dataView)
                       throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Performs mail merge from a <b>DataView</b> into the document with mail merge regions.
             </summary><remarks><p>This method is useful if you retrieve data into a <b>DataTable</b> but then
             need to apply a filter or sort before the mail merge.</p><p>The document must have a mail merge region defined with name that matches
             <b>DataView.Table.TableName</b>.</p><p>If there are other mail merge regions defined in the document they are left intact.
             This allows to perform several mail merge operations.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="dataView"><CODE>dataView</CODE> - Data source for the mail merge operation. The source table
             of the <b>DataView</b> must have its <b>TableName</b> property set.</DD></DL><example><p><b>Example:</b></p>Shows how to use regions to execute two separate mail merges in one document.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// If we want to perform two consecutive mail merges on one document while taking data from two tables
// related to each other in any way, we can separate the mail merges with regions.
// Normally, MERGEFIELDs contain the name of a column of a mail merge data source.
// Instead, we can use "TableStart:" and "TableEnd:" prefixes to begin/end a mail merge region.
// Each region will belong to a table with a name that matches the string immediately after the prefix's colon.
// These regions are separate for unrelated data, while they can be nested for hierarchical data.
builder.writeln("\tCities: ");
builder.insertField(" MERGEFIELD TableStart:Cities");
builder.insertField(" MERGEFIELD Name");
builder.insertField(" MERGEFIELD TableEnd:Cities");
builder.insertParagraph();

// Both MERGEFIELDs refer to the same column name, but values for each will come from different data tables.
builder.writeln("\tFruit: ");
builder.insertField(" MERGEFIELD TableStart:Fruit");
builder.insertField(" MERGEFIELD Name");
builder.insertField(" MERGEFIELD TableEnd:Fruit");

// Create two unrelated data tables.
DataTable tableCities = new DataTable("Cities");
tableCities.getColumns().add("Name");
tableCities.getRows().add("Washington");
tableCities.getRows().add("London");
tableCities.getRows().add("New York");

DataTable tableFruit = new DataTable("Fruit");
tableFruit.getColumns().add("Name");
tableFruit.getRows().add("Cherry");
tableFruit.getRows().add("Apple");
tableFruit.getRows().add("Watermelon");
tableFruit.getRows().add("Banana");

// We will need to run one mail merge per table. The first mail merge will populate the MERGEFIELDs
// in the "Cities" range while leaving the fields the "Fruit" range unfilled.
doc.getMailMerge().executeWithRegions(tableCities);

doc.save(getArtifactsDir() + "MailMerge.ExecuteWithRegionsConcurrent.docx");</pre></example>
</DL>
<HR>

<A NAME="executeWithRegions(com.aspose.words.net.System.Data.IDataReader,java.lang.String)"><!-- --></A><A NAME="executeWithRegions-com.aspose.words.net.System.Data.IDataReader-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>executeWithRegions</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>executeWithRegions</B>(com.aspose.words.net.System.Data.IDataReader&nbsp;dataReader, java.lang.String&nbsp;tableName)
                       throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Performs mail merge from <b>IDataReader</b> into the document with mail merge regions.
            </summary><remarks><p>You can pass <b>SqlDataReader</b> or <b>OleDbDataReader</b> object into this
            method as a parameter because they both implemented <b>IDataReader</b> interface.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="dataReader"><CODE>dataReader</CODE> - Source of the data records for mail merge such as <b>OleDbDataReader</b> or <b>SqlDataReader</b>.</DD><DD param="tableName"><CODE>tableName</CODE> - Name of the mail merge region in the document to populate.</DD></DL><example><p><b>Example:</b></p>Shows how to insert images stored in a database BLOB field into a report.<pre>
public void imageFromBlob() throws Exception {
    Document doc = new Document(getMyDir() + "Mail merge destination - Northwind employees.docx");

    // Set up the event handler for image fields
    doc.getMailMerge().setFieldMergingCallback(new HandleMergeImageFieldFromBlob());

    // Loads the driver
    Class.forName("net.ucanaccess.jdbc.UcanaccessDriver");

    // Open the database connection
    String connString = "jdbc:ucanaccess://" + getDatabaseDir() + "Northwind.accdb";

    // DSN-less DB connection
    java.sql.Connection conn = java.sql.DriverManager.getConnection(connString, "Admin", "");

    // Create and execute a command
    java.sql.Statement statement = conn.createStatement();
    java.sql.ResultSet resultSet = statement.executeQuery("SELECT * FROM Employees");

    DataTable table = new DataTable(resultSet, "Employees");

    // Perform mail merge
    doc.getMailMerge().executeWithRegions(table);

    // Close the database
    conn.close();

    doc.save(getArtifactsDir() + "MailMergeEvent.ImageFromBlob.docx");
}

private class HandleMergeImageFieldFromBlob implements IFieldMergingCallback {
    public void fieldMerging(final FieldMergingArgs args) {
        // Do nothing
    }

    // This is called when mail merge engine encounters Image:XXX merge field in the document.
    // You have a chance to return an Image object, file name or a stream that contains the image.
    public void imageFieldMerging(final ImageFieldMergingArgs e) {
        // The field value is a byte array, just cast it and create a stream on it
        ByteArrayInputStream imageStream = new ByteArrayInputStream((byte[]) e.getFieldValue());
        // Now the mail merge engine will retrieve the image from the stream
        e.setImageStream(imageStream);
    }
}</pre></example>
</DL>
<HR>

<A NAME="getFieldNames()"><!-- --></A><A NAME="getFieldNames--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFieldNames</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String[]&nbsp;<B>getFieldNames</B>()
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a collection of mail merge field names available in the document.
            </summary><remarks><p>Returns full merge field names including optional prefix. Does not eliminate duplicate field names.</p><p>A new string array is created on every call.</p><p>Includes "mustache" field names if <cref><A HREF="#UseNonMergeFields" title="property in class com.aspose.words.MailMerge">UseNonMergeFields</A></cref> is <code>true</code>.</p></remarks><example><p><b>Example:</b></p>Shows how to get names of all merge fields in a document.<pre>
String[] fieldNames = doc.getMailMerge().getFieldNames();</pre></example>
</DL>
<HR>

<A NAME="getFieldNamesForRegion(java.lang.String)"><!-- --></A><A NAME="getFieldNamesForRegion-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFieldNamesForRegion</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String[]&nbsp;<B>getFieldNamesForRegion</B>(java.lang.String&nbsp;regionName)
                               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a collection of mail merge field names available in the region.
            </summary><remarks><p>Returns full merge field names including optional prefix. Does not eliminate duplicate field names.</p><p>If document contains multiple regions with the same name the very first region is processed.</p><p>A new string array is created on every call.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="regionName"><CODE>regionName</CODE> - Region name (case-insensitive).</DD></DL><example><p><b>Example:</b></p>Shows how to create, list, and read mail merge regions.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// These tags, which go inside MERGEFIELDs, denote the strings that signify the starts and ends of mail merge regions
Assert.assertEquals(doc.getMailMerge().getRegionStartTag(), "TableStart");
Assert.assertEquals(doc.getMailMerge().getRegionEndTag(), "TableEnd");

// By using these tags, we will start and end a "MailMergeRegion1", which will contain MERGEFIELDs for two columns
builder.insertField(" MERGEFIELD TableStart:MailMergeRegion1");
builder.insertField(" MERGEFIELD Column1");
builder.write(", ");
builder.insertField(" MERGEFIELD Column2");
builder.insertField(" MERGEFIELD TableEnd:MailMergeRegion1");

// We can keep track of merge regions and their columns by looking at these collections
ArrayList&lt;MailMergeRegionInfo&gt; regions = doc.getMailMerge().getRegionsByName("MailMergeRegion1");
Assert.assertEquals(regions.size(), 1);
Assert.assertEquals(regions.get(0).getName(), "MailMergeRegion1");

String[] mergeFieldNames = doc.getMailMerge().getFieldNamesForRegion("MailMergeRegion1");
Assert.assertEquals(mergeFieldNames[0], "Column1");
Assert.assertEquals(mergeFieldNames[1], "Column2");

// Insert a region with the same name inside the existing region, which will make it a parent.
// Now a "Column2" field will be inside a new region.
builder.moveToField(regions.get(0).getFields().get(1), false);
builder.insertField(" MERGEFIELD TableStart:MailMergeRegion1");
builder.moveToField(regions.get(0).getFields().get(1), true);
builder.insertField(" MERGEFIELD TableEnd:MailMergeRegion1");

// Regions that share the same name are still accounted for and can be accessed by index
regions = doc.getMailMerge().getRegionsByName("MailMergeRegion1");
Assert.assertEquals(regions.size(), 2);
// Check that the second region now has a parent region.
Assert.assertEquals("MailMergeRegion1", regions.get(1).getParentRegion().getName());

mergeFieldNames = doc.getMailMerge().getFieldNamesForRegion("MailMergeRegion1", 1);
Assert.assertEquals(mergeFieldNames[0], "Column2");</pre></example>
</DL>
<HR>

<A NAME="getFieldNamesForRegion(java.lang.String,int)"><!-- --></A><A NAME="getFieldNamesForRegion-java.lang.String-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFieldNamesForRegion</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String[]&nbsp;<B>getFieldNamesForRegion</B>(java.lang.String&nbsp;regionName, int&nbsp;regionIndex)
                               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a collection of mail merge field names available in the region.
            </summary><remarks><p>Returns full merge field names including optional prefix. Does not eliminate duplicate field names.</p><p>If document contains multiple regions with the same name the Nth region (zero-based) is processed.</p><p>A new string array is created on every call.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="regionName"><CODE>regionName</CODE> - Region name (case-insensitive).</DD><DD param="regionIndex"><CODE>regionIndex</CODE> - Region index (zero-based).</DD></DL><example><p><b>Example:</b></p>Shows how to create, list, and read mail merge regions.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// These tags, which go inside MERGEFIELDs, denote the strings that signify the starts and ends of mail merge regions
Assert.assertEquals(doc.getMailMerge().getRegionStartTag(), "TableStart");
Assert.assertEquals(doc.getMailMerge().getRegionEndTag(), "TableEnd");

// By using these tags, we will start and end a "MailMergeRegion1", which will contain MERGEFIELDs for two columns
builder.insertField(" MERGEFIELD TableStart:MailMergeRegion1");
builder.insertField(" MERGEFIELD Column1");
builder.write(", ");
builder.insertField(" MERGEFIELD Column2");
builder.insertField(" MERGEFIELD TableEnd:MailMergeRegion1");

// We can keep track of merge regions and their columns by looking at these collections
ArrayList&lt;MailMergeRegionInfo&gt; regions = doc.getMailMerge().getRegionsByName("MailMergeRegion1");
Assert.assertEquals(regions.size(), 1);
Assert.assertEquals(regions.get(0).getName(), "MailMergeRegion1");

String[] mergeFieldNames = doc.getMailMerge().getFieldNamesForRegion("MailMergeRegion1");
Assert.assertEquals(mergeFieldNames[0], "Column1");
Assert.assertEquals(mergeFieldNames[1], "Column2");

// Insert a region with the same name inside the existing region, which will make it a parent.
// Now a "Column2" field will be inside a new region.
builder.moveToField(regions.get(0).getFields().get(1), false);
builder.insertField(" MERGEFIELD TableStart:MailMergeRegion1");
builder.moveToField(regions.get(0).getFields().get(1), true);
builder.insertField(" MERGEFIELD TableEnd:MailMergeRegion1");

// Regions that share the same name are still accounted for and can be accessed by index
regions = doc.getMailMerge().getRegionsByName("MailMergeRegion1");
Assert.assertEquals(regions.size(), 2);
// Check that the second region now has a parent region.
Assert.assertEquals("MailMergeRegion1", regions.get(1).getParentRegion().getName());

mergeFieldNames = doc.getMailMerge().getFieldNamesForRegion("MailMergeRegion1", 1);
Assert.assertEquals(mergeFieldNames[0], "Column2");</pre></example>
</DL>
<HR>

<A NAME="getRegionsByName(java.lang.String)"><!-- --></A><A NAME="getRegionsByName-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRegionsByName</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.util.ArrayList&lt;<A HREF="MailMergeRegionInfo.html" title="class in com.aspose.words">MailMergeRegionInfo</A>&gt;&nbsp;<B>getRegionsByName</B>(java.lang.String&nbsp;regionName)
                                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a collection of mail merge regions with the specified name.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="regionName"><CODE>regionName</CODE> - Region name (case-insensitive).</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The list of regions.</DD></DL><example><p><b>Example:</b></p>Shows how to create, list, and read mail merge regions.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// These tags, which go inside MERGEFIELDs, denote the strings that signify the starts and ends of mail merge regions
Assert.assertEquals(doc.getMailMerge().getRegionStartTag(), "TableStart");
Assert.assertEquals(doc.getMailMerge().getRegionEndTag(), "TableEnd");

// By using these tags, we will start and end a "MailMergeRegion1", which will contain MERGEFIELDs for two columns
builder.insertField(" MERGEFIELD TableStart:MailMergeRegion1");
builder.insertField(" MERGEFIELD Column1");
builder.write(", ");
builder.insertField(" MERGEFIELD Column2");
builder.insertField(" MERGEFIELD TableEnd:MailMergeRegion1");

// We can keep track of merge regions and their columns by looking at these collections
ArrayList&lt;MailMergeRegionInfo&gt; regions = doc.getMailMerge().getRegionsByName("MailMergeRegion1");
Assert.assertEquals(regions.size(), 1);
Assert.assertEquals(regions.get(0).getName(), "MailMergeRegion1");

String[] mergeFieldNames = doc.getMailMerge().getFieldNamesForRegion("MailMergeRegion1");
Assert.assertEquals(mergeFieldNames[0], "Column1");
Assert.assertEquals(mergeFieldNames[1], "Column2");

// Insert a region with the same name inside the existing region, which will make it a parent.
// Now a "Column2" field will be inside a new region.
builder.moveToField(regions.get(0).getFields().get(1), false);
builder.insertField(" MERGEFIELD TableStart:MailMergeRegion1");
builder.moveToField(regions.get(0).getFields().get(1), true);
builder.insertField(" MERGEFIELD TableEnd:MailMergeRegion1");

// Regions that share the same name are still accounted for and can be accessed by index
regions = doc.getMailMerge().getRegionsByName("MailMergeRegion1");
Assert.assertEquals(regions.size(), 2);
// Check that the second region now has a parent region.
Assert.assertEquals("MailMergeRegion1", regions.get(1).getParentRegion().getName());

mergeFieldNames = doc.getMailMerge().getFieldNamesForRegion("MailMergeRegion1", 1);
Assert.assertEquals(mergeFieldNames[0], "Column2");</pre></example>
</DL>
<HR>

<A NAME="getRegionsHierarchy()"><!-- --></A><A NAME="getRegionsHierarchy--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRegionsHierarchy</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="MailMergeRegionInfo.html" title="class in com.aspose.words">MailMergeRegionInfo</A>&nbsp;<B>getRegionsHierarchy</B>()
                                       throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a full hierarchy of regions (with fields) available in the document.
            </summary><remarks><p>Hierarchy is returned in the form of the <cref><A HREF="MailMergeRegionInfo.html" title="class in com.aspose.words">MailMergeRegionInfo</A></cref> class.</p></remarks><DL><DT><B>Returns:</B></DT><DD returns="">Regions' hierarchy.</DD></DL><example><p><b>Example:</b></p>Shows how to get MailMergeRegionInfo and work with it.<pre>
Document doc = new Document(getMyDir() + "Mail merge regions.docx");

// Returns a full hierarchy of regions (with fields) available in the document
MailMergeRegionInfo regionInfo = doc.getMailMerge().getRegionsHierarchy();

// Get top regions in the document
ArrayList topRegions = regionInfo.getRegions();
Assert.assertEquals(topRegions.size(), 2);
Assert.assertEquals(((MailMergeRegionInfo) topRegions.get(0)).getName(), "Region1");
Assert.assertEquals(((MailMergeRegionInfo) topRegions.get(1)).getName(), "Region2");
Assert.assertEquals(((MailMergeRegionInfo) topRegions.get(0)).getLevel(), 1);
Assert.assertEquals(((MailMergeRegionInfo) topRegions.get(1)).getLevel(), 1);

// Get nested region in first top region
ArrayList nestedRegions = ((MailMergeRegionInfo) topRegions.get(0)).getRegions();
Assert.assertEquals(nestedRegions.size(), 2);
Assert.assertEquals(((MailMergeRegionInfo) nestedRegions.get(0)).getName(), "NestedRegion1");
Assert.assertEquals(((MailMergeRegionInfo) nestedRegions.get(1)).getName(), "NestedRegion2");
Assert.assertEquals(((MailMergeRegionInfo) nestedRegions.get(0)).getLevel(), 2);
Assert.assertEquals(((MailMergeRegionInfo) nestedRegions.get(1)).getLevel(), 2);

// Get field list in first top region
ArrayList fieldList = ((MailMergeRegionInfo) topRegions.get(0)).getFields();
Assert.assertEquals(fieldList.size(), 4);

FieldMergeField startFieldMergeField = ((MailMergeRegionInfo) nestedRegions.get(0)).getStartField();
Assert.assertEquals(startFieldMergeField.getFieldName(), "TableStart:NestedRegion1");

FieldMergeField endFieldMergeField = ((MailMergeRegionInfo) nestedRegions.get(0)).getEndField();
Assert.assertEquals(endFieldMergeField.getFieldName(), "TableEnd:NestedRegion1");</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>