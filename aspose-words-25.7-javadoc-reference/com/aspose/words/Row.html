<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 19 Jul 2025 -->
<TITLE>Row</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class Row</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="Node.html" title="class in com.aspose.words">Node</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>
          <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.Row</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Cloneable, java.lang.Iterable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Row </B><DT>extends <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></DL>
</PRE>

<P>

<summary>
            Represents a table row.
            <p>To learn more, visit the <a href="https://docs.aspose.com/words/net/working-with-tables/">Working with Tables</a> documentation article.</p></summary><remarks><p><cref><i>Row</i></cref> can only be a child of a <cref><A HREF="Table.html" title="class in com.aspose.words">Table</A></cref>.</p><p><cref><i>Row</i></cref> can contain one or more <cref><A HREF="Cell.html" title="class in com.aspose.words">Cell</A></cref> nodes.</p><p>A minimal valid row needs to have at least one <cref><A HREF="Cell.html" title="class in com.aspose.words">Cell</A></cref>.</p></remarks><example><p><b>Example:</b></p>Shows how to create a table.<pre>
Document doc = new Document();
Table table = new Table(doc);
doc.getFirstSection().getBody().appendChild(table);

// Tables contain rows, which contain cells, which may have paragraphs
// with typical elements such as runs, shapes, and even other tables.
// Calling the "EnsureMinimum" method on a table will ensure that
// the table has at least one row, cell, and paragraph.
Row firstRow = new Row(doc);
table.appendChild(firstRow);

Cell firstCell = new Cell(doc);
firstRow.appendChild(firstCell);

Paragraph paragraph = new Paragraph(doc);
firstCell.appendChild(paragraph);

// Add text to the first cell in the first row of the table.
Run run = new Run(doc, "Hello world!");
paragraph.appendChild(run);

doc.save(getArtifactsDir() + "Table.CreateTable.docx");</pre></example><example><p><b>Example:</b></p>Shows how to iterate through all tables in the document and print the contents of each cell.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");
TableCollection tables = doc.getFirstSection().getBody().getTables();

Assert.assertEquals(2, tables.toArray().length);

for (int i = 0; i &lt; tables.getCount(); i++) {
    System.out.println(MessageFormat.format("Start of Table {0}", i));

    RowCollection rows = tables.get(i).getRows();

    for (int j = 0; j &lt; rows.getCount(); j++) {
        System.out.println(MessageFormat.format("\tStart of Row {0}", j));

        CellCollection cells = rows.get(j).getCells();

        for (int k = 0; k &lt; cells.getCount(); k++) {
            String cellText = cells.get(k).toString(SaveFormat.TEXT).trim();
            System.out.println(MessageFormat.format("\t\tContents of Cell:{0} = \"{1}\"", k, cellText));
        }

        System.out.println(MessageFormat.format("\tEnd of Row {0}", j));
    }

    System.out.println(MessageFormat.format("End of Table {0}\n", i));
}</pre></example><example><p><b>Example:</b></p>Shows how to build a nested table without using a document builder.<pre>
public void createNestedTable() throws Exception {
    Document doc = new Document();

    // Create the outer table with three rows and four columns, and then add it to the document.
    Table outerTable = createTable(doc, 3, 4, "Outer Table");
    doc.getFirstSection().getBody().appendChild(outerTable);

    // Create another table with two rows and two columns and then insert it into the first table's first cell.
    Table innerTable = createTable(doc, 2, 2, "Inner Table");
    outerTable.getFirstRow().getFirstCell().appendChild(innerTable);

    doc.save(getArtifactsDir() + "Table.CreateNestedTable.docx");
}

// Creates a new table in the document with the given dimensions and text in each cell.
private Table createTable(final Document doc, final int rowCount, final int cellCount, final String cellText) throws Exception {
    Table table = new Table(doc);

    for (int rowId = 1; rowId &lt;= rowCount; rowId++) {
        Row row = new Row(doc);
        table.appendChild(row);

        for (int cellId = 1; cellId &lt;= cellCount; cellId++) {
            Cell cell = new Cell(doc);
            cell.appendChild(new Paragraph(doc));
            cell.getFirstParagraph().appendChild(new Run(doc, cellText));

            row.appendChild(cell);
        }
    }

    // You can use the "Title" and "Description" properties to add a title and description respectively to your table.
    // The table must have at least one row before we can use these properties.
    // These properties are meaningful for ISO / IEC 29500 compliant .docx documents (see the OoxmlCompliance class).
    // If we save the document to pre-ISO/IEC 29500 formats, Microsoft Word ignores these properties.
    table.setTitle("Aspose table title");
    table.setDescription("Aspose table description");

    return table;
}</pre></example>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" ><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="#Row(com.aspose.words.DocumentBase)">Row</A></B>(<A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A>&nbsp;doc)</CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Initializes a new instance of the <cref><i>Row</i></cref> class.
            </TD>
</TR>
</TABLE>&nbsp;

<!-- ========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE RULES="GROUPS" BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Property Getters/Setters Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="CellCollection.html" title="class in com.aspose.words">CellCollection</A></CODE></TD><TD><CODE><B><A HREF="#Cells">getCells</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Provides typed access to the <cref><A HREF="Cell.html" title="class in com.aspose.words">Cell</A></cref> child nodes of the row.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#Count">getCount</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the number of immediate children of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#CustomNodeId">getCustomNodeId</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#CustomNodeId">setCustomNodeId</A></B>(int&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Specifies custom node identifier.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A></CODE></TD><TD><CODE><B><A HREF="#Document">getDocument</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the document to which this node belongs.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Cell.html" title="class in com.aspose.words">Cell</A></CODE></TD><TD><CODE><B><A HREF="#FirstCell">getFirstCell</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns the first <cref><A HREF="Cell.html" title="class in com.aspose.words">Cell</A></cref> in the row.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#FirstChild">getFirstChild</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first child of the node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#HasChildNodes">hasChildNodes</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns <code>true</code> if this node has any child nodes.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#Hidden">getHidden</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#Hidden">setHidden</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a flag indicating whether this row is hidden or not.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsComposite">isComposite</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns <code>true</code> as this node can have child nodes.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsFirstRow">isFirstRow</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            True if this is the first row in a table; false otherwise.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsLastRow">isLastRow</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            True if this is the last row in a table; false otherwise.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Cell.html" title="class in com.aspose.words">Cell</A></CODE></TD><TD><CODE><B><A HREF="#LastCell">getLastCell</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns the last <cref><A HREF="Cell.html" title="class in com.aspose.words">Cell</A></cref> in the row.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#LastChild">getLastChild</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the last child of the node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Row.html" title="class in com.aspose.words">Row</A></CODE></TD><TD><CODE><B><A HREF="#NextRow">getNextRow</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the next <cref><i>Row</i></cref> node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#NextSibling">getNextSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately following this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#NodeType">getNodeType</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns <cref><A HREF="NodeType.html#ROW" title="field in class com.aspose.words.NodeType">NodeType.ROW</A></cref>.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#ParentNode">getParentNode</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the immediate parent of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Table.html" title="class in com.aspose.words">Table</A></CODE></TD><TD><CODE><B><A HREF="#ParentTable">getParentTable</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns the immediate parent table of the row.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Row.html" title="class in com.aspose.words">Row</A></CODE></TD><TD><CODE><B><A HREF="#PreviousRow">getPreviousRow</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the previous <cref><i>Row</i></cref> node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#PreviousSibling">getPreviousSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately preceding this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Range.html" title="class in com.aspose.words">Range</A></CODE></TD><TD><CODE><B><A HREF="#Range">getRange</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a <cref><A HREF="Range.html" title="class in com.aspose.words">Range</A></cref> object that represents the portion of a document that is contained in this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="RowFormat.html" title="class in com.aspose.words">RowFormat</A></CODE></TD><TD><CODE><B><A HREF="#RowFormat">getRowFormat</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Provides access to the formatting properties of the row.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#accept(com.aspose.words.DocumentVisitor)">accept</A></B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Accepts a visitor.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#acceptEnd(com.aspose.words.DocumentVisitor)">acceptEnd</A></B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Accepts a visitor for visiting the end of the row.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#acceptStart(com.aspose.words.DocumentVisitor)">acceptStart</A></B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Accepts a visitor for visiting the start of the row.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#deepClone(boolean)">deepClone</A></B>(boolean&nbsp;isCloneChildren)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Creates a duplicate of the node.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#ensureMinimum()">ensureMinimum</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            If the <cref><i>Row</i></cref> has no cells, creates and appends one <cref><A HREF="Cell.html" title="class in com.aspose.words">Cell</A></cref>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(int)">getAncestor</A></B>(int&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(java.lang.Class)">getAncestor</A></B>(java.lang.Class&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified object type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#getChild(int,int,boolean)">getChild</A></B>(int&nbsp;nodeType, int&nbsp;index, boolean&nbsp;isDeep)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns an Nth child node that matches the specified type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="NodeCollection.html" title="class in com.aspose.words">NodeCollection</A></CODE></TD><TD><CODE><B><A HREF="#getChildNodes(int,boolean)">getChildNodes</A></B>(int&nbsp;nodeType, boolean&nbsp;isDeep)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a live collection of child nodes that match the specified type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#getText()">getText</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Gets the text of all cells in this row including the end of row character.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#indexOf(com.aspose.words.Node)">indexOf</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;child)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns the index of the specified child node in the child node array.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.util.Iterator&lt;<A HREF="Node.html" title="class in com.aspose.words">Node</A>&gt;</CODE></TD><TD><CODE><B><A HREF="#iterator()">iterator</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Provides support for the for each style iteration over the child nodes of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#nextPreOrder(com.aspose.words.Node)">nextPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets next node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#previousPreOrder(com.aspose.words.Node)">previousPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the previous node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#remove()">remove</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes itself from the parent.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#removeAllChildren()">removeAllChildren</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes all the child nodes of the current node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#removeSmartTags()">removeSmartTags</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes all <cref><A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A></cref> descendant nodes of the current node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="NodeList.html" title="class in com.aspose.words">NodeList</A></CODE></TD><TD><CODE><B><A HREF="#selectNodes(java.lang.String)">selectNodes</A></B>(java.lang.String&nbsp;xpath)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Selects a list of nodes matching the XPath expression.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#selectSingleNode(java.lang.String)">selectSingleNode</A></B>(java.lang.String&nbsp;xpath)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Selects the first <cref><A HREF="Node.html" title="class in com.aspose.words">Node</A></cref> that matches the XPath expression.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(com.aspose.words.SaveOptions)">toString</A></B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string using the specified save options.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(int)">toString</A></B>(int&nbsp;saveFormat)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string in the specified format.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Row(com.aspose.words.DocumentBase)"><!-- --></A><A NAME="Row-com.aspose.words.DocumentBase-"><!-- --></A><H3>
Row</H3>
<PRE>
public <B>Row</B>(<A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A>&nbsp;doc)</PRE>
<DL><DD><summary>
            Initializes a new instance of the <cref><i>Row</i></cref> class.
            </summary><remarks><p>When <cref><i>Row</i></cref> is created, it belongs to the specified document, but is not
            yet part of the document and <cref><A HREF="#ParentNode" title="property in class com.aspose.words.Row">ParentNode</A></cref> is <code>null</code>.</p><p>To append <cref><i>Row</i></cref> to the document use <cref><B>InsertAfter``1</B></cref> or <cref><B>InsertBefore``1</B></cref>
            on the table where you want the row inserted.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="doc"><CODE>doc</CODE> - The owner document.</DD></DL><example><p><b>Example:</b></p>Shows how to build a nested table without using a document builder.<pre>
public void createNestedTable() throws Exception {
    Document doc = new Document();

    // Create the outer table with three rows and four columns, and then add it to the document.
    Table outerTable = createTable(doc, 3, 4, "Outer Table");
    doc.getFirstSection().getBody().appendChild(outerTable);

    // Create another table with two rows and two columns and then insert it into the first table's first cell.
    Table innerTable = createTable(doc, 2, 2, "Inner Table");
    outerTable.getFirstRow().getFirstCell().appendChild(innerTable);

    doc.save(getArtifactsDir() + "Table.CreateNestedTable.docx");
}

// Creates a new table in the document with the given dimensions and text in each cell.
private Table createTable(final Document doc, final int rowCount, final int cellCount, final String cellText) throws Exception {
    Table table = new Table(doc);

    for (int rowId = 1; rowId &lt;= rowCount; rowId++) {
        Row row = new Row(doc);
        table.appendChild(row);

        for (int cellId = 1; cellId &lt;= cellCount; cellId++) {
            Cell cell = new Cell(doc);
            cell.appendChild(new Paragraph(doc));
            cell.getFirstParagraph().appendChild(new Run(doc, cellText));

            row.appendChild(cell);
        }
    }

    // You can use the "Title" and "Description" properties to add a title and description respectively to your table.
    // The table must have at least one row before we can use these properties.
    // These properties are meaningful for ISO / IEC 29500 compliant .docx documents (see the OoxmlCompliance class).
    // If we save the document to pre-ISO/IEC 29500 formats, Microsoft Word ignores these properties.
    table.setTitle("Aspose table title");
    table.setDescription("Aspose table description");

    return table;
}</pre></example>
</DL>
<HR>



<!-- ============ PROPERTY DETAIL ========== -->

<A NAME="property_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Property Getters/Setters Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Cells"><!-- --></A><A NAME="getCells()"><!-- --></A><A NAME="getCells--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCells</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CellCollection.html" title="class in com.aspose.words">CellCollection</A>&nbsp;<B>getCells</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Provides typed access to the <cref><A HREF="Cell.html" title="class in com.aspose.words">Cell</A></cref> child nodes of the row.
            </summary><example><p><b>Example:</b></p>Shows how to iterate through all tables in the document and print the contents of each cell.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");
TableCollection tables = doc.getFirstSection().getBody().getTables();

Assert.assertEquals(2, tables.toArray().length);

for (int i = 0; i &lt; tables.getCount(); i++) {
    System.out.println(MessageFormat.format("Start of Table {0}", i));

    RowCollection rows = tables.get(i).getRows();

    for (int j = 0; j &lt; rows.getCount(); j++) {
        System.out.println(MessageFormat.format("\tStart of Row {0}", j));

        CellCollection cells = rows.get(j).getCells();

        for (int k = 0; k &lt; cells.getCount(); k++) {
            String cellText = cells.get(k).toString(SaveFormat.TEXT).trim();
            System.out.println(MessageFormat.format("\t\tContents of Cell:{0} = \"{1}\"", k, cellText));
        }

        System.out.println(MessageFormat.format("\tEnd of Row {0}", j));
    }

    System.out.println(MessageFormat.format("End of Table {0}\n", i));
}</pre></example>
</DL>
<HR>

<A NAME="Count"><!-- --></A><A NAME="getCount()"><!-- --></A><A NAME="getCount--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCount</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getCount</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the number of immediate children of this node.
            </summary><example><p><b>Example:</b></p>Shows how to add, update and delete child nodes in a CompositeNode's collection of children.<pre>
Document doc = new Document();

// An empty document, by default, has one paragraph.
Assert.assertEquals(1, doc.getFirstSection().getBody().getParagraphs().getCount());

// Composite nodes such as our paragraph can contain other composite and inline nodes as children.
Paragraph paragraph = doc.getFirstSection().getBody().getFirstParagraph();
Run paragraphText = new Run(doc, "Initial text. ");
paragraph.appendChild(paragraphText);

// Create three more run nodes.
Run run1 = new Run(doc, "Run 1. ");
Run run2 = new Run(doc, "Run 2. ");
Run run3 = new Run(doc, "Run 3. ");

// The document body will not display these runs until we insert them into a composite node
// that itself is a part of the document's node tree, as we did with the first run.
// We can determine where the text contents of nodes that we insert
// appears in the document by specifying an insertion location relative to another node in the paragraph.
Assert.assertEquals("Initial text.", paragraph.getText().trim());

// Insert the second run into the paragraph in front of the initial run.
paragraph.insertBefore(run2, paragraphText);

Assert.assertEquals("Run 2. Initial text.", paragraph.getText().trim());

// Insert the third run after the initial run.
paragraph.insertAfter(run3, paragraphText);

Assert.assertEquals("Run 2. Initial text. Run 3.", paragraph.getText().trim());

// Insert the first run to the start of the paragraph's child nodes collection.
paragraph.prependChild(run1);

Assert.assertEquals("Run 1. Run 2. Initial text. Run 3.", paragraph.getText().trim());
Assert.assertEquals(4, paragraph.getChildNodes(NodeType.ANY, true).getCount());

// We can modify the contents of the run by editing and deleting existing child nodes.
((Run) paragraph.getChildNodes(NodeType.RUN, true).get(1)).setText("Updated run 2. ");
paragraph.getChildNodes(NodeType.RUN, true).remove(paragraphText);

Assert.assertEquals("Run 1. Updated run 2. Run 3.", paragraph.getText().trim());
Assert.assertEquals(3, paragraph.getChildNodes(NodeType.ANY, true).getCount());</pre></example>
</DL>
<HR>

<A NAME="CustomNodeId"><!-- --></A><A NAME="getCustomNodeId()"><!-- --></A><A NAME="getCustomNodeId--"><!-- --></A><A NAME="setCustomNodeId(int)"><!-- --></A><A NAME="setCustomNodeId-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCustomNodeId/setCustomNodeId</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getCustomNodeId</B>()&nbsp;/&nbsp;public void&nbsp;<B>setCustomNodeId</B>(int&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Specifies custom node identifier.
            </summary><remarks><p>Default is zero.</p><p>This identifier can be set and used arbitrarily. For example, as a key to get external data.</p><p>Important note, specified value is not saved to an output file and exists only during the node lifetime.</p></remarks><example><p><b>Example:</b></p>Shows how to traverse through a composite node's collection of child nodes.<pre>
Document doc = new Document();

// Add two runs and one shape as child nodes to the first paragraph of this document.
Paragraph paragraph = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 0, true);
paragraph.appendChild(new Run(doc, "Hello world! "));

Shape shape = new Shape(doc, ShapeType.RECTANGLE);
shape.setWidth(200.0);
shape.setHeight(200.0);
// Note that the 'CustomNodeId' is not saved to an output file and exists only during the node lifetime.
shape.setCustomNodeId(100);
shape.setWrapType(WrapType.INLINE);
paragraph.appendChild(shape);

paragraph.appendChild(new Run(doc, "Hello again!"));

// Iterate through the paragraph's collection of immediate children,
// and print any runs or shapes that we find within.
NodeCollection children = paragraph.getChildNodes(NodeType.ANY, false);

Assert.assertEquals(3, paragraph.getChildNodes(NodeType.ANY, false).getCount());

for (Node child : (Iterable&lt;Node&gt;) children)
    switch (child.getNodeType()) {
        case NodeType.RUN:
            System.out.println("Run contents:");
            System.out.println(MessageFormat.format("\t\"{0}\"", child.getText().trim()));
            break;
        case NodeType.SHAPE:
            Shape childShape = (Shape)child;
            System.out.println("Shape:");
            System.out.println(MessageFormat.format("\t{0}, {1}x{2}", childShape.getShapeType(), childShape.getWidth(), childShape.getHeight()));
            break;
    }</pre></example>
</DL>
<HR>

<A NAME="Document"><!-- --></A><A NAME="getDocument()"><!-- --></A><A NAME="getDocument--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getDocument</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A>&nbsp;<B>getDocument</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the document to which this node belongs.
            </summary><remarks><p>The node always belongs to a document even if it has just been created
            and not yet added to the tree, or if it has been removed from the tree.</p></remarks><example><p><b>Example:</b></p>Shows how to create a node and set its owning document.<pre>
Document doc = new Document();
Paragraph para = new Paragraph(doc);
para.appendChild(new Run(doc, "Hello world!"));

// We have not yet appended this paragraph as a child to any composite node.
Assert.assertNull(para.getParentNode());

// If a node is an appropriate child node type of another composite node,
// we can attach it as a child only if both nodes have the same owner document.
// The owner document is the document we passed to the node's constructor.
// We have not attached this paragraph to the document, so the document does not contain its text.
Assert.assertEquals(para.getDocument(), doc);
Assert.assertEquals("", doc.getText().trim());

// Since the document owns this paragraph, we can apply one of its styles to the paragraph's contents.
para.getParagraphFormat().setStyleName("Heading 1");

// Add this node to the document, and then verify its contents.
doc.getFirstSection().getBody().appendChild(para);

Assert.assertEquals(doc.getFirstSection().getBody(), para.getParentNode());
Assert.assertEquals("Hello world!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="FirstCell"><!-- --></A><A NAME="getFirstCell()"><!-- --></A><A NAME="getFirstCell--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFirstCell</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Cell.html" title="class in com.aspose.words">Cell</A>&nbsp;<B>getFirstCell</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns the first <cref><A HREF="Cell.html" title="class in com.aspose.words">Cell</A></cref> in the row.
            </summary><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<A NAME="FirstChild"><!-- --></A><A NAME="getFirstChild()"><!-- --></A><A NAME="getFirstChild--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFirstChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getFirstChild</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first child of the node.
            </summary><remarks>
            If there is no first child node, a <code>null</code> is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to use a node's NextSibling property to enumerate through its immediate children.<pre>
Document doc = new Document(getMyDir() + "Paragraphs.docx");

for (Node node = doc.getFirstSection().getBody().getFirstChild(); node != null; node = node.getNextSibling()) {
    System.out.println(Node.nodeTypeToString(node.getNodeType()));
}</pre></example><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="HasChildNodes"><!-- --></A><A NAME="hasChildNodes()"><!-- --></A><A NAME="hasChildNodes--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>hasChildNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>hasChildNodes</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns <code>true</code> if this node has any child nodes.
            </summary><example><p><b>Example:</b></p>Shows how to combine the rows from two tables into one.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");

// Below are two ways of getting a table from a document.
// 1 -  From the "Tables" collection of a Body node:
Table firstTable = doc.getFirstSection().getBody().getTables().get(0);

// 2 -  Using the "GetChild" method:
Table secondTable = (Table) doc.getChild(NodeType.TABLE, 1, true);

// Append all rows from the current table to the next.
while (secondTable.hasChildNodes())
    firstTable.getRows().add(secondTable.getFirstRow());

// Remove the empty table container.
secondTable.remove();

doc.save(getArtifactsDir() + "Table.CombineTables.docx");</pre></example>
</DL>
<HR>

<A NAME="Hidden"><!-- --></A><A NAME="getHidden()"><!-- --></A><A NAME="getHidden--"><!-- --></A><A NAME="setHidden(boolean)"><!-- --></A><A NAME="setHidden-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getHidden/setHidden</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getHidden</B>()&nbsp;/&nbsp;public void&nbsp;<B>setHidden</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a flag indicating whether this row is hidden or not.
            </summary><remarks>
            Hidden row is not supported for WordML and ODT documents.
            </remarks><example><p><b>Example:</b></p>Shows how to hide a table row.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");

Row row = doc.getFirstSection().getBody().getTables().get(0).getFirstRow();
row.setHidden(true);

doc.save(getArtifactsDir() + "Table.HiddenRow.docx");

doc = new Document(getArtifactsDir() + "Table.HiddenRow.docx");

row = doc.getFirstSection().getBody().getTables().get(0).getFirstRow();
Assert.assertTrue(row.getHidden());

for (Cell cell : row.getCells())
{
    for (Paragraph para : cell.getParagraphs())
    {
        for (Run run : para.getRuns())
            Assert.assertTrue(run.getFont().getHidden());
    }
}</pre></example>
</DL>
<HR>

<A NAME="IsComposite"><!-- --></A><A NAME="isComposite()"><!-- --></A><A NAME="isComposite--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isComposite</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isComposite</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns <code>true</code> as this node can have child nodes.
            </summary><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="IsFirstRow"><!-- --></A><A NAME="isFirstRow()"><!-- --></A><A NAME="isFirstRow--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isFirstRow</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isFirstRow</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            True if this is the first row in a table; false otherwise.
            </summary><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<A NAME="IsLastRow"><!-- --></A><A NAME="isLastRow()"><!-- --></A><A NAME="isLastRow--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isLastRow</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isLastRow</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            True if this is the last row in a table; false otherwise.
            </summary><example><p><b>Example:</b></p>Shows how to set a table to stay together on the same page.<pre>
Document doc = new Document(getMyDir() + "Table spanning two pages.docx");
Table table = doc.getFirstSection().getBody().getTables().get(0);

// Enabling KeepWithNext for every paragraph in the table except for the
// last ones in the last row will prevent the table from splitting across multiple pages.
for (Cell cell : (Iterable&lt;Cell&gt;) table.getChildNodes(NodeType.CELL, true))
    for (Paragraph para : cell.getParagraphs()) {
        Assert.assertTrue(para.isInCell());

        if (!(cell.getParentRow().isLastRow() &amp;&amp; para.isEndOfCell()))
            para.getParagraphFormat().setKeepWithNext(true);
    }

doc.save(getArtifactsDir() + "Table.KeepTableTogether.docx");</pre></example>
</DL>
<HR>

<A NAME="LastCell"><!-- --></A><A NAME="getLastCell()"><!-- --></A><A NAME="getLastCell--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getLastCell</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Cell.html" title="class in com.aspose.words">Cell</A>&nbsp;<B>getLastCell</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns the last <cref><A HREF="Cell.html" title="class in com.aspose.words">Cell</A></cref> in the row.
            </summary><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<A NAME="LastChild"><!-- --></A><A NAME="getLastChild()"><!-- --></A><A NAME="getLastChild--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getLastChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getLastChild</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the last child of the node.
            </summary><remarks>
            If there is no last child node, a <code>null</code> is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to use of methods of Node and CompositeNode to remove a section before the last section in the document.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Section 1 text.");
builder.insertBreak(BreakType.SECTION_BREAK_CONTINUOUS);
builder.writeln("Section 2 text.");

// Both sections are siblings of each other.
Section lastSection = (Section) doc.getLastChild();
Section firstSection = (Section) lastSection.getPreviousSibling();

// Remove a section based on its sibling relationship with another section.
if (lastSection.getPreviousSibling() != null)
    doc.removeChild(firstSection);

// The section we removed was the first one, leaving the document with only the second.
Assert.assertEquals("Section 2 text.", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="NextRow"><!-- --></A><A NAME="getNextRow()"><!-- --></A><A NAME="getNextRow--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNextRow</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Row.html" title="class in com.aspose.words">Row</A>&nbsp;<B>getNextRow</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the next <cref><i>Row</i></cref> node.
            </summary><remarks>
            The method can be used when you need to have typed access to table rows. If a
            <cref><A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A></cref> node is found in a table instead of a row,
            it is automatically traversed to get a row contained within.
            </remarks><example><p><b>Example:</b></p>Shows how to enumerate through all table cells.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");
Table table = doc.getFirstSection().getBody().getTables().get(0);

// Enumerate through all cells of the table.
for (Row row = table.getFirstRow(); row != null; row = row.getNextRow())
{
    for (Cell cell = row.getFirstCell(); cell != null; cell = cell.getNextCell())
    {
        System.out.println(cell.getText());
    }
}</pre></example>
</DL>
<HR>

<A NAME="NextSibling"><!-- --></A><A NAME="getNextSibling()"><!-- --></A><A NAME="getNextSibling--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNextSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getNextSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately following this node.
            </summary><remarks>
            If there is no next node, a <code>null</code> is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to use a node's NextSibling property to enumerate through its immediate children.<pre>
Document doc = new Document(getMyDir() + "Paragraphs.docx");

for (Node node = doc.getFirstSection().getBody().getFirstChild(); node != null; node = node.getNextSibling()) {
    System.out.println(Node.nodeTypeToString(node.getNodeType()));
}</pre></example><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="NodeType"><!-- --></A><A NAME="getNodeType()"><!-- --></A><A NAME="getNodeType--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNodeType</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getNodeType</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns <cref><A HREF="NodeType.html#ROW" title="field in class com.aspose.words.NodeType">NodeType.ROW</A></cref>.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</summary><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="ParentNode"><!-- --></A><A NAME="getParentNode()"><!-- --></A><A NAME="getParentNode--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getParentNode</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getParentNode</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the immediate parent of this node.
            </summary><remarks><p>If a node has just been created and not yet added to the tree,
            or if it has been removed from the tree, the parent is <code>null</code>.</p></remarks><example><p><b>Example:</b></p>Shows how to access a node's parent node.<pre>
Document doc = new Document();
Paragraph para = doc.getFirstSection().getBody().getFirstParagraph();

// Append a child Run node to the document's first paragraph.
Run run = new Run(doc, "Hello world!");
para.appendChild(run);

// The paragraph is the parent node of the run node. We can trace this lineage
// all the way to the document node, which is the root of the document's node tree.
Assert.assertEquals(para, run.getParentNode());
Assert.assertEquals(doc.getFirstSection().getBody(), para.getParentNode());
Assert.assertEquals(doc.getFirstSection(), doc.getFirstSection().getBody().getParentNode());
Assert.assertEquals(doc, doc.getFirstSection().getParentNode());</pre></example><example><p><b>Example:</b></p>Shows how to create a node and set its owning document.<pre>
Document doc = new Document();
Paragraph para = new Paragraph(doc);
para.appendChild(new Run(doc, "Hello world!"));

// We have not yet appended this paragraph as a child to any composite node.
Assert.assertNull(para.getParentNode());

// If a node is an appropriate child node type of another composite node,
// we can attach it as a child only if both nodes have the same owner document.
// The owner document is the document we passed to the node's constructor.
// We have not attached this paragraph to the document, so the document does not contain its text.
Assert.assertEquals(para.getDocument(), doc);
Assert.assertEquals("", doc.getText().trim());

// Since the document owns this paragraph, we can apply one of its styles to the paragraph's contents.
para.getParagraphFormat().setStyleName("Heading 1");

// Add this node to the document, and then verify its contents.
doc.getFirstSection().getBody().appendChild(para);

Assert.assertEquals(doc.getFirstSection().getBody(), para.getParentNode());
Assert.assertEquals("Hello world!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="ParentTable"><!-- --></A><A NAME="getParentTable()"><!-- --></A><A NAME="getParentTable--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getParentTable</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Table.html" title="class in com.aspose.words">Table</A>&nbsp;<B>getParentTable</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns the immediate parent table of the row.
            </summary><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<A NAME="PreviousRow"><!-- --></A><A NAME="getPreviousRow()"><!-- --></A><A NAME="getPreviousRow--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPreviousRow</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Row.html" title="class in com.aspose.words">Row</A>&nbsp;<B>getPreviousRow</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the previous <cref><i>Row</i></cref> node.
            </summary><remarks>
            The method can be used when you need to have typed access to table rows. If a
            <cref><A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A></cref> node is found in a table instead of a row,
            it is automatically traversed to get a row contained within.
            </remarks><example><p><b>Example:</b></p>Shows how to enumerate through all table cells.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");
Table table = doc.getFirstSection().getBody().getTables().get(0);

// Enumerate through all cells of the table.
for (Row row = table.getFirstRow(); row != null; row = row.getNextRow())
{
    for (Cell cell = row.getFirstCell(); cell != null; cell = cell.getNextCell())
    {
        System.out.println(cell.getText());
    }
}</pre></example>
</DL>
<HR>

<A NAME="PreviousSibling"><!-- --></A><A NAME="getPreviousSibling()"><!-- --></A><A NAME="getPreviousSibling--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPreviousSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getPreviousSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately preceding this node.
            </summary><remarks>
            If there is no preceding node, a <code>null</code> is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to use of methods of Node and CompositeNode to remove a section before the last section in the document.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Section 1 text.");
builder.insertBreak(BreakType.SECTION_BREAK_CONTINUOUS);
builder.writeln("Section 2 text.");

// Both sections are siblings of each other.
Section lastSection = (Section) doc.getLastChild();
Section firstSection = (Section) lastSection.getPreviousSibling();

// Remove a section based on its sibling relationship with another section.
if (lastSection.getPreviousSibling() != null)
    doc.removeChild(firstSection);

// The section we removed was the first one, leaving the document with only the second.
Assert.assertEquals("Section 2 text.", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="Range"><!-- --></A><A NAME="getRange()"><!-- --></A><A NAME="getRange--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRange</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Range.html" title="class in com.aspose.words">Range</A>&nbsp;<B>getRange</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a <cref><A HREF="Range.html" title="class in com.aspose.words">Range</A></cref> object that represents the portion of a document that is contained in this node.
            </summary><example><p><b>Example:</b></p>Shows how to delete all the nodes from a range.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Add text to the first section in the document, and then add another section.
builder.write("Section 1. ");
builder.insertBreak(BreakType.SECTION_BREAK_CONTINUOUS);
builder.write("Section 2.");

Assert.assertEquals("Section 1. \fSection 2.", doc.getText().trim());

// Remove the first section entirely by removing all the nodes
// within its range, including the section itself.
doc.getSections().get(0).getRange().delete();

Assert.assertEquals(1, doc.getSections().getCount());
Assert.assertEquals("Section 2.", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="RowFormat"><!-- --></A><A NAME="getRowFormat()"><!-- --></A><A NAME="getRowFormat--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRowFormat</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="RowFormat.html" title="class in com.aspose.words">RowFormat</A>&nbsp;<B>getRowFormat</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Provides access to the formatting properties of the row.
            </summary><example><p><b>Example:</b></p>Shows how to modify formatting of a table row.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");
Table table = doc.getFirstSection().getBody().getTables().get(0);

// Use the first row's "RowFormat" property to set formatting that modifies that entire row's appearance.
Row firstRow = table.getFirstRow();
firstRow.getRowFormat().getBorders().setLineStyle(LineStyle.NONE);
firstRow.getRowFormat().setHeightRule(HeightRule.AUTO);
firstRow.getRowFormat().setAllowBreakAcrossPages(true);

doc.save(getArtifactsDir() + "Table.RowFormat.docx");</pre></example><example><p><b>Example:</b></p>Shows how to modify the format of rows and cells in a table.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

Table table = builder.startTable();
builder.insertCell();
builder.write("City");
builder.insertCell();
builder.write("Country");
builder.endRow();
builder.insertCell();
builder.write("London");
builder.insertCell();
builder.write("U.K.");
builder.endTable();

// Use the first row's "RowFormat" property to modify the formatting
// of the contents of all cells in this row.
RowFormat rowFormat = table.getFirstRow().getRowFormat();
rowFormat.setHeight(25.0);
rowFormat.getBorders().getByBorderType(BorderType.BOTTOM).setColor(Color.RED);

// Use the "CellFormat" property of the first cell in the last row to modify the formatting of that cell's contents.
CellFormat cellFormat = table.getLastRow().getFirstCell().getCellFormat();
cellFormat.setWidth(100.0);
cellFormat.getShading().setBackgroundPatternColor(Color.ORANGE);

doc.save(getArtifactsDir() + "Table.RowCellFormat.docx");</pre></example>
</DL>
<HR>



<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="accept(com.aspose.words.DocumentVisitor)"><!-- --></A><A NAME="accept-com.aspose.words.DocumentVisitor-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>accept</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>accept</B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)
              throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
Accepts a visitor.
</summary><remarks><p>Enumerates over this node and all of its children. Each node calls a corresponding method on <cref><A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A></cref>.</p><p>For more info see the Visitor design pattern.</p></remarks><remarks>
            Calls <cref><A HREF="DocumentVisitor.html#visitRowStart(com.aspose.words.Row)" title="method in class com.aspose.words.DocumentVisitor">DocumentVisitor.visitRowStart(com.aspose.words.Row)</A></cref>, then calls <cref><A HREF="#accept(com.aspose.words.DocumentVisitor)" title="method in class com.aspose.words.Row">accept(com.aspose.words.DocumentVisitor)</A></cref> for all child nodes of the section
            and calls <cref><A HREF="DocumentVisitor.html#visitRowEnd(com.aspose.words.Row)" title="method in class com.aspose.words.DocumentVisitor">DocumentVisitor.visitRowEnd(com.aspose.words.Row)</A></cref> at the end.
            </remarks><DL><DT><B>Parameters:</B></DT><DD param="visitor"><CODE>visitor</CODE> - The visitor that will visit the nodes.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">True if all nodes were visited; false if <cref><A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A></cref> stopped the operation before visiting all nodes.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<A NAME="acceptEnd(com.aspose.words.DocumentVisitor)"><!-- --></A><A NAME="acceptEnd-com.aspose.words.DocumentVisitor-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>acceptEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>acceptEnd</B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)
             throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Accepts a visitor for visiting the end of the row.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="visitor"><CODE>visitor</CODE> - The document visitor.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value. The action to be taken by the visitor.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<A NAME="acceptStart(com.aspose.words.DocumentVisitor)"><!-- --></A><A NAME="acceptStart-com.aspose.words.DocumentVisitor-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>acceptStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>acceptStart</B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Accepts a visitor for visiting the start of the row.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="visitor"><CODE>visitor</CODE> - The document visitor.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value. The action to be taken by the visitor.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<A NAME="deepClone(boolean)"><!-- --></A><A NAME="deepClone-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>deepClone</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>deepClone</B>(boolean&nbsp;isCloneChildren)</PRE></TD></TR></TABLE>
<DL><DD><summary>
Creates a duplicate of the node.
</summary><remarks><p>This method serves as a copy constructor for nodes. 
The cloned node has no parent, but belongs to the same document as the original node.</p><p>This method always performs a deep copy of the node. The <i>isCloneChildren</i> parameter
specifies whether to perform copy all child nodes as well.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="isCloneChildren"><CODE>isCloneChildren</CODE> - True to recursively clone the subtree under the specified node; 
false to clone only the node itself.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The cloned node.</DD></DL><example><p><b>Example:</b></p>Shows how to clone a composite node.<pre>
Document doc = new Document();
Paragraph para = doc.getFirstSection().getBody().getFirstParagraph();
para.appendChild(new Run(doc, "Hello world!"));

// Below are two ways of cloning a composite node.
// 1 -  Create a clone of a node, and create a clone of each of its child nodes as well.
Node cloneWithChildren = para.deepClone(true);

Assert.assertTrue(((CompositeNode) cloneWithChildren).hasChildNodes());
Assert.assertEquals("Hello world!", cloneWithChildren.getText().trim());

// 2 -  Create a clone of a node just by itself without any children.
Node cloneWithoutChildren = para.deepClone(false);

Assert.assertFalse(((CompositeNode) cloneWithoutChildren).hasChildNodes());
Assert.assertEquals("", cloneWithoutChildren.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="ensureMinimum()"><!-- --></A><A NAME="ensureMinimum--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>ensureMinimum</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>ensureMinimum</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            If the <cref><i>Row</i></cref> has no cells, creates and appends one <cref><A HREF="Cell.html" title="class in com.aspose.words">Cell</A></cref>.
            </summary><example><p><b>Example:</b></p>Shows how to ensure a row node contains the nodes we need to begin adding content to it.<pre>
Document doc = new Document();
Table table = new Table(doc);
doc.getFirstSection().getBody().appendChild(table);
Row row = new Row(doc);
table.appendChild(row);

// Rows contain cells, containing paragraphs with typical elements such as runs, shapes, and even other tables.
// Our new row has none of these nodes, and we cannot add contents to it until it does.
Assert.assertEquals(0, row.getChildNodes(NodeType.ANY, true).getCount());

// Calling the "EnsureMinimum" method on a table will ensure that
// the table has at least one cell with an empty paragraph.
row.ensureMinimum();
row.getFirstCell().getFirstParagraph().appendChild(new Run(doc, "Hello world!"));</pre></example>
</DL>
<HR>

<A NAME="getAncestor(int)"><!-- --></A><A NAME="getAncestor-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(int&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. The node type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or <code>null</code> if no ancestor of this type was found.</DD></DL><example><p><b>Example:</b></p>Shows how to find out if a tables are nested.<pre>
public void calculateDepthOfNestedTables() throws Exception {
    Document doc = new Document(getMyDir() + "Nested tables.docx");
    NodeCollection tables = doc.getChildNodes(NodeType.TABLE, true);
    for (int i = 0; i &lt; tables.getCount(); i++) {
        Table table = (Table) tables.get(i);

        // Find out if any cells in the table have other tables as children.
        int count = getChildTableCount(table);
        System.out.print(MessageFormat.format("Table #{0} has {1} tables directly within its cells", i, count));

        // Find out if the table is nested inside another table, and, if so, at what depth.
        int tableDepth = getNestedDepthOfTable(table);

        if (tableDepth &gt; 0)
            System.out.println(MessageFormat.format("Table #{0} is nested inside another table at depth of {1}", i, tableDepth));
        else
            System.out.println(MessageFormat.format("Table #{0} is a non nested table (is not a child of another table)", i));
    }
}

// Calculates what level a table is nested inside other tables.
//
// Returns An integer containing the level the table is nested at.
// 0 = Table is not nested inside any other table
// 1 = Table is nested within one parent table
// 2 = Table is nested within two parent tables etc..
private static int getNestedDepthOfTable(final Table table) {
    int depth = 0;
    Node parent = table.getAncestor(table.getNodeType());

    while (parent != null) {
        depth++;
        parent = parent.getAncestor(Table.class);
    }

    return depth;
}

// Determines if a table contains any immediate child table within its cells.
// Does not recursively traverse through those tables to check for further tables.
//
// Returns true if at least one child cell contains a table.
// Returns false if no cells in the table contains a table.
private static int getChildTableCount(final Table table) {
    int childTableCount = 0;

    for (Row row : table.getRows()) {
        for (Cell cell : row.getCells()) {
            TableCollection childTables = cell.getTables();

            if (childTables.getCount() &gt; 0) childTableCount++;
        }
    }

    return childTableCount;
}</pre></example>
</DL>
<HR>

<A NAME="getAncestor(java.lang.Class)"><!-- --></A><A NAME="getAncestor-java.lang.Class-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(java.lang.Class&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified object type.
            </summary><remarks><p>The ancestor type matches if it is equal to <i>ancestorType</i> or derived from <i>ancestorType</i>.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - The object type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or <code>null</code> if no ancestor of this type was found.</DD></DL><example><p><b>Example:</b></p>Shows how to find out if a tables are nested.<pre>
public void calculateDepthOfNestedTables() throws Exception {
    Document doc = new Document(getMyDir() + "Nested tables.docx");
    NodeCollection tables = doc.getChildNodes(NodeType.TABLE, true);
    for (int i = 0; i &lt; tables.getCount(); i++) {
        Table table = (Table) tables.get(i);

        // Find out if any cells in the table have other tables as children.
        int count = getChildTableCount(table);
        System.out.print(MessageFormat.format("Table #{0} has {1} tables directly within its cells", i, count));

        // Find out if the table is nested inside another table, and, if so, at what depth.
        int tableDepth = getNestedDepthOfTable(table);

        if (tableDepth &gt; 0)
            System.out.println(MessageFormat.format("Table #{0} is nested inside another table at depth of {1}", i, tableDepth));
        else
            System.out.println(MessageFormat.format("Table #{0} is a non nested table (is not a child of another table)", i));
    }
}

// Calculates what level a table is nested inside other tables.
//
// Returns An integer containing the level the table is nested at.
// 0 = Table is not nested inside any other table
// 1 = Table is nested within one parent table
// 2 = Table is nested within two parent tables etc..
private static int getNestedDepthOfTable(final Table table) {
    int depth = 0;
    Node parent = table.getAncestor(table.getNodeType());

    while (parent != null) {
        depth++;
        parent = parent.getAncestor(Table.class);
    }

    return depth;
}

// Determines if a table contains any immediate child table within its cells.
// Does not recursively traverse through those tables to check for further tables.
//
// Returns true if at least one child cell contains a table.
// Returns false if no cells in the table contains a table.
private static int getChildTableCount(final Table table) {
    int childTableCount = 0;

    for (Row row : table.getRows()) {
        for (Cell cell : row.getCells()) {
            TableCollection childTables = cell.getTables();

            if (childTables.getCount() &gt; 0) childTableCount++;
        }
    }

    return childTableCount;
}</pre></example>
</DL>
<HR>

<A NAME="getChild(int,int,boolean)"><!-- --></A><A NAME="getChild-int-int-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getChild</B>(int&nbsp;nodeType, int&nbsp;index, boolean&nbsp;isDeep)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns an Nth child node that matches the specified type.
            </summary><remarks><p>If index is out of range, a <code>null</code> is returned.</p></remarks><remarks>Note that markup nodes (<cref><A HREF="NodeType.html#STRUCTURED_DOCUMENT_TAG" title="field in class com.aspose.words.NodeType">NodeType.STRUCTURED_DOCUMENT_TAG</A></cref> and <cref><A HREF="NodeType.html#SMART_TAG" title="field in class com.aspose.words.NodeType">NodeType.SMART_TAG</A></cref>)
            are traversed even when <i>isDeep</i> = <code>false</code> and <cref><A HREF="#getChild(int,int,boolean)" title="method in class com.aspose.words.Row">getChild(int,int,boolean)</A></cref> is invoked for non-markup node type. For example if the first run in a para
            is wrapped in a <cref><A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A></cref>, it will still be returned by <cref><A HREF="#getChild(int,int,boolean)" title="method in class com.aspose.words.Row">getChild(int,int,boolean)</A></cref>(<cref><A HREF="NodeType.html#RUN" title="field in class com.aspose.words.NodeType">NodeType.RUN</A></cref>, 0, <code>false</code>).</remarks><DL><DT><B>Parameters:</B></DT><DD param="nodeType"><CODE>nodeType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. Specifies the type of the child node.</DD><DD param="index"><CODE>index</CODE> - Zero based index of the child node to select.
            Negative indexes are also allowed and indicate access from the end,
            that is -1 means the last node.</DD><DD param="isDeep"><CODE>isDeep</CODE> - <code>true</code> to select from all child nodes recursively;
            <code>false</code> to select only among immediate children. See remarks for more info.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The child node that matches the criteria or <code>null</code> if no matching node is found.</DD></DL><example><p><b>Example:</b></p>Shows how to traverse through a composite node's collection of child nodes.<pre>
Document doc = new Document();

// Add two runs and one shape as child nodes to the first paragraph of this document.
Paragraph paragraph = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 0, true);
paragraph.appendChild(new Run(doc, "Hello world! "));

Shape shape = new Shape(doc, ShapeType.RECTANGLE);
shape.setWidth(200.0);
shape.setHeight(200.0);
// Note that the 'CustomNodeId' is not saved to an output file and exists only during the node lifetime.
shape.setCustomNodeId(100);
shape.setWrapType(WrapType.INLINE);
paragraph.appendChild(shape);

paragraph.appendChild(new Run(doc, "Hello again!"));

// Iterate through the paragraph's collection of immediate children,
// and print any runs or shapes that we find within.
NodeCollection children = paragraph.getChildNodes(NodeType.ANY, false);

Assert.assertEquals(3, paragraph.getChildNodes(NodeType.ANY, false).getCount());

for (Node child : (Iterable&lt;Node&gt;) children)
    switch (child.getNodeType()) {
        case NodeType.RUN:
            System.out.println("Run contents:");
            System.out.println(MessageFormat.format("\t\"{0}\"", child.getText().trim()));
            break;
        case NodeType.SHAPE:
            Shape childShape = (Shape)child;
            System.out.println("Shape:");
            System.out.println(MessageFormat.format("\t{0}, {1}x{2}", childShape.getShapeType(), childShape.getWidth(), childShape.getHeight()));
            break;
    }</pre></example><example><p><b>Example:</b></p>Shows how to apply the properties of a table's style directly to the table's elements.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

Table table = builder.startTable();
builder.insertCell();
builder.write("Hello world!");
builder.endTable();

TableStyle tableStyle = (TableStyle) doc.getStyles().add(StyleType.TABLE, "MyTableStyle1");
tableStyle.setRowStripe(3);
tableStyle.setCellSpacing(5.0);
tableStyle.getShading().setBackgroundPatternColor(Color.WHITE);
tableStyle.getBorders().setColor(Color.BLUE);
tableStyle.getBorders().setLineStyle(LineStyle.DOT_DASH);

table.setStyle(tableStyle);

// This method concerns table style properties such as the ones we set above.
doc.expandTableStylesToDirectFormatting();

doc.save(getArtifactsDir() + "Document.TableStyleToDirectFormatting.docx");</pre></example>
</DL>
<HR>

<A NAME="getChildNodes(int,boolean)"><!-- --></A><A NAME="getChildNodes-int-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getChildNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="NodeCollection.html" title="class in com.aspose.words">NodeCollection</A>&nbsp;<B>getChildNodes</B>(int&nbsp;nodeType, boolean&nbsp;isDeep)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a live collection of child nodes that match the specified type.
            </summary><remarks><p>The collection of nodes returned by this method is always live.</p></remarks><remarks><p>A live collection is always in sync with the document. For example, if you
selected all sections in a document and enumerate through the collection
deleting the sections, the section is removed from the collection immediately
when it is removed from the document.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="nodeType"><CODE>nodeType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. Specifies the type of nodes to select.</DD><DD param="isDeep"><CODE>isDeep</CODE> - <code>true</code> to select from all child nodes recursively;
            <code>false</code> to select only among immediate children. </DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A live collection of child nodes of the specified type.</DD></DL><example><p><b>Example:</b></p>Shows how to add, update and delete child nodes in a CompositeNode's collection of children.<pre>
Document doc = new Document();

// An empty document, by default, has one paragraph.
Assert.assertEquals(1, doc.getFirstSection().getBody().getParagraphs().getCount());

// Composite nodes such as our paragraph can contain other composite and inline nodes as children.
Paragraph paragraph = doc.getFirstSection().getBody().getFirstParagraph();
Run paragraphText = new Run(doc, "Initial text. ");
paragraph.appendChild(paragraphText);

// Create three more run nodes.
Run run1 = new Run(doc, "Run 1. ");
Run run2 = new Run(doc, "Run 2. ");
Run run3 = new Run(doc, "Run 3. ");

// The document body will not display these runs until we insert them into a composite node
// that itself is a part of the document's node tree, as we did with the first run.
// We can determine where the text contents of nodes that we insert
// appears in the document by specifying an insertion location relative to another node in the paragraph.
Assert.assertEquals("Initial text.", paragraph.getText().trim());

// Insert the second run into the paragraph in front of the initial run.
paragraph.insertBefore(run2, paragraphText);

Assert.assertEquals("Run 2. Initial text.", paragraph.getText().trim());

// Insert the third run after the initial run.
paragraph.insertAfter(run3, paragraphText);

Assert.assertEquals("Run 2. Initial text. Run 3.", paragraph.getText().trim());

// Insert the first run to the start of the paragraph's child nodes collection.
paragraph.prependChild(run1);

Assert.assertEquals("Run 1. Run 2. Initial text. Run 3.", paragraph.getText().trim());
Assert.assertEquals(4, paragraph.getChildNodes(NodeType.ANY, true).getCount());

// We can modify the contents of the run by editing and deleting existing child nodes.
((Run) paragraph.getChildNodes(NodeType.RUN, true).get(1)).setText("Updated run 2. ");
paragraph.getChildNodes(NodeType.RUN, true).remove(paragraphText);

Assert.assertEquals("Run 1. Updated run 2. Run 3.", paragraph.getText().trim());
Assert.assertEquals(3, paragraph.getChildNodes(NodeType.ANY, true).getCount());</pre></example><example><p><b>Example:</b></p>Shows how to traverse through a composite node's collection of child nodes.<pre>
Document doc = new Document();

// Add two runs and one shape as child nodes to the first paragraph of this document.
Paragraph paragraph = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 0, true);
paragraph.appendChild(new Run(doc, "Hello world! "));

Shape shape = new Shape(doc, ShapeType.RECTANGLE);
shape.setWidth(200.0);
shape.setHeight(200.0);
// Note that the 'CustomNodeId' is not saved to an output file and exists only during the node lifetime.
shape.setCustomNodeId(100);
shape.setWrapType(WrapType.INLINE);
paragraph.appendChild(shape);

paragraph.appendChild(new Run(doc, "Hello again!"));

// Iterate through the paragraph's collection of immediate children,
// and print any runs or shapes that we find within.
NodeCollection children = paragraph.getChildNodes(NodeType.ANY, false);

Assert.assertEquals(3, paragraph.getChildNodes(NodeType.ANY, false).getCount());

for (Node child : (Iterable&lt;Node&gt;) children)
    switch (child.getNodeType()) {
        case NodeType.RUN:
            System.out.println("Run contents:");
            System.out.println(MessageFormat.format("\t\"{0}\"", child.getText().trim()));
            break;
        case NodeType.SHAPE:
            Shape childShape = (Shape)child;
            System.out.println("Shape:");
            System.out.println(MessageFormat.format("\t{0}, {1}x{2}", childShape.getShapeType(), childShape.getWidth(), childShape.getHeight()));
            break;
    }</pre></example><example><p><b>Example:</b></p>Shows how to extract images from a document, and save them to the local file system as individual files.<pre>
Document doc = new Document(getMyDir() + "Images.docx");

// Get the collection of shapes from the document,
// and save the image data of every shape with an image as a file to the local file system.
NodeCollection shapes = doc.getChildNodes(NodeType.SHAPE, true);

int imageIndex = 0;
for (Shape shape : (Iterable&lt;Shape&gt;) shapes) {
    if (shape.hasImage()) {
        // The image data of shapes may contain images of many possible image formats. 
        // We can determine a file extension for each image automatically, based on its format.
        String imageFileName = MessageFormat.format("File.ExtractImages.{0}{1}", imageIndex, FileFormatUtil.imageTypeToExtension(shape.getImageData().getImageType()));
        shape.getImageData().save(getArtifactsDir() + imageFileName);
        imageIndex++;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to print all of a document's comments and their replies.<pre>
Document doc = new Document(getMyDir() + "Comments.docx");

NodeCollection comments = doc.getChildNodes(NodeType.COMMENT, true);
// If a comment has no ancestor, it is a "top-level" comment as opposed to a reply-type comment.
// Print all top-level comments along with any replies they may have.
for (Comment comment : (Iterable&lt;Comment&gt;) comments) {
    if (comment.getAncestor() == null) {
        System.out.println("Top-level comment:");
        System.out.println("\t\"{comment.GetText().Trim()}\", by {comment.Author}");
        System.out.println("Has {comment.Replies.Count} replies");
        for (Comment commentReply : comment.getReplies()) {
            System.out.println("\t\"{commentReply.GetText().Trim()}\", by {commentReply.Author}");
        }
        System.out.println();
    }
}</pre></example>
</DL>
<HR>

<A NAME="getText()"><!-- --></A><A NAME="getText--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getText</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getText</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Gets the text of all cells in this row including the end of row character.
             </summary><remarks><p>Returns concatenated text of all child nodes with the end of row character
             <cref><A HREF="ControlChar.html#CELL" title="field in class com.aspose.words.ControlChar">ControlChar.CELL</A></cref> appended at the end.</p><p>The returned string includes all control and special characters as described in <cref><A HREF="ControlChar.html" title="class in com.aspose.words">ControlChar</A></cref>.</p></remarks><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<A NAME="indexOf(com.aspose.words.Node)"><!-- --></A><A NAME="indexOf-com.aspose.words.Node-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>indexOf</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>indexOf</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;child)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns the index of the specified child node in the child node array.
            </summary><remarks>
            Returns -1 if the node is not found in the child nodes.
            </remarks><example><p><b>Example:</b></p>Shows how to get the index of a given child node from its parent.<pre>
Document doc = new Document(getMyDir() + "Rendering.docx");

Body body = doc.getFirstSection().getBody();

// Retrieve the index of the last paragraph in the body of the first section.
Assert.assertEquals(24, body.getChildNodes(NodeType.ANY, false).indexOf(body.getLastParagraph()));</pre></example>
</DL>
<HR>

<A NAME="iterator()"><!-- --></A><A NAME="iterator--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>iterator</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.util.Iterator&lt;<A HREF="Node.html" title="class in com.aspose.words">Node</A>&gt;&nbsp;<B>iterator</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Provides support for the for each style iteration over the child nodes of this node.
            </summary><example><p><b>Example:</b></p>Shows how to print all of a document's comments and their replies.<pre>
Document doc = new Document(getMyDir() + "Comments.docx");

NodeCollection comments = doc.getChildNodes(NodeType.COMMENT, true);
// If a comment has no ancestor, it is a "top-level" comment as opposed to a reply-type comment.
// Print all top-level comments along with any replies they may have.
for (Comment comment : (Iterable&lt;Comment&gt;) comments) {
    if (comment.getAncestor() == null) {
        System.out.println("Top-level comment:");
        System.out.println("\t\"{comment.GetText().Trim()}\", by {comment.Author}");
        System.out.println("Has {comment.Replies.Count} replies");
        for (Comment commentReply : comment.getReplies()) {
            System.out.println("\t\"{commentReply.GetText().Trim()}\", by {commentReply.Author}");
        }
        System.out.println();
    }
}</pre></example>
</DL>
<HR>

<A NAME="nextPreOrder(com.aspose.words.Node)"><!-- --></A><A NAME="nextPreOrder-com.aspose.words.Node-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>nextPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>nextPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets next node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Next node in pre-order order. Null if reached the <i>rootNode</i>.</DD></DL><example><p><b>Example:</b></p>Shows how to traverse the document's node tree using the pre-order traversal algorithm, and delete any encountered shape with an image.<pre>
Document doc = new Document(getMyDir() + "Images.docx");
ArrayList&lt;Shape&gt; shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(9, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));

Node curNode = doc;
while (curNode != null) {
    Node nextNode = curNode.nextPreOrder(doc);

    if (curNode.previousPreOrder(doc) != null &amp;&amp; nextNode != null)
        Assert.assertEquals(curNode, nextNode.previousPreOrder(doc));

    if (curNode.getNodeType() == NodeType.SHAPE &amp;&amp; ((Shape) curNode).hasImage())
        curNode.remove();

    curNode = nextNode;
}

shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(0, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));</pre></example>
</DL>
<HR>

<A NAME="previousPreOrder(com.aspose.words.Node)"><!-- --></A><A NAME="previousPreOrder-com.aspose.words.Node-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>previousPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>previousPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the previous node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Previous node in pre-order order. Null if reached the <i>rootNode</i>.</DD></DL><example><p><b>Example:</b></p>Shows how to traverse the document's node tree using the pre-order traversal algorithm, and delete any encountered shape with an image.<pre>
Document doc = new Document(getMyDir() + "Images.docx");
ArrayList&lt;Shape&gt; shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(9, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));

Node curNode = doc;
while (curNode != null) {
    Node nextNode = curNode.nextPreOrder(doc);

    if (curNode.previousPreOrder(doc) != null &amp;&amp; nextNode != null)
        Assert.assertEquals(curNode, nextNode.previousPreOrder(doc));

    if (curNode.getNodeType() == NodeType.SHAPE &amp;&amp; ((Shape) curNode).hasImage())
        curNode.remove();

    curNode = nextNode;
}

shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(0, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));</pre></example>
</DL>
<HR>

<A NAME="remove()"><!-- --></A><A NAME="remove--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>remove</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>remove</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes itself from the parent.
            </summary><example><p><b>Example:</b></p>Shows how to delete all shapes with images from a document.<pre>
Document doc = new Document(getMyDir() + "Images.docx");
ArrayList&lt;Shape&gt; shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(9, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));

for (Shape shape : shapes)
    if (shape.hasImage())
        shape.remove();

shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(0, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));</pre></example><example><p><b>Example:</b></p>Shows how to remove all child nodes of a specific type from a composite node.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");

Assert.assertEquals(2, doc.getChildNodes(NodeType.TABLE, true).getCount());

Node curNode = doc.getFirstSection().getBody().getFirstChild();

while (curNode != null) {
    // Save the next sibling node as a variable in case we want to move to it after deleting this node.
    Node nextNode = curNode.getNextSibling();

    // A section body can contain Paragraph and Table nodes.
    // If the node is a Table, remove it from the parent.
    if (curNode.getNodeType() == NodeType.TABLE) {
        curNode.remove();
    }

    curNode = nextNode;
}

Assert.assertEquals(0, doc.getChildNodes(NodeType.TABLE, true).getCount());</pre></example>
</DL>
<HR>

<A NAME="removeAllChildren()"><!-- --></A><A NAME="removeAllChildren--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>removeAllChildren</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>removeAllChildren</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes all the child nodes of the current node.
            </summary><example><p><b>Example:</b></p>Shows how to construct an Aspose.Words document by hand.<pre>
Document doc = new Document();

// A blank document contains one section, one body and one paragraph.
// Call the "RemoveAllChildren" method to remove all those nodes,
// and end up with a document node with no children.
doc.removeAllChildren();

// This document now has no composite child nodes that we can add content to.
// If we wish to edit it, we will need to repopulate its node collection.
// First, create a new section, and then append it as a child to the root document node.
Section section = new Section(doc);
doc.appendChild(section);

// Set some page setup properties for the section.
section.getPageSetup().setSectionStart(SectionStart.NEW_PAGE);
section.getPageSetup().setPaperSize(PaperSize.LETTER);

// A section needs a body, which will contain and display all its contents
// on the page between the section's header and footer.
Body body = new Body(doc);
section.appendChild(body);

// Create a paragraph, set some formatting properties, and then append it as a child to the body.
Paragraph para = new Paragraph(doc);

para.getParagraphFormat().setStyleName("Heading 1");
para.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER);

body.appendChild(para);

// Finally, add some content to do the document. Create a run,
// set its appearance and contents, and then append it as a child to the paragraph.
Run run = new Run(doc);
run.setText("Hello World!");
run.getFont().setColor(Color.RED);
para.appendChild(run);

Assert.assertEquals("Hello World!", doc.getText().trim());

doc.save(getArtifactsDir() + "Section.CreateManually.docx");</pre></example>
</DL>
<HR>

<A NAME="removeSmartTags()"><!-- --></A><A NAME="removeSmartTags--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>removeSmartTags</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>removeSmartTags</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes all <cref><A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A></cref> descendant nodes of the current node.
            </summary><remarks>This method does not remove the content of the smart tags.</remarks><example><p><b>Example:</b></p>Shows how to create smart tags.<pre>
public void create() throws Exception {
    Document doc = new Document();

    // A smart tag appears in a document with Microsoft Word recognizes a part of its text as some form of data,
    // such as a name, date, or address, and converts it to a hyperlink that displays a purple dotted underline.
    SmartTag smartTag = new SmartTag(doc);

    // Smart tags are composite nodes that contain their recognized text in its entirety.
    // Add contents to this smart tag manually.
    smartTag.appendChild(new Run(doc, "May 29, 2019"));

    // Microsoft Word may recognize the above contents as being a date.
    // Smart tags use the "Element" property to reflect the type of data they contain.
    smartTag.setElement("date");

    // Some smart tag types process their contents further into custom XML properties.
    smartTag.getProperties().add(new CustomXmlProperty("Day", "", "29"));
    smartTag.getProperties().add(new CustomXmlProperty("Month", "", "5"));
    smartTag.getProperties().add(new CustomXmlProperty("Year", "", "2019"));

    // Set the smart tag's URI to the default value.
    smartTag.setUri("urn:schemas-microsoft-com:office:smarttags");

    doc.getFirstSection().getBody().getFirstParagraph().appendChild(smartTag);
    doc.getFirstSection().getBody().getFirstParagraph().appendChild(new Run(doc, " is a date. "));

    // Create another smart tag for a stock ticker.
    smartTag = new SmartTag(doc);
    smartTag.setElement("stockticker");
    smartTag.setUri("urn:schemas-microsoft-com:office:smarttags");

    smartTag.appendChild(new Run(doc, "MSFT"));

    doc.getFirstSection().getBody().getFirstParagraph().appendChild(smartTag);
    doc.getFirstSection().getBody().getFirstParagraph().appendChild(new Run(doc, " is a stock ticker."));

    // Print all the smart tags in our document using a document visitor.
    doc.accept(new SmartTagPrinter());

    // Older versions of Microsoft Word support smart tags.
    doc.save(getArtifactsDir() + "SmartTag.Create.doc");

    // Use the "RemoveSmartTags" method to remove all smart tags from a document.
    Assert.assertEquals(2, doc.getChildNodes(NodeType.SMART_TAG, true).getCount());

    doc.removeSmartTags();

    Assert.assertEquals(0, doc.getChildNodes(NodeType.SMART_TAG, true).getCount());
}

/// &lt;summary&gt;
/// Prints visited smart tags and their contents.
/// &lt;/summary&gt;
private static class SmartTagPrinter extends DocumentVisitor {
    /// &lt;summary&gt;
    /// Called when a SmartTag node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitSmartTagStart(SmartTag smartTag) {
        System.out.println("Smart tag type: {smartTag.Element}");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when the visiting of a SmartTag node is ended.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitSmartTagEnd(SmartTag smartTag) {
        System.out.println("\tContents: \"{smartTag.ToString(SaveFormat.Text)}\"");

        if (smartTag.getProperties().getCount() == 0) {
            System.out.println("\tContains no properties");
        } else {
            System.out.println("\tProperties: ");
            String[] properties = new String[smartTag.getProperties().getCount()];
            int index = 0;

            for (CustomXmlProperty cxp : smartTag.getProperties())
                properties[index++] = MessageFormat.format("\"{0}\" = \"{1}\"", cxp.getName(), cxp.getValue());

            System.out.println(StringUtils.join(properties, ", "));
        }

        return VisitorAction.CONTINUE;
    }
}</pre></example><example><p><b>Example:</b></p>Removes all smart tags from descendant nodes of a composite node.<pre>
Document doc = new Document(getMyDir() + "Smart tags.doc");

Assert.assertEquals(8, doc.getChildNodes(NodeType.SMART_TAG, true).getCount());

doc.removeSmartTags();

Assert.assertEquals(0, doc.getChildNodes(NodeType.SMART_TAG, true).getCount());</pre></example>
</DL>
<HR>

<A NAME="selectNodes(java.lang.String)"><!-- --></A><A NAME="selectNodes-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>selectNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="NodeList.html" title="class in com.aspose.words">NodeList</A>&nbsp;<B>selectNodes</B>(java.lang.String&nbsp;xpath)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Selects a list of nodes matching the XPath expression.
            </summary><remarks><p>Only expressions with element names are supported at the moment. Expressions
            that use attribute names are not supported.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="xpath"><CODE>xpath</CODE> - The XPath expression.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A list of nodes matching the XPath query.</DD></DL><example><p><b>Example:</b></p>Shows how to select certain nodes by using an XPath expression.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");

// This expression will extract all paragraph nodes,
// which are descendants of any table node in the document.
NodeList nodeList = doc.selectNodes("//Table//Paragraph");

// Iterate through the list with an enumerator and print the contents of every paragraph in each cell of the table.
int index = 0;

Iterator&lt;Node&gt; e = nodeList.iterator();
while (e.hasNext()) {
    Node currentNode = e.next();
    System.out.println(MessageFormat.format("Table paragraph index {0}, contents: \"{1}\"", index++, currentNode.getText().trim()));
}

// This expression will select any paragraphs that are direct children of any Body node in the document.
nodeList = doc.selectNodes("//Body/Paragraph");

// We can treat the list as an array.
Assert.assertEquals(nodeList.toArray().length, 4);

// Use SelectSingleNode to select the first result of the same expression as above.
Node node = doc.selectSingleNode("//Body/Paragraph");

Assert.assertEquals(Paragraph.class, node.getClass());</pre></example><example><p><b>Example:</b></p>Shows how to use an XPath expression to test whether a node is inside a field.<pre>
Document doc = new Document(getMyDir() + "Mail merge destination - Northwind employees.docx");

// The NodeList that results from this XPath expression will contain all nodes we find inside a field.
// However, FieldStart and FieldEnd nodes can be on the list if there are nested fields in the path.
// Currently does not find rare fields in which the FieldCode or FieldResult spans across multiple paragraphs.
NodeList resultList =
        doc.selectNodes("//FieldStart/following-sibling::node()[following-sibling::FieldEnd]");
Run[] runs = Arrays.stream(resultList.toArray()).filter(n -&gt; n.getNodeType() == NodeType.RUN).toArray(Run[]::new);
Run run = runs[0];

// Check if the specified run is one of the nodes that are inside the field.
System.out.println(MessageFormat.format("Contents of the first Run node that''s part of a field: {0}", run.getText().trim()));</pre></example>
</DL>
<HR>

<A NAME="selectSingleNode(java.lang.String)"><!-- --></A><A NAME="selectSingleNode-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>selectSingleNode</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>selectSingleNode</B>(java.lang.String&nbsp;xpath)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Selects the first <cref><A HREF="Node.html" title="class in com.aspose.words">Node</A></cref> that matches the XPath expression.
            </summary><remarks><p>Only expressions with element names are supported at the moment. Expressions
            that use attribute names are not supported.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="xpath"><CODE>xpath</CODE> - The XPath expression.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The first <cref><A HREF="Node.html" title="class in com.aspose.words">Node</A></cref> that matches the XPath query or <code>null</code> if no matching node is found.</DD></DL><example><p><b>Example:</b></p>Shows how to select certain nodes by using an XPath expression.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");

// This expression will extract all paragraph nodes,
// which are descendants of any table node in the document.
NodeList nodeList = doc.selectNodes("//Table//Paragraph");

// Iterate through the list with an enumerator and print the contents of every paragraph in each cell of the table.
int index = 0;

Iterator&lt;Node&gt; e = nodeList.iterator();
while (e.hasNext()) {
    Node currentNode = e.next();
    System.out.println(MessageFormat.format("Table paragraph index {0}, contents: \"{1}\"", index++, currentNode.getText().trim()));
}

// This expression will select any paragraphs that are direct children of any Body node in the document.
nodeList = doc.selectNodes("//Body/Paragraph");

// We can treat the list as an array.
Assert.assertEquals(nodeList.toArray().length, 4);

// Use SelectSingleNode to select the first result of the same expression as above.
Node node = doc.selectSingleNode("//Body/Paragraph");

Assert.assertEquals(Paragraph.class, node.getClass());</pre></example>
</DL>
<HR>

<A NAME="toString(com.aspose.words.SaveOptions)"><!-- --></A><A NAME="toString-com.aspose.words.SaveOptions-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string using the specified save options.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="saveOptions"><CODE>saveOptions</CODE> - Specifies the options that control how the node is saved.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><example><p><b>Example:</b></p>Exports the content of a node to String in HTML format.<pre>
Document doc = new Document(getMyDir() + "Document.docx");

Node node = doc.getLastSection().getBody().getLastParagraph();

// When we call the ToString method using the html SaveFormat overload,
// it converts the node's contents to their raw html representation.
Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%; font-size:12pt\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(SaveFormat.HTML));

// We can also modify the result of this conversion using a SaveOptions object.
HtmlSaveOptions saveOptions = new HtmlSaveOptions();
saveOptions.setExportRelativeFontSize(true);

Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(saveOptions));</pre></example>
</DL>
<HR>

<A NAME="toString(int)"><!-- --></A><A NAME="toString-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(int&nbsp;saveFormat)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string in the specified format.
            </summary><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><DL><DT><B>Parameters:</B></DT><DD><CODE>saveFormat</CODE> - A <A HREF="SaveFormat.html" title="Utility class in com.aspose.words">SaveFormat</A> value.</DD></DL><example><p><b>Example:</b></p>Shows how to extract the list labels of all paragraphs that are list items.<pre>
Document doc = new Document(getMyDir() + "Rendering.docx");
doc.updateListLabels();
int listParaCount = 1;

for (Paragraph paragraph : (Iterable&lt;Paragraph&gt;) doc.getChildNodes(NodeType.PARAGRAPH, true)) {
    // Find if we have the paragraph list. In our document, our list uses plain Arabic numbers,
    // which start at three and ends at six.
    if (paragraph.getListFormat().isListItem()) {
        System.out.println(MessageFormat.format("List item paragraph #{0}", listParaCount));

        // This is the text we get when getting when we output this node to text format.
        // This text output will omit list labels. Trim any paragraph formatting characters. 
        String paragraphText = paragraph.toString(SaveFormat.TEXT).trim();
        System.out.println("Exported Text: " + paragraphText);

        ListLabel label = paragraph.getListLabel();

        // This gets the position of the paragraph in the current level of the list. If we have a list with multiple levels,
        // this will tell us what position it is on that level.
        System.out.println("\tNumerical Id: {label.LabelValue}");

        // Combine them together to include the list label with the text in the output.
        System.out.println("\tList label combined with text: {label.LabelString} {paragraphText}");
    }</pre></example><example><p><b>Example:</b></p>Exports the content of a node to String in HTML format.<pre>
Document doc = new Document(getMyDir() + "Document.docx");

Node node = doc.getLastSection().getBody().getLastParagraph();

// When we call the ToString method using the html SaveFormat overload,
// it converts the node's contents to their raw html representation.
Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%; font-size:12pt\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(SaveFormat.HTML));

// We can also modify the result of this conversion using a SaveOptions object.
HtmlSaveOptions saveOptions = new HtmlSaveOptions();
saveOptions.setExportRelativeFontSize(true);

Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(saveOptions));</pre></example><example><p><b>Example:</b></p>Shows the difference between calling the GetText and ToString methods on a node.<pre>
Document doc = new Document();

DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField("MERGEFIELD Field");

// GetText will retrieve the visible text as well as field codes and special characters.
Assert.assertEquals("\u0013MERGEFIELD Field\u0014Field\u0015\f", doc.getText());

// ToString will give us the document's appearance if saved to a passed save format.
Assert.assertEquals("Field\r\n", doc.toString(SaveFormat.TEXT));</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>