<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 19 Jul 2025 -->
<TITLE>LayoutEnumerator</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class LayoutEnumerator</H2>
<PRE>
java.lang.Object
    <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.LayoutEnumerator</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>LayoutEnumerator </B><DT>extends java.lang.Object</DL>
</PRE>

<P>

<summary>
            Enumerates page layout entities of a document.
            
            You can use this class to walk over the page layout model. Available properties are type, geometry, text and page index where entity is rendered,
            as well as overall structure and relationships.
            Use combination of <cref><A HREF="LayoutCollector.html#getEntity(com.aspose.words.Node)" title="method in class com.aspose.words.LayoutCollector">LayoutCollector.getEntity(com.aspose.words.Node)</A></cref> and <cref><A HREF="#Current" title="property in class com.aspose.words.LayoutEnumerator">Current</A></cref> move to the entity which corresponds to a document node.
            <p>To learn more, visit the <a href="https://docs.aspose.com/words/net/converting-to-fixed-page-format/">Converting to Fixed-page Format</a> documentation article.</p></summary><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" ><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="#LayoutEnumerator(com.aspose.words.Document)">LayoutEnumerator</A></B>(<A HREF="Document.html" title="class in com.aspose.words">Document</A>&nbsp;document)</CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Initializes new instance of this class.
            </TD>
</TR>
</TABLE>&nbsp;

<!-- ========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE RULES="GROUPS" BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Property Getters/Setters Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.Object</CODE></TD><TD><CODE><B><A HREF="#Current">getCurrent</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#Current">setCurrent</A></B>(java.lang.Object&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets current position in the page layout model.
            This property returns an opaque object which corresponds to the current layout entity.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Document.html" title="class in com.aspose.words">Document</A></CODE></TD><TD><CODE><B><A HREF="#Document">getDocument</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets document this instance enumerates.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#Kind">getKind</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the kind of the current entity. This can be an empty string but never <code>null</code>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#PageIndex">getPageIndex</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the 1-based index of a page which contains the current entity.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.awt.geom.Rectangle2D.Float</CODE></TD><TD><CODE><B><A HREF="#Rectangle">getRectangle</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns the bounding rectangle of the current entity relative to the page top left corner (in points).
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#Text">getText</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets text of the current span entity. Throws for other entity types.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#Type">getType</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the type of the current entity.
            The value of the property is <A HREF="LayoutEntityType.html" title="Utility class in com.aspose.words">LayoutEntityType</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.Object</CODE></TD><TD><CODE><B><A HREF="#Item(java.lang.String)">get</A></B>(java.lang.String&nbsp;key)</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets a named property of the entity.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#moveFirstChild()">moveFirstChild</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Moves to the first child entity.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#moveLastChild()">moveLastChild</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Moves to the last child entity.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#moveNext()">moveNext</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Moves to the next sibling entity in visual order.
            
             When iterating lines of a paragraph broken across pages this method
             will not move to the next page but rather move to the next entity on the same page.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#moveNextLogical()">moveNextLogical</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Moves to the next sibling entity in a logical order.
            
             When iterating lines of a paragraph broken across pages this method
             will move to the next line even if it resides on another page.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#moveParent()">moveParent</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Moves to the parent entity.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#moveParent(int)">moveParent</A></B>(int&nbsp;types)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Moves to the parent entity of the specified type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#movePrevious()">movePrevious</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Moves to the previous sibling entity.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#movePreviousLogical()">movePreviousLogical</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Moves to the previous sibling entity in a logical order.
            
             When iterating lines of a paragraph broken across pages this method
             will move to the previous line even if it resides on another page.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#reset()">reset</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Moves the enumerator to the first page of the document.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="LayoutEnumerator(com.aspose.words.Document)"><!-- --></A><A NAME="LayoutEnumerator-com.aspose.words.Document-"><!-- --></A><H3>
LayoutEnumerator</H3>
<PRE>
public <B>LayoutEnumerator</B>(<A HREF="Document.html" title="class in com.aspose.words">Document</A>&nbsp;document)
                 throws java.lang.Exception</PRE>
<DL><DD><summary>
            Initializes new instance of this class.
            </summary><remarks><p>If page layout model of the document hasn't been built the enumerator calls <cref><A HREF="Document.html#updatePageLayout()" title="method in class com.aspose.words.Document">Document.updatePageLayout()</A></cref> to build it.</p><p>Whenever document is updated and new page layout model is created, a new enumerator must be used to access it.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="document"><CODE>document</CODE> - A document whose page layout model to enumerate.</DD></DL><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>



<!-- ============ PROPERTY DETAIL ========== -->

<A NAME="property_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Property Getters/Setters Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Current"><!-- --></A><A NAME="getCurrent()"><!-- --></A><A NAME="getCurrent--"><!-- --></A><A NAME="setCurrent(java.lang.Object)"><!-- --></A><A NAME="setCurrent-java.lang.Object-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCurrent/setCurrent</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.Object&nbsp;<B>getCurrent</B>()&nbsp;/&nbsp;public void&nbsp;<B>setCurrent</B>(java.lang.Object&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets current position in the page layout model.
            This property returns an opaque object which corresponds to the current layout entity.
            </summary><example><p><b>Example:</b></p>Shows how to see the the ranges of pages that a node spans.<pre>
Document doc = new Document();
LayoutCollector layoutCollector = new LayoutCollector(doc);

// Call the "GetNumPagesSpanned" method to count how many pages the content of our document spans.
// Since the document is empty, that number of pages is currently zero.
Assert.assertEquals(doc, layoutCollector.getDocument());
Assert.assertEquals(0, layoutCollector.getNumPagesSpanned(doc));

// Populate the document with 5 pages of content.
DocumentBuilder builder = new DocumentBuilder(doc);
builder.write("Section 1");
builder.insertBreak(BreakType.PAGE_BREAK);
builder.insertBreak(BreakType.PAGE_BREAK);
builder.insertBreak(BreakType.SECTION_BREAK_EVEN_PAGE);
builder.write("Section 2");
builder.insertBreak(BreakType.PAGE_BREAK);
builder.insertBreak(BreakType.PAGE_BREAK);

// Before the layout collector, we need to call the "UpdatePageLayout" method to give us
// an accurate figure for any layout-related metric, such as the page count.
Assert.assertEquals(0, layoutCollector.getNumPagesSpanned(doc));

layoutCollector.clear();
doc.updatePageLayout();

Assert.assertEquals(5, layoutCollector.getNumPagesSpanned(doc));

// We can see the numbers of the start and end pages of any node and their overall page spans.
NodeCollection nodes = doc.getChildNodes(NodeType.ANY, true);
for (Node node : (Iterable&lt;Node&gt;) nodes) {
    System.out.println(MessageFormat.format("-&gt;  NodeType.{0}: ", node.getNodeType()));
    System.out.println(MessageFormat.format("\tStarts on page {0}, ends on page {1},", layoutCollector.getStartPageIndex(node), layoutCollector.getEndPageIndex(node)) +
            MessageFormat.format(" spanning {0} pages.", layoutCollector.getNumPagesSpanned(node)));
}

// We can iterate over the layout entities using a LayoutEnumerator.
LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());

// The LayoutEnumerator can traverse the collection of layout entities like a tree.
// We can also apply it to any node's corresponding layout entity.
layoutEnumerator.setCurrent(layoutCollector.getEntity(doc.getChild(NodeType.PARAGRAPH, 1, true)));

Assert.assertEquals(LayoutEntityType.SPAN, layoutEnumerator.getType());
Assert.assertEquals("Â¶", layoutEnumerator.getText());</pre></example>
</DL>
<HR>

<A NAME="Document"><!-- --></A><A NAME="getDocument()"><!-- --></A><A NAME="getDocument--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getDocument</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Document.html" title="class in com.aspose.words">Document</A>&nbsp;<B>getDocument</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets document this instance enumerates.
            </summary><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="Kind"><!-- --></A><A NAME="getKind()"><!-- --></A><A NAME="getKind--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getKind</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getKind</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the kind of the current entity. This can be an empty string but never <code>null</code>.
            </summary><remarks>This is a more specific type of the current entity, e.g. bookmark span has <cref><A HREF="LayoutEntityType.html#SPAN" title="field in class com.aspose.words.LayoutEntityType">LayoutEntityType.SPAN</A></cref> type and
            may have either a BOOKMARKSTART or BOOKMARKEND kind.</remarks><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="PageIndex"><!-- --></A><A NAME="getPageIndex()"><!-- --></A><A NAME="getPageIndex--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPageIndex</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getPageIndex</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the 1-based index of a page which contains the current entity.
            </summary><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="Rectangle"><!-- --></A><A NAME="getRectangle()"><!-- --></A><A NAME="getRectangle--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRectangle</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.awt.geom.Rectangle2D.Float&nbsp;<B>getRectangle</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns the bounding rectangle of the current entity relative to the page top left corner (in points).
            </summary><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="Text"><!-- --></A><A NAME="getText()"><!-- --></A><A NAME="getText--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getText</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getText</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets text of the current span entity. Throws for other entity types.
            </summary><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="Type"><!-- --></A><A NAME="getType()"><!-- --></A><A NAME="getType--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getType</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getType</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the type of the current entity.
            The value of the property is <A HREF="LayoutEntityType.html" title="Utility class in com.aspose.words">LayoutEntityType</A> integer constant.</summary><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="Item(java.lang.String)"><!-- --></A><A NAME="get(java.lang.String)"><!-- --></A><A NAME="get-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>get</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.Object&nbsp;<B>get</B>(java.lang.String&nbsp;key)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets a named property of the entity.
            </summary><remarks>This is currently used to get font properties of spans.
            See <cref><A HREF="Font.html" title="class in com.aspose.words">Font</A></cref> class for possible properties names. Not all properties are supported.
            </remarks><DL><DT><B>Parameters:</B></DT><DD param="key"><CODE>key</CODE> - A name of the property (case-sensitive).</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Null if property is not available, otherwise value of the property.</DD></DL>
</DL>
<HR>



<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="moveFirstChild()"><!-- --></A><A NAME="moveFirstChild--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>moveFirstChild</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>moveFirstChild</B>()
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Moves to the first child entity.
            </summary><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="moveLastChild()"><!-- --></A><A NAME="moveLastChild--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>moveLastChild</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>moveLastChild</B>()
                     throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Moves to the last child entity.
            </summary><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="moveNext()"><!-- --></A><A NAME="moveNext--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>moveNext</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>moveNext</B>()
                throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Moves to the next sibling entity in visual order.
            
             When iterating lines of a paragraph broken across pages this method
             will not move to the next page but rather move to the next entity on the same page.
             </summary><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="moveNextLogical()"><!-- --></A><A NAME="moveNextLogical--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>moveNextLogical</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>moveNextLogical</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Moves to the next sibling entity in a logical order.
            
             When iterating lines of a paragraph broken across pages this method
             will move to the next line even if it resides on another page.
             </summary><remarks>
             Note that all <cref><A HREF="LayoutEntityType.html#SPAN" title="field in class com.aspose.words.LayoutEntityType">LayoutEntityType.SPAN</A></cref> entities are linked together thus if <cref><A HREF="#Current" title="property in class com.aspose.words.LayoutEnumerator">Current</A></cref>
             entity is span repeated calling of this method will iterates complete story of the document.
             </remarks><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="moveParent()"><!-- --></A><A NAME="moveParent--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>moveParent</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>moveParent</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Moves to the parent entity.
            </summary><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="moveParent(int)"><!-- --></A><A NAME="moveParent-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>moveParent</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>moveParent</B>(int&nbsp;types)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Moves to the parent entity of the specified type.
            </summary><remarks>This method is useful if you need to find the cell, column or header/footer parent of the entity.</remarks><DL><DT><B>Parameters:</B></DT><DD param="types"><CODE>types</CODE> - A <cref><A HREF="LayoutEntityType.html" title="Utility class in com.aspose.words">LayoutEntityType</A></cref> value. The parent entity type to move to. Use bitwise-OR to specify multiple parent types.</DD></DL><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="movePrevious()"><!-- --></A><A NAME="movePrevious--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>movePrevious</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>movePrevious</B>()
                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Moves to the previous sibling entity.
            </summary><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="movePreviousLogical()"><!-- --></A><A NAME="movePreviousLogical--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>movePreviousLogical</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>movePreviousLogical</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Moves to the previous sibling entity in a logical order.
            
             When iterating lines of a paragraph broken across pages this method
             will move to the previous line even if it resides on another page.
             </summary><remarks>
             Note that all <cref><A HREF="LayoutEntityType.html#SPAN" title="field in class com.aspose.words.LayoutEntityType">LayoutEntityType.SPAN</A></cref> entities are linked together thus if <cref><A HREF="#Current" title="property in class com.aspose.words.LayoutEnumerator">Current</A></cref>
             entity is span repeated calling of this method will iterates complete story of the document.
             </remarks><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<A NAME="reset()"><!-- --></A><A NAME="reset--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>reset</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>reset</B>()
          throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Moves the enumerator to the first page of the document.
            </summary><example><p><b>Example:</b></p>Shows ways of traversing a document's layout entities.<pre>
public void layoutEnumerator() throws Exception {
    // Open a document that contains a variety of layout entities.
    // Layout entities are pages, cells, rows, lines, and other objects included in the LayoutEntityType enum.
    // Each layout entity has a rectangular space that it occupies in the document body.
    Document doc = new Document(getMyDir() + "Layout entities.docx");

    // Create an enumerator that can traverse these entities like a tree.
    LayoutEnumerator layoutEnumerator = new LayoutEnumerator(doc);

    Assert.assertEquals(doc, layoutEnumerator.getDocument());

    layoutEnumerator.moveParent(LayoutEntityType.PAGE);

    Assert.assertEquals(LayoutEntityType.PAGE, layoutEnumerator.getType());
    Assert.assertThrows(IllegalStateException.class, () -&gt; System.out.println(layoutEnumerator.getText()));

    // We can call this method to make sure that the enumerator will be at the first layout entity.
    layoutEnumerator.reset();

    // There are two orders that determine how the layout enumerator continues traversing layout entities
    // when it encounters entities that span across multiple pages.
    // 1 -  In visual order:
    // When moving through an entity's children that span multiple pages,
    // page layout takes precedence, and we move to other child elements on this page and avoid the ones on the next.
    System.out.println("Traversing from first to last, elements between pages separated:");
    traverseLayoutForward(layoutEnumerator, 1);

    // Our enumerator is now at the end of the collection. We can traverse the layout entities backwards to go back to the beginning.
    System.out.println("Traversing from last to first, elements between pages separated:");
    traverseLayoutBackward(layoutEnumerator, 1);

    // 2 -  In logical order:
    // When moving through an entity's children that span multiple pages,
    // the enumerator will move between pages to traverse all the child entities.
    System.out.println("Traversing from first to last, elements between pages mixed:");
    traverseLayoutForwardLogical(layoutEnumerator, 1);

    System.out.println("Traversing from last to first, elements between pages mixed:");
    traverseLayoutBackwardLogical(layoutEnumerator, 1);
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutForward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNext());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Visual" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackward(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackward(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePrevious());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection front-to-back,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutForwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveFirstChild()) {
            traverseLayoutForwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.moveNextLogical());
}

/// &lt;summary&gt;
/// Enumerate through layoutEnumerator's layout entity collection back-to-front,
/// in a depth-first manner, and in the "Logical" order.
/// &lt;/summary&gt;
private static void traverseLayoutBackwardLogical(LayoutEnumerator layoutEnumerator, int depth) throws Exception {
    do {
        printCurrentEntity(layoutEnumerator, depth);

        if (layoutEnumerator.moveLastChild()) {
            traverseLayoutBackwardLogical(layoutEnumerator, depth + 1);
            layoutEnumerator.moveParent();
        }
    } while (layoutEnumerator.movePreviousLogical());
}

/// &lt;summary&gt;
/// Print information about layoutEnumerator's current entity to the console, while indenting the text with tab characters
/// based on its depth relative to the root node that we provided in the constructor LayoutEnumerator instance.
/// The rectangle that we process at the end represents the area and location that the entity takes up in the document.
/// &lt;/summary&gt;
private static void printCurrentEntity(LayoutEnumerator layoutEnumerator, int indent) throws Exception {
    String tabs = StringUtils.repeat("\t", indent);

    System.out.println(layoutEnumerator.getKind().equals("")
            ? MessageFormat.format("{0}-&gt; Entity type: {1}", tabs, layoutEnumerator.getType())
            : MessageFormat.format("{0}-&gt; Entity type &amp; kind: {1}, {2}", tabs, layoutEnumerator.getType(), layoutEnumerator.getKind()));

    // Only spans can contain text.
    if (layoutEnumerator.getType() == LayoutEntityType.SPAN)
        System.out.println("{tabs}   Span contents: \"{layoutEnumerator.Text}\"");

    Rectangle2D.Float leRect = layoutEnumerator.getRectangle();
    System.out.println(MessageFormat.format("{0}   Rectangle dimensions {1}x{2}, X={3} Y={4}", tabs, leRect.getWidth(), leRect.getHeight(), leRect.getX(), leRect.getY()));
    System.out.println(MessageFormat.format("{0}   Page {1}", tabs, layoutEnumerator.getPageIndex()));
}</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>