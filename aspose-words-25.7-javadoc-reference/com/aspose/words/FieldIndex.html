<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 19 Jul 2025 -->
<TITLE>FieldIndex</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class FieldIndex</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="Field.html" title="class in com.aspose.words">Field</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.FieldIndex</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>FieldIndex </B><DT>extends <A HREF="Field.html" title="class in com.aspose.words">Field</A></DL>
</PRE>

<P>

<summary>
            Implements the INDEX field.
            <p>To learn more, visit the <a href="https://docs.aspose.com/words/net/working-with-fields/">Working with Fields</a> documentation article.</p></summary><remarks>
            Builds an index using the index entries specified by XE fields, and inserts that index at this place in the document.
            </remarks><example><p><b>Example:</b></p>Shows how to create an INDEX field, and then use XE fields to populate it with entries.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side
// and the page containing the XE field on the right.
// If the XE fields have the same value in their "Text" property,
// the INDEX field will group them into one entry.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);

// Configure the INDEX field only to display XE fields that are within the bounds
// of a bookmark named "MainBookmark", and whose "EntryType" properties have a value of "A".
// For both INDEX and XE fields, the "EntryType" property only uses the first character of its string value.
index.setBookmarkName("MainBookmark");
index.setEntryType("A");

Assert.assertEquals(" INDEX  \\b MainBookmark \\f A", index.getFieldCode());

// On a new page, start the bookmark with a name that matches the value
// of the INDEX field's "BookmarkName" property.
builder.insertBreak(BreakType.PAGE_BREAK);
builder.startBookmark("MainBookmark");

// The INDEX field will pick up this entry because it is inside the bookmark,
// and its entry type also matches the INDEX field's entry type.
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Index entry 1");
indexEntry.setEntryType("A");

Assert.assertEquals(" XE  \"Index entry 1\" \\f A", indexEntry.getFieldCode());

// Insert an XE field that will not appear in the INDEX because the entry types do not match.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Index entry 2");
indexEntry.setEntryType("B");

// End the bookmark and insert an XE field afterwards.
// It is of the same type as the INDEX field, but will not appear
// since it is outside the bookmark's boundaries.
builder.endBookmark("MainBookmark");
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Index entry 3");
indexEntry.setEntryType("A");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.Filtering.docx");</pre></example><example><p><b>Example:</b></p>Shows how to populate an INDEX field with entries using XE fields, and also modify its appearance.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// If the XE fields have the same value in their "Text" property,
// the INDEX field will group them into one entry.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);
index.setLanguageId("1033");

// Setting this property's value to "A" will group all the entries by their first letter,
// and place that letter in uppercase above each group.
index.setHeading("A");

// Set the table created by the INDEX field to span over 2 columns.
index.setNumberOfColumns("2");

// Set any entries with starting letters outside the "a-c" character range to be omitted.
index.setLetterRange("a-c");

Assert.assertEquals(" INDEX  \\z 1033 \\h A \\c 2 \\p a-c", index.getFieldCode());

// These next two XE fields will show up under the "A" heading,
// with their respective text stylings also applied to their page numbers.
builder.insertBreak(BreakType.PAGE_BREAK);
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Apple");
indexEntry.isItalic(true);

Assert.assertEquals(" XE  Apple \\i", indexEntry.getFieldCode());

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Apricot");
indexEntry.isBold(true);

Assert.assertEquals(" XE  Apricot \\b", indexEntry.getFieldCode());

// Both the next two XE fields will be under a "B" and "C" heading in the INDEX fields table of contents.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Banana");

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Cherry");

// INDEX fields sort all entries alphabetically, so this entry will show up under "A" with the other two.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Avocado");

// This entry will not appear because it starts with the letter "D",
// which is outside the "a-c" character range that the INDEX field's LetterRange property defines.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Durian");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.Formatting.docx");</pre></example>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" ><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="#FieldIndex()">FieldIndex</A></B>()</CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>&nbsp;

<!-- ========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE RULES="GROUPS" BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Property Getters/Setters Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#BookmarkName">getBookmarkName</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#BookmarkName">setBookmarkName</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the name of the bookmark that marks the portion of the document used to build the index.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#CrossReferenceSeparator">getCrossReferenceSeparator</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#CrossReferenceSeparator">setCrossReferenceSeparator</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the character sequence that is used to separate cross references and other entries.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#DisplayResult">getDisplayResult</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the text that represents the displayed field result.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="FieldEnd.html" title="class in com.aspose.words">FieldEnd</A></CODE></TD><TD><CODE><B><A HREF="#End">getEnd</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node that represents the field end.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#EntryType">getEntryType</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#EntryType">setEntryType</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets an index entry type used to build the index.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="FieldFormat.html" title="class in com.aspose.words">FieldFormat</A></CODE></TD><TD><CODE><B><A HREF="#Format">getFormat</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets a <cref><A HREF="FieldFormat.html" title="class in com.aspose.words">FieldFormat</A></cref> object that provides typed access to field's formatting.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#HasPageNumberSeparator">hasPageNumberSeparator</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets a value indicating whether a page number separator is overridden through the field's code.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#HasSequenceName">hasSequenceName</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets a value indicating whether a sequence should be used while the field's result building.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#Heading">getHeading</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#Heading">setHeading</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a heading that appears at the start of each set of entries for any given letter.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsDirty">isDirty</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#IsDirty">isDirty</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets whether the current result of the field is no longer correct (stale) due to other modifications made to the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsLocked">isLocked</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#IsLocked">isLocked</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets whether the field is locked (should not recalculate its result).
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#LanguageId">getLanguageId</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#LanguageId">setLanguageId</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the language ID used to generate the index.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#LetterRange">getLetterRange</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#LetterRange">setLetterRange</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a range of letters to which limit the index.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#LocaleId">getLocaleId</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#LocaleId">setLocaleId</A></B>(int&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the LCID of the field.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#NumberOfColumns">getNumberOfColumns</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#NumberOfColumns">setNumberOfColumns</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the number of columns per page used when building the index.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#PageNumberListSeparator">getPageNumberListSeparator</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#PageNumberListSeparator">setPageNumberListSeparator</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the character sequence that is used to separate two page numbers in a page number list.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#PageNumberSeparator">getPageNumberSeparator</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#PageNumberSeparator">setPageNumberSeparator</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the character sequence that is used to separate an index entry and its page number.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#PageRangeSeparator">getPageRangeSeparator</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#PageRangeSeparator">setPageRangeSeparator</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the character sequence that is used to separate the start and end of a page range.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#Result">getResult</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#Result">setResult</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets text that is between the field separator and field end.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#RunSubentriesOnSameLine">getRunSubentriesOnSameLine</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#RunSubentriesOnSameLine">setRunSubentriesOnSameLine</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets whether run subentries into the same line as the main entry.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="FieldSeparator.html" title="class in com.aspose.words">FieldSeparator</A></CODE></TD><TD><CODE><B><A HREF="#Separator">getSeparator</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node that represents the field separator. Can be <code>null</code>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#SequenceName">getSequenceName</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#SequenceName">setSequenceName</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the name of a sequence whose number is included with the page number.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#SequenceSeparator">getSequenceSeparator</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#SequenceSeparator">setSequenceSeparator</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the character sequence that is used to separate sequence numbers and page numbers.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="FieldStart.html" title="class in com.aspose.words">FieldStart</A></CODE></TD><TD><CODE><B><A HREF="#Start">getStart</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node that represents the start of the field.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#Type">getType</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the Microsoft Word field type.
            The value of the property is <A HREF="FieldType.html" title="Utility class in com.aspose.words">FieldType</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#UseYomi">getUseYomi</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#UseYomi">setUseYomi</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets whether to enable the use of yomi text for index entries.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#getFieldCode()">getFieldCode</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns text between field start and field separator (or field end if there is no separator).
            Both field code and field result of child fields are included.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#getFieldCode(boolean)">getFieldCode</A></B>(boolean&nbsp;includeChildFieldCodes)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns text between field start and field separator (or field end if there is no separator).
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#remove()">remove</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes the field from the document. Returns a node right after the field. If the field's end is the last child
            of its parent node, returns its parent paragraph. If the field is already removed, returns <code>null</code>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#unlink()">unlink</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Performs the field unlink.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#update()">update</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Performs the field update. Throws if the field is being updated already.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#update(boolean)">update</A></B>(boolean&nbsp;ignoreMergeFormat)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Performs a field update. Throws if the field is being updated already.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="FieldIndex()"><!-- --></A><A NAME="FieldIndex--"><!-- --></A><H3>
FieldIndex</H3>
<PRE>
public <B>FieldIndex</B>()</PRE>
<DL><DD><summary />
</DL>
<HR>



<!-- ============ PROPERTY DETAIL ========== -->

<A NAME="property_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Property Getters/Setters Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="BookmarkName"><!-- --></A><A NAME="getBookmarkName()"><!-- --></A><A NAME="getBookmarkName--"><!-- --></A><A NAME="setBookmarkName(java.lang.String)"><!-- --></A><A NAME="setBookmarkName-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getBookmarkName/setBookmarkName</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getBookmarkName</B>()&nbsp;/&nbsp;public void&nbsp;<B>setBookmarkName</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the name of the bookmark that marks the portion of the document used to build the index.
            </summary><example><p><b>Example:</b></p>Shows how to create an INDEX field, and then use XE fields to populate it with entries.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side
// and the page containing the XE field on the right.
// If the XE fields have the same value in their "Text" property,
// the INDEX field will group them into one entry.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);

// Configure the INDEX field only to display XE fields that are within the bounds
// of a bookmark named "MainBookmark", and whose "EntryType" properties have a value of "A".
// For both INDEX and XE fields, the "EntryType" property only uses the first character of its string value.
index.setBookmarkName("MainBookmark");
index.setEntryType("A");

Assert.assertEquals(" INDEX  \\b MainBookmark \\f A", index.getFieldCode());

// On a new page, start the bookmark with a name that matches the value
// of the INDEX field's "BookmarkName" property.
builder.insertBreak(BreakType.PAGE_BREAK);
builder.startBookmark("MainBookmark");

// The INDEX field will pick up this entry because it is inside the bookmark,
// and its entry type also matches the INDEX field's entry type.
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Index entry 1");
indexEntry.setEntryType("A");

Assert.assertEquals(" XE  \"Index entry 1\" \\f A", indexEntry.getFieldCode());

// Insert an XE field that will not appear in the INDEX because the entry types do not match.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Index entry 2");
indexEntry.setEntryType("B");

// End the bookmark and insert an XE field afterwards.
// It is of the same type as the INDEX field, but will not appear
// since it is outside the bookmark's boundaries.
builder.endBookmark("MainBookmark");
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Index entry 3");
indexEntry.setEntryType("A");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.Filtering.docx");</pre></example>
</DL>
<HR>

<A NAME="CrossReferenceSeparator"><!-- --></A><A NAME="getCrossReferenceSeparator()"><!-- --></A><A NAME="getCrossReferenceSeparator--"><!-- --></A><A NAME="setCrossReferenceSeparator(java.lang.String)"><!-- --></A><A NAME="setCrossReferenceSeparator-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCrossReferenceSeparator/setCrossReferenceSeparator</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getCrossReferenceSeparator</B>()&nbsp;/&nbsp;public void&nbsp;<B>setCrossReferenceSeparator</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the character sequence that is used to separate cross references and other entries.
            </summary><example><p><b>Example:</b></p>Shows how to define cross references in an INDEX field.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// The INDEX entry will collect all XE fields with matching values in the "Text" property
// into one entry as opposed to making an entry for each XE field.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);

// We can configure an XE field to get its INDEX entry to display a string instead of a page number.
// First, for entries that substitute a page number with a string,
// specify a custom separator between the XE field's Text property value and the string.
index.setCrossReferenceSeparator(", see: ");

Assert.assertEquals(" INDEX  \\k \", see: \"", index.getFieldCode());

// Insert an XE field, which creates a regular INDEX entry which displays this field's page number,
// and does not invoke the CrossReferenceSeparator value.
// The entry for this XE field will display "Apple, 2".
builder.insertBreak(BreakType.PAGE_BREAK);
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Apple");

Assert.assertEquals(" XE  Apple", indexEntry.getFieldCode());

// Insert another XE field on page 3 and set a value for the PageNumberReplacement property.
// This value will show up instead of the number of the page that this field is on,
// and the INDEX field's CrossReferenceSeparator value will appear in front of it.
// The entry for this XE field will display "Banana, see: Tropical fruit".
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Banana");
indexEntry.setPageNumberReplacement("Tropical fruit");

Assert.assertEquals(" XE  Banana \\t \"Tropical fruit\"", indexEntry.getFieldCode());

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.CrossReferenceSeparator.docx");</pre></example>
</DL>
<HR>

<A NAME="DisplayResult"><!-- --></A><A NAME="getDisplayResult()"><!-- --></A><A NAME="getDisplayResult--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getDisplayResult</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getDisplayResult</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the text that represents the displayed field result.
            </summary><remarks>
            The <cref><A HREF="Document.html#updateListLabels()" title="method in class com.aspose.words.Document">Document.updateListLabels()</A></cref> method must be called to obtain correct value for the
            <cref><A HREF="FieldListNum.html" title="class in com.aspose.words">FieldListNum</A></cref>, <cref><A HREF="FieldAutoNum.html" title="class in com.aspose.words">FieldAutoNum</A></cref>, <cref><A HREF="FieldAutoNumOut.html" title="class in com.aspose.words">FieldAutoNumOut</A></cref> and <cref><A HREF="FieldAutoNumLgl.html" title="class in com.aspose.words">FieldAutoNumLgl</A></cref> fields.
            </remarks><example><p><b>Example:</b></p>Shows how to get the real text that a field displays in the document.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.write("This document was written by ");
FieldAuthor fieldAuthor = (FieldAuthor) builder.insertField(FieldType.FIELD_AUTHOR, true);
fieldAuthor.setAuthorName("John Doe");

// We can use the DisplayResult property to verify what exact text
// a field would display in its place in the document.
Assert.assertEquals("", fieldAuthor.getDisplayResult());

// Fields do not maintain accurate result values in real-time. 
// To make sure our fields display accurate results at any given time,
// such as right before a save operation, we need to update them manually.
fieldAuthor.update();

Assert.assertEquals("John Doe", fieldAuthor.getDisplayResult());

doc.save(getArtifactsDir() + "Field.DisplayResult.docx");</pre></example>
</DL>
<HR>

<A NAME="End"><!-- --></A><A NAME="getEnd()"><!-- --></A><A NAME="getEnd--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getEnd</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="FieldEnd.html" title="class in com.aspose.words">FieldEnd</A>&nbsp;<B>getEnd</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node that represents the field end.
            </summary><example><p><b>Example:</b></p>Shows how to work with a collection of fields.<pre>
public void fieldCollection() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    builder.insertField(" DATE \\@ \"dddd, d MMMM yyyy\" ");
    builder.insertField(" TIME ");
    builder.insertField(" REVNUM ");
    builder.insertField(" AUTHOR  \"John Doe\" ");
    builder.insertField(" SUBJECT \"My Subject\" ");
    builder.insertField(" QUOTE \"Hello world!\" ");
    doc.updateFields();

    FieldCollection fields = doc.getRange().getFields();

    Assert.assertEquals(6, fields.getCount());

    // Iterate over the field collection, and print contents and type
    // of every field using a custom visitor implementation.
    FieldVisitor fieldVisitor = new FieldVisitor();

    Iterator&lt;Field&gt; fieldEnumerator = fields.iterator();

    while (fieldEnumerator.hasNext()) {
        if (fieldEnumerator != null) {
            Field currentField = fieldEnumerator.next();

            currentField.getStart().accept(fieldVisitor);
            if (currentField.getSeparator() != null) {
                currentField.getSeparator().accept(fieldVisitor);
            }
            currentField.getEnd().accept(fieldVisitor);
        } else {
            System.out.println("There are no fields in the document.");
        }
    }

    System.out.println(fieldVisitor.getText());
}

/// &lt;summary&gt;
/// Document visitor implementation that prints field info.
/// &lt;/summary&gt;
public static class FieldVisitor extends DocumentVisitor {
    public FieldVisitor() {
        mBuilder = new StringBuilder();
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(final FieldStart fieldStart) {
        mBuilder.append("Found field: " + fieldStart.getFieldType() + "\r\n");
        mBuilder.append("\tField code: " + fieldStart.getField().getFieldCode() + "\r\n");
        mBuilder.append("\tDisplayed as: " + fieldStart.getField().getResult() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(final FieldSeparator fieldSeparator) {
        mBuilder.append("\tFound separator: " + fieldSeparator.getText() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(final FieldEnd fieldEnd) {
        mBuilder.append("End of field: " + fieldEnd.getFieldType() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    private final /*final*/ StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="EntryType"><!-- --></A><A NAME="getEntryType()"><!-- --></A><A NAME="getEntryType--"><!-- --></A><A NAME="setEntryType(java.lang.String)"><!-- --></A><A NAME="setEntryType-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getEntryType/setEntryType</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getEntryType</B>()&nbsp;/&nbsp;public void&nbsp;<B>setEntryType</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets an index entry type used to build the index.
            </summary><example><p><b>Example:</b></p>Shows how to create an INDEX field, and then use XE fields to populate it with entries.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side
// and the page containing the XE field on the right.
// If the XE fields have the same value in their "Text" property,
// the INDEX field will group them into one entry.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);

// Configure the INDEX field only to display XE fields that are within the bounds
// of a bookmark named "MainBookmark", and whose "EntryType" properties have a value of "A".
// For both INDEX and XE fields, the "EntryType" property only uses the first character of its string value.
index.setBookmarkName("MainBookmark");
index.setEntryType("A");

Assert.assertEquals(" INDEX  \\b MainBookmark \\f A", index.getFieldCode());

// On a new page, start the bookmark with a name that matches the value
// of the INDEX field's "BookmarkName" property.
builder.insertBreak(BreakType.PAGE_BREAK);
builder.startBookmark("MainBookmark");

// The INDEX field will pick up this entry because it is inside the bookmark,
// and its entry type also matches the INDEX field's entry type.
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Index entry 1");
indexEntry.setEntryType("A");

Assert.assertEquals(" XE  \"Index entry 1\" \\f A", indexEntry.getFieldCode());

// Insert an XE field that will not appear in the INDEX because the entry types do not match.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Index entry 2");
indexEntry.setEntryType("B");

// End the bookmark and insert an XE field afterwards.
// It is of the same type as the INDEX field, but will not appear
// since it is outside the bookmark's boundaries.
builder.endBookmark("MainBookmark");
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Index entry 3");
indexEntry.setEntryType("A");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.Filtering.docx");</pre></example>
</DL>
<HR>

<A NAME="Format"><!-- --></A><A NAME="getFormat()"><!-- --></A><A NAME="getFormat--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFormat</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="FieldFormat.html" title="class in com.aspose.words">FieldFormat</A>&nbsp;<B>getFormat</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets a <cref><A HREF="FieldFormat.html" title="class in com.aspose.words">FieldFormat</A></cref> object that provides typed access to field's formatting.
            </summary><example><p><b>Example:</b></p>Shows how to format field results.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Use a document builder to insert a field that displays a result with no format applied.
Field field = builder.insertField("= 2 + 3");

Assert.assertEquals("= 2 + 3", field.getFieldCode());
Assert.assertEquals("5", field.getResult());

// We can apply a format to a field's result using the field's properties.
// Below are three types of formats that we can apply to a field's result.
// 1 -  Numeric format:
FieldFormat format = field.getFormat();
format.setNumericFormat("$###.00");
field.update();

Assert.assertEquals("= 2 + 3 \\# $###.00", field.getFieldCode());
Assert.assertEquals("$  5.00", field.getResult());

// 2 -  Date/time format:
field = builder.insertField("DATE");
format = field.getFormat();
format.setDateTimeFormat("dddd, MMMM dd, yyyy");
field.update();

Assert.assertEquals("DATE \\@ \"dddd, MMMM dd, yyyy\"", field.getFieldCode());
System.out.println("Today's date, in {format.DateTimeFormat} format:\n\t{field.Result}");

// 3 -  General format:
field = builder.insertField("= 25 + 33");
format = field.getFormat();
format.getGeneralFormats().add(GeneralFormat.LOWERCASE_ROMAN);
format.getGeneralFormats().add(GeneralFormat.UPPER);
field.update();

int index = 0;
Iterator&lt;Integer&gt; generalFormatEnumerator = format.getGeneralFormats().iterator();
while (generalFormatEnumerator.hasNext()) {
    int value = generalFormatEnumerator.next();
    System.out.println(MessageFormat.format("General format index {0}: {1}", index++, value));
}

Assert.assertEquals("= 25 + 33 \\* roman \\* Upper", field.getFieldCode());
Assert.assertEquals("LVIII", field.getResult());
Assert.assertEquals(2, format.getGeneralFormats().getCount());
Assert.assertEquals(GeneralFormat.LOWERCASE_ROMAN, format.getGeneralFormats().get(0));

// We can remove our formats to revert the field's result to its original form.
format.getGeneralFormats().remove(GeneralFormat.LOWERCASE_ROMAN);
format.getGeneralFormats().removeAt(0);
Assert.assertEquals(0, format.getGeneralFormats().getCount());
field.update();

Assert.assertEquals("= 25 + 33  ", field.getFieldCode());
Assert.assertEquals("58", field.getResult());
Assert.assertEquals(0, format.getGeneralFormats().getCount());</pre></example>
</DL>
<HR>

<A NAME="HasPageNumberSeparator"><!-- --></A><A NAME="hasPageNumberSeparator()"><!-- --></A><A NAME="hasPageNumberSeparator--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>hasPageNumberSeparator</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>hasPageNumberSeparator</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets a value indicating whether a page number separator is overridden through the field's code.
            </summary><example><p><b>Example:</b></p>Shows how to edit the page number separator in an INDEX field.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// The INDEX entry will group XE fields with matching values in the "Text" property
// into one entry as opposed to making an entry for each XE field.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);

// If our INDEX field has an entry for a group of XE fields,
// this entry will display the number of each page that contains an XE field that belongs to this group.
// We can set custom separators to customize the appearance of these page numbers.
index.setPageNumberSeparator(", on page(s) ");
index.setPageNumberListSeparator(" &amp; ");

Assert.assertEquals(" INDEX  \\e \", on page(s) \" \\l \" &amp; \"", index.getFieldCode());
Assert.assertTrue(index.hasPageNumberSeparator());

// After we insert these XE fields, the INDEX field will display "First entry, on page(s) 2 &amp; 3 &amp; 4".
builder.insertBreak(BreakType.PAGE_BREAK);
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("First entry");

Assert.assertEquals(" XE  \"First entry\"", indexEntry.getFieldCode());

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("First entry");

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("First entry");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.PageNumberList.docx");</pre></example>
</DL>
<HR>

<A NAME="HasSequenceName"><!-- --></A><A NAME="hasSequenceName()"><!-- --></A><A NAME="hasSequenceName--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>hasSequenceName</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>hasSequenceName</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets a value indicating whether a sequence should be used while the field's result building.
            </summary><example><p><b>Example:</b></p>Shows how to split a document into portions by combining INDEX and SEQ fields.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// If the XE fields have the same value in their "Text" property,
// the INDEX field will group them into one entry.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);

// In the SequenceName property, name a SEQ field sequence. Each entry of this INDEX field will now also display
// the number that the sequence count is on at the XE field location that created this entry.
index.setSequenceName("MySequence");

// Set text that will around the sequence and page numbers to explain their meaning to the user.
// An entry created with this configuration will display something like "MySequence at 1 on page 1" at its page number.
// PageNumberSeparator and SequenceSeparator cannot be longer than 15 characters.
index.setPageNumberSeparator("\tMySequence at ");
index.setSequenceSeparator(" on page ");
Assert.assertTrue(index.hasSequenceName());

Assert.assertEquals(" INDEX  \\s MySequence \\e \"\tMySequence at \" \\d \" on page \"", index.getFieldCode());

// SEQ fields display a count that increments at each SEQ field.
// These fields also maintain separate counts for each unique named sequence
// identified by the SEQ field's "SequenceIdentifier" property.
// Insert a SEQ field which moves the "MySequence" sequence to 1.
// This field no different from normal document text. It will not appear on an INDEX field's table of contents.
builder.insertBreak(BreakType.PAGE_BREAK);
FieldSeq sequenceField = (FieldSeq) builder.insertField(FieldType.FIELD_SEQUENCE, true);
sequenceField.setSequenceIdentifier("MySequence");

Assert.assertEquals(" SEQ  MySequence", sequenceField.getFieldCode());

// Insert an XE field which will create an entry in the INDEX field.
// Since "MySequence" is at 1 and this XE field is on page 2, along with the custom separators we defined above,
// this field's INDEX entry will display "Cat" on the left side, and "MySequence at 1 on page 2" on the right.
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Cat");

Assert.assertEquals(" XE  Cat", indexEntry.getFieldCode());

// Insert a page break, and use SEQ fields to advance "MySequence" to 3.
builder.insertBreak(BreakType.PAGE_BREAK);
sequenceField = (FieldSeq) builder.insertField(FieldType.FIELD_SEQUENCE, true);
sequenceField.setSequenceIdentifier("MySequence");
sequenceField = (FieldSeq) builder.insertField(FieldType.FIELD_SEQUENCE, true);
sequenceField.setSequenceIdentifier("MySequence");

// Insert an XE field with the same Text property as the one above.
// The INDEX entry will group XE fields with matching values in the "Text" property
// into one entry as opposed to making an entry for each XE field.
// Since we are on page 2 with "MySequence" at 3, ", 3 on page 3" will be appended to the same INDEX entry as above.
// The page number portion of that INDEX entry will now display "MySequence at 1 on page 2, 3 on page 3".
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Cat");

// Insert an XE field with a new and unique Text property value.
// This will add a new entry, with MySequence at 3 on page 4.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Dog");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.Sequence.docx");</pre></example>
</DL>
<HR>

<A NAME="Heading"><!-- --></A><A NAME="getHeading()"><!-- --></A><A NAME="getHeading--"><!-- --></A><A NAME="setHeading(java.lang.String)"><!-- --></A><A NAME="setHeading-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getHeading/setHeading</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getHeading</B>()&nbsp;/&nbsp;public void&nbsp;<B>setHeading</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a heading that appears at the start of each set of entries for any given letter.
            </summary><example><p><b>Example:</b></p>Shows how to populate an INDEX field with entries using XE fields, and also modify its appearance.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// If the XE fields have the same value in their "Text" property,
// the INDEX field will group them into one entry.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);
index.setLanguageId("1033");

// Setting this property's value to "A" will group all the entries by their first letter,
// and place that letter in uppercase above each group.
index.setHeading("A");

// Set the table created by the INDEX field to span over 2 columns.
index.setNumberOfColumns("2");

// Set any entries with starting letters outside the "a-c" character range to be omitted.
index.setLetterRange("a-c");

Assert.assertEquals(" INDEX  \\z 1033 \\h A \\c 2 \\p a-c", index.getFieldCode());

// These next two XE fields will show up under the "A" heading,
// with their respective text stylings also applied to their page numbers.
builder.insertBreak(BreakType.PAGE_BREAK);
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Apple");
indexEntry.isItalic(true);

Assert.assertEquals(" XE  Apple \\i", indexEntry.getFieldCode());

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Apricot");
indexEntry.isBold(true);

Assert.assertEquals(" XE  Apricot \\b", indexEntry.getFieldCode());

// Both the next two XE fields will be under a "B" and "C" heading in the INDEX fields table of contents.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Banana");

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Cherry");

// INDEX fields sort all entries alphabetically, so this entry will show up under "A" with the other two.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Avocado");

// This entry will not appear because it starts with the letter "D",
// which is outside the "a-c" character range that the INDEX field's LetterRange property defines.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Durian");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.Formatting.docx");</pre></example>
</DL>
<HR>

<A NAME="IsDirty"><!-- --></A><A NAME="isDirty()"><!-- --></A><A NAME="isDirty--"><!-- --></A><A NAME="isDirty(boolean)"><!-- --></A><A NAME="isDirty-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isDirty/isDirty</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isDirty</B>()&nbsp;/&nbsp;public void&nbsp;<B>isDirty</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets whether the current result of the field is no longer correct (stale) due to other modifications made to the document.
            </summary><example><p><b>Example:</b></p>Shows how to use special property for updating field result.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Give the document's built-in "Author" property value, and then display it with a field.
doc.getBuiltInDocumentProperties().setAuthor("John Doe");
FieldAuthor field = (FieldAuthor) builder.insertField(FieldType.FIELD_AUTHOR, true);

Assert.assertFalse(field.isDirty());
Assert.assertEquals("John Doe", field.getResult());

// Update the property. The field still displays the old value.
doc.getBuiltInDocumentProperties().setAuthor("John &amp; Jane Doe");

Assert.assertEquals("John Doe", field.getResult());

// Since the field's value is out of date, we can mark it as "dirty".
// This value will stay out of date until we update the field manually with the Field.Update() method.
field.isDirty(true);

// If we save without calling an update method,
// the field will keep displaying the out of date value in the output document.
doc.save(getArtifactsDir() + "Filed.UpdateDirtyFields.docx");

// The LoadOptions object has an option to update all fields
// marked as "dirty" when loading the document.
LoadOptions options = new LoadOptions();
options.setUpdateDirtyFields(updateDirtyFields);

doc = new Document(getArtifactsDir() + "Filed.UpdateDirtyFields.docx", options);

Assert.assertEquals("John &amp; Jane Doe", doc.getBuiltInDocumentProperties().getAuthor());

field = (FieldAuthor) doc.getRange().getFields().get(0);

// Updating dirty fields like this automatically set their "IsDirty" flag to false.
if (updateDirtyFields) {
    Assert.assertEquals("John &amp; Jane Doe", field.getResult());
    Assert.assertFalse(field.isDirty());
} else {
    Assert.assertEquals("John Doe", field.getResult());
    Assert.assertTrue(field.isDirty());
}</pre></example>
</DL>
<HR>

<A NAME="IsLocked"><!-- --></A><A NAME="isLocked()"><!-- --></A><A NAME="isLocked--"><!-- --></A><A NAME="isLocked(boolean)"><!-- --></A><A NAME="isLocked-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isLocked/isLocked</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isLocked</B>()&nbsp;/&nbsp;public void&nbsp;<B>isLocked</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets whether the field is locked (should not recalculate its result).
            </summary><example><p><b>Example:</b></p>Shows how to work with a FieldStart node.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

FieldDate field = (FieldDate) builder.insertField(FieldType.FIELD_DATE, true);
field.getFormat().setDateTimeFormat("dddd, MMMM dd, yyyy");
field.update();

FieldChar fieldStart = field.getStart();

Assert.assertEquals(FieldType.FIELD_DATE, fieldStart.getFieldType());
Assert.assertEquals(false, fieldStart.isDirty());
Assert.assertEquals(false, fieldStart.isLocked());

// Retrieve the facade object which represents the field in the document.
field = (FieldDate) fieldStart.getField();

Assert.assertEquals(false, field.isLocked());
Assert.assertEquals(" DATE  \\@ \"dddd, MMMM dd, yyyy\"", field.getFieldCode());

// Update the field to show the current date.
field.update();</pre></example>
</DL>
<HR>

<A NAME="LanguageId"><!-- --></A><A NAME="getLanguageId()"><!-- --></A><A NAME="getLanguageId--"><!-- --></A><A NAME="setLanguageId(java.lang.String)"><!-- --></A><A NAME="setLanguageId-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getLanguageId/setLanguageId</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getLanguageId</B>()&nbsp;/&nbsp;public void&nbsp;<B>setLanguageId</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the language ID used to generate the index.
            </summary><example><p><b>Example:</b></p>Shows how to populate an INDEX field with entries using XE fields, and also modify its appearance.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// If the XE fields have the same value in their "Text" property,
// the INDEX field will group them into one entry.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);
index.setLanguageId("1033");

// Setting this property's value to "A" will group all the entries by their first letter,
// and place that letter in uppercase above each group.
index.setHeading("A");

// Set the table created by the INDEX field to span over 2 columns.
index.setNumberOfColumns("2");

// Set any entries with starting letters outside the "a-c" character range to be omitted.
index.setLetterRange("a-c");

Assert.assertEquals(" INDEX  \\z 1033 \\h A \\c 2 \\p a-c", index.getFieldCode());

// These next two XE fields will show up under the "A" heading,
// with their respective text stylings also applied to their page numbers.
builder.insertBreak(BreakType.PAGE_BREAK);
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Apple");
indexEntry.isItalic(true);

Assert.assertEquals(" XE  Apple \\i", indexEntry.getFieldCode());

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Apricot");
indexEntry.isBold(true);

Assert.assertEquals(" XE  Apricot \\b", indexEntry.getFieldCode());

// Both the next two XE fields will be under a "B" and "C" heading in the INDEX fields table of contents.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Banana");

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Cherry");

// INDEX fields sort all entries alphabetically, so this entry will show up under "A" with the other two.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Avocado");

// This entry will not appear because it starts with the letter "D",
// which is outside the "a-c" character range that the INDEX field's LetterRange property defines.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Durian");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.Formatting.docx");</pre></example>
</DL>
<HR>

<A NAME="LetterRange"><!-- --></A><A NAME="getLetterRange()"><!-- --></A><A NAME="getLetterRange--"><!-- --></A><A NAME="setLetterRange(java.lang.String)"><!-- --></A><A NAME="setLetterRange-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getLetterRange/setLetterRange</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getLetterRange</B>()&nbsp;/&nbsp;public void&nbsp;<B>setLetterRange</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a range of letters to which limit the index.
            </summary><example><p><b>Example:</b></p>Shows how to populate an INDEX field with entries using XE fields, and also modify its appearance.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// If the XE fields have the same value in their "Text" property,
// the INDEX field will group them into one entry.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);
index.setLanguageId("1033");

// Setting this property's value to "A" will group all the entries by their first letter,
// and place that letter in uppercase above each group.
index.setHeading("A");

// Set the table created by the INDEX field to span over 2 columns.
index.setNumberOfColumns("2");

// Set any entries with starting letters outside the "a-c" character range to be omitted.
index.setLetterRange("a-c");

Assert.assertEquals(" INDEX  \\z 1033 \\h A \\c 2 \\p a-c", index.getFieldCode());

// These next two XE fields will show up under the "A" heading,
// with their respective text stylings also applied to their page numbers.
builder.insertBreak(BreakType.PAGE_BREAK);
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Apple");
indexEntry.isItalic(true);

Assert.assertEquals(" XE  Apple \\i", indexEntry.getFieldCode());

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Apricot");
indexEntry.isBold(true);

Assert.assertEquals(" XE  Apricot \\b", indexEntry.getFieldCode());

// Both the next two XE fields will be under a "B" and "C" heading in the INDEX fields table of contents.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Banana");

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Cherry");

// INDEX fields sort all entries alphabetically, so this entry will show up under "A" with the other two.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Avocado");

// This entry will not appear because it starts with the letter "D",
// which is outside the "a-c" character range that the INDEX field's LetterRange property defines.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Durian");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.Formatting.docx");</pre></example>
</DL>
<HR>

<A NAME="LocaleId"><!-- --></A><A NAME="getLocaleId()"><!-- --></A><A NAME="getLocaleId--"><!-- --></A><A NAME="setLocaleId(int)"><!-- --></A><A NAME="setLocaleId-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getLocaleId/setLocaleId</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getLocaleId</B>()&nbsp;/&nbsp;public void&nbsp;<B>setLocaleId</B>(int&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the LCID of the field.
            </summary><example><p><b>Example:</b></p>Shows how to insert a field and work with its locale.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Insert a DATE field, and then print the date it will display.
// Your thread's current culture determines the formatting of the date.
Field field = builder.insertField("DATE");
System.out.println(MessageFormat.format("Today''s date, as displayed in the \"{0}\" culture: {1}", Locale.getDefault().getDisplayLanguage(), field.getResult()));

Assert.assertEquals(1033, field.getLocaleId());
// Changing the culture of our thread will impact the result of the DATE field.
// Another way to get the DATE field to display a date in a different culture is to use its LocaleId property.
// This way allows us to avoid changing the thread's culture to get this effect.
doc.getFieldOptions().setFieldUpdateCultureSource(FieldUpdateCultureSource.FIELD_CODE);
CultureInfo de = new CultureInfo("de-DE");
field.setLocaleId(1031);
field.update();

System.out.println(MessageFormat.format("Today''s date, as displayed according to the \"{0}\" culture: {1}", Locale.forLanguageTag(LocaleUtil.getLocaleFromLCID(field.getLocaleId())).getDisplayLanguage(), field.getResult()));</pre></example><DL><DT><B>See Also:</B></DT><DD><cref seealso=""><A HREF="FieldUpdateCultureSource.html#FIELD_CODE" title="field in class com.aspose.words.FieldUpdateCultureSource">FieldUpdateCultureSource.FIELD_CODE</A></cref></DD></DL>
</DL>
<HR>

<A NAME="NumberOfColumns"><!-- --></A><A NAME="getNumberOfColumns()"><!-- --></A><A NAME="getNumberOfColumns--"><!-- --></A><A NAME="setNumberOfColumns(java.lang.String)"><!-- --></A><A NAME="setNumberOfColumns-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNumberOfColumns/setNumberOfColumns</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getNumberOfColumns</B>()&nbsp;/&nbsp;public void&nbsp;<B>setNumberOfColumns</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the number of columns per page used when building the index.
            </summary><example><p><b>Example:</b></p>Shows how to populate an INDEX field with entries using XE fields, and also modify its appearance.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// If the XE fields have the same value in their "Text" property,
// the INDEX field will group them into one entry.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);
index.setLanguageId("1033");

// Setting this property's value to "A" will group all the entries by their first letter,
// and place that letter in uppercase above each group.
index.setHeading("A");

// Set the table created by the INDEX field to span over 2 columns.
index.setNumberOfColumns("2");

// Set any entries with starting letters outside the "a-c" character range to be omitted.
index.setLetterRange("a-c");

Assert.assertEquals(" INDEX  \\z 1033 \\h A \\c 2 \\p a-c", index.getFieldCode());

// These next two XE fields will show up under the "A" heading,
// with their respective text stylings also applied to their page numbers.
builder.insertBreak(BreakType.PAGE_BREAK);
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Apple");
indexEntry.isItalic(true);

Assert.assertEquals(" XE  Apple \\i", indexEntry.getFieldCode());

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Apricot");
indexEntry.isBold(true);

Assert.assertEquals(" XE  Apricot \\b", indexEntry.getFieldCode());

// Both the next two XE fields will be under a "B" and "C" heading in the INDEX fields table of contents.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Banana");

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Cherry");

// INDEX fields sort all entries alphabetically, so this entry will show up under "A" with the other two.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Avocado");

// This entry will not appear because it starts with the letter "D",
// which is outside the "a-c" character range that the INDEX field's LetterRange property defines.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Durian");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.Formatting.docx");</pre></example>
</DL>
<HR>

<A NAME="PageNumberListSeparator"><!-- --></A><A NAME="getPageNumberListSeparator()"><!-- --></A><A NAME="getPageNumberListSeparator--"><!-- --></A><A NAME="setPageNumberListSeparator(java.lang.String)"><!-- --></A><A NAME="setPageNumberListSeparator-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPageNumberListSeparator/setPageNumberListSeparator</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getPageNumberListSeparator</B>()&nbsp;/&nbsp;public void&nbsp;<B>setPageNumberListSeparator</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the character sequence that is used to separate two page numbers in a page number list.
            </summary><example><p><b>Example:</b></p>Shows how to edit the page number separator in an INDEX field.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// The INDEX entry will group XE fields with matching values in the "Text" property
// into one entry as opposed to making an entry for each XE field.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);

// If our INDEX field has an entry for a group of XE fields,
// this entry will display the number of each page that contains an XE field that belongs to this group.
// We can set custom separators to customize the appearance of these page numbers.
index.setPageNumberSeparator(", on page(s) ");
index.setPageNumberListSeparator(" &amp; ");

Assert.assertEquals(" INDEX  \\e \", on page(s) \" \\l \" &amp; \"", index.getFieldCode());
Assert.assertTrue(index.hasPageNumberSeparator());

// After we insert these XE fields, the INDEX field will display "First entry, on page(s) 2 &amp; 3 &amp; 4".
builder.insertBreak(BreakType.PAGE_BREAK);
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("First entry");

Assert.assertEquals(" XE  \"First entry\"", indexEntry.getFieldCode());

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("First entry");

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("First entry");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.PageNumberList.docx");</pre></example>
</DL>
<HR>

<A NAME="PageNumberSeparator"><!-- --></A><A NAME="getPageNumberSeparator()"><!-- --></A><A NAME="getPageNumberSeparator--"><!-- --></A><A NAME="setPageNumberSeparator(java.lang.String)"><!-- --></A><A NAME="setPageNumberSeparator-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPageNumberSeparator/setPageNumberSeparator</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getPageNumberSeparator</B>()&nbsp;/&nbsp;public void&nbsp;<B>setPageNumberSeparator</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the character sequence that is used to separate an index entry and its page number.
            </summary><example><p><b>Example:</b></p>Shows how to edit the page number separator in an INDEX field.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// The INDEX entry will group XE fields with matching values in the "Text" property
// into one entry as opposed to making an entry for each XE field.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);

// If our INDEX field has an entry for a group of XE fields,
// this entry will display the number of each page that contains an XE field that belongs to this group.
// We can set custom separators to customize the appearance of these page numbers.
index.setPageNumberSeparator(", on page(s) ");
index.setPageNumberListSeparator(" &amp; ");

Assert.assertEquals(" INDEX  \\e \", on page(s) \" \\l \" &amp; \"", index.getFieldCode());
Assert.assertTrue(index.hasPageNumberSeparator());

// After we insert these XE fields, the INDEX field will display "First entry, on page(s) 2 &amp; 3 &amp; 4".
builder.insertBreak(BreakType.PAGE_BREAK);
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("First entry");

Assert.assertEquals(" XE  \"First entry\"", indexEntry.getFieldCode());

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("First entry");

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("First entry");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.PageNumberList.docx");</pre></example>
</DL>
<HR>

<A NAME="PageRangeSeparator"><!-- --></A><A NAME="getPageRangeSeparator()"><!-- --></A><A NAME="getPageRangeSeparator--"><!-- --></A><A NAME="setPageRangeSeparator(java.lang.String)"><!-- --></A><A NAME="setPageRangeSeparator-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPageRangeSeparator/setPageRangeSeparator</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getPageRangeSeparator</B>()&nbsp;/&nbsp;public void&nbsp;<B>setPageRangeSeparator</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the character sequence that is used to separate the start and end of a page range.
            </summary><example><p><b>Example:</b></p>Shows how to specify a bookmark's spanned pages as a page range for an INDEX field entry.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// The INDEX entry will collect all XE fields with matching values in the "Text" property
// into one entry as opposed to making an entry for each XE field.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);

// For INDEX entries that display page ranges, we can specify a separator string
// which will appear between the number of the first page, and the number of the last.
index.setPageNumberSeparator(", on page(s) ");
index.setPageRangeSeparator(" to ");

Assert.assertEquals(" INDEX  \\e \", on page(s) \" \\g \" to \"", index.getFieldCode());

builder.insertBreak(BreakType.PAGE_BREAK);
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("My entry");

// If an XE field names a bookmark using the PageRangeBookmarkName property,
// its INDEX entry will show the range of pages that the bookmark spans
// instead of the number of the page that contains the XE field.
indexEntry.setPageRangeBookmarkName("MyBookmark");

Assert.assertEquals(" XE  \"My entry\" \\r MyBookmark", indexEntry.getFieldCode());
Assert.assertEquals(indexEntry.getPageRangeBookmarkName(), "MyBookmark");

// Insert a bookmark that starts on page 3 and ends on page 5.
// The INDEX entry for the XE field that references this bookmark will display this page range.
// In our table, the INDEX entry will display "My entry, on page(s) 3 to 5".
builder.insertBreak(BreakType.PAGE_BREAK);
builder.startBookmark("MyBookmark");
builder.write("Start of MyBookmark");
builder.insertBreak(BreakType.PAGE_BREAK);
builder.insertBreak(BreakType.PAGE_BREAK);
builder.write("End of MyBookmark");
builder.endBookmark("MyBookmark");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.PageRangeBookmark.docx");</pre></example>
</DL>
<HR>

<A NAME="Result"><!-- --></A><A NAME="getResult()"><!-- --></A><A NAME="getResult--"><!-- --></A><A NAME="setResult(java.lang.String)"><!-- --></A><A NAME="setResult-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getResult/setResult</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getResult</B>()&nbsp;/&nbsp;public void&nbsp;<B>setResult</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets text that is between the field separator and field end.
            </summary><example><p><b>Example:</b></p>Shows how to insert a field into a document using a field code.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

Field dateField = builder.insertField("DATE \\* MERGEFORMAT");

Assert.assertEquals(FieldType.FIELD_DATE, dateField.getType());
Assert.assertEquals("DATE \\* MERGEFORMAT", dateField.getFieldCode());</pre></example>
</DL>
<HR>

<A NAME="RunSubentriesOnSameLine"><!-- --></A><A NAME="getRunSubentriesOnSameLine()"><!-- --></A><A NAME="getRunSubentriesOnSameLine--"><!-- --></A><A NAME="setRunSubentriesOnSameLine(boolean)"><!-- --></A><A NAME="setRunSubentriesOnSameLine-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRunSubentriesOnSameLine/setRunSubentriesOnSameLine</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getRunSubentriesOnSameLine</B>()&nbsp;/&nbsp;public void&nbsp;<B>setRunSubentriesOnSameLine</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets whether run subentries into the same line as the main entry.
            </summary><example><p><b>Example:</b></p>Shows how to work with subentries in an INDEX field.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// The INDEX entry will collect all XE fields with matching values in the "Text" property
// into one entry as opposed to making an entry for each XE field.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);
index.setPageNumberSeparator(", see page ");
index.setHeading("A");

// XE fields that have a Text property whose value becomes the heading of the INDEX entry.
// If this value contains two string segments split by a colon (the INDEX entry will treat :) delimiter,
// the first segment is heading, and the second segment will become the subheading.
// The INDEX field first groups entries alphabetically, then, if there are multiple XE fields with the same
// headings, the INDEX field will further subgroup them by the values of these headings.
// There can be multiple subgrouping layers, depending on how many times
// the Text properties of XE fields get segmented like this.
// By default, an INDEX field entry group will create a new line for every subheading within this group. 
// We can set the RunSubentriesOnSameLine flag to true to keep the heading,
// and every subheading for the group on one line instead, which will make the INDEX field more compact.
index.setRunSubentriesOnSameLine(runSubentriesOnTheSameLine);

if (runSubentriesOnTheSameLine)
    Assert.assertEquals(" INDEX  \\e \", see page \" \\h A \\r", index.getFieldCode());
else
    Assert.assertEquals(" INDEX  \\e \", see page \" \\h A", index.getFieldCode());

// Insert two XE fields, each on a new page, and with the same heading named "Heading 1",
// which the INDEX field will use to group them.
// If RunSubentriesOnSameLine is false, then the INDEX table will create three lines:
// one line for the grouping heading "Heading 1", and one more line for each subheading.
// If RunSubentriesOnSameLine is true, then the INDEX table will create a one-line
// entry that encompasses the heading and every subheading.
builder.insertBreak(BreakType.PAGE_BREAK);
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Heading 1:Subheading 1");

Assert.assertEquals(" XE  \"Heading 1:Subheading 1\"", indexEntry.getFieldCode());

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Heading 1:Subheading 2");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.Subheading.docx");</pre></example>
</DL>
<HR>

<A NAME="Separator"><!-- --></A><A NAME="getSeparator()"><!-- --></A><A NAME="getSeparator--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getSeparator</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="FieldSeparator.html" title="class in com.aspose.words">FieldSeparator</A>&nbsp;<B>getSeparator</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node that represents the field separator. Can be <code>null</code>.
            </summary><example><p><b>Example:</b></p>Shows how to work with a collection of fields.<pre>
public void fieldCollection() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    builder.insertField(" DATE \\@ \"dddd, d MMMM yyyy\" ");
    builder.insertField(" TIME ");
    builder.insertField(" REVNUM ");
    builder.insertField(" AUTHOR  \"John Doe\" ");
    builder.insertField(" SUBJECT \"My Subject\" ");
    builder.insertField(" QUOTE \"Hello world!\" ");
    doc.updateFields();

    FieldCollection fields = doc.getRange().getFields();

    Assert.assertEquals(6, fields.getCount());

    // Iterate over the field collection, and print contents and type
    // of every field using a custom visitor implementation.
    FieldVisitor fieldVisitor = new FieldVisitor();

    Iterator&lt;Field&gt; fieldEnumerator = fields.iterator();

    while (fieldEnumerator.hasNext()) {
        if (fieldEnumerator != null) {
            Field currentField = fieldEnumerator.next();

            currentField.getStart().accept(fieldVisitor);
            if (currentField.getSeparator() != null) {
                currentField.getSeparator().accept(fieldVisitor);
            }
            currentField.getEnd().accept(fieldVisitor);
        } else {
            System.out.println("There are no fields in the document.");
        }
    }

    System.out.println(fieldVisitor.getText());
}

/// &lt;summary&gt;
/// Document visitor implementation that prints field info.
/// &lt;/summary&gt;
public static class FieldVisitor extends DocumentVisitor {
    public FieldVisitor() {
        mBuilder = new StringBuilder();
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(final FieldStart fieldStart) {
        mBuilder.append("Found field: " + fieldStart.getFieldType() + "\r\n");
        mBuilder.append("\tField code: " + fieldStart.getField().getFieldCode() + "\r\n");
        mBuilder.append("\tDisplayed as: " + fieldStart.getField().getResult() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(final FieldSeparator fieldSeparator) {
        mBuilder.append("\tFound separator: " + fieldSeparator.getText() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(final FieldEnd fieldEnd) {
        mBuilder.append("End of field: " + fieldEnd.getFieldType() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    private final /*final*/ StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="SequenceName"><!-- --></A><A NAME="getSequenceName()"><!-- --></A><A NAME="getSequenceName--"><!-- --></A><A NAME="setSequenceName(java.lang.String)"><!-- --></A><A NAME="setSequenceName-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getSequenceName/setSequenceName</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getSequenceName</B>()&nbsp;/&nbsp;public void&nbsp;<B>setSequenceName</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the name of a sequence whose number is included with the page number.
            </summary><example><p><b>Example:</b></p>Shows how to split a document into portions by combining INDEX and SEQ fields.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// If the XE fields have the same value in their "Text" property,
// the INDEX field will group them into one entry.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);

// In the SequenceName property, name a SEQ field sequence. Each entry of this INDEX field will now also display
// the number that the sequence count is on at the XE field location that created this entry.
index.setSequenceName("MySequence");

// Set text that will around the sequence and page numbers to explain their meaning to the user.
// An entry created with this configuration will display something like "MySequence at 1 on page 1" at its page number.
// PageNumberSeparator and SequenceSeparator cannot be longer than 15 characters.
index.setPageNumberSeparator("\tMySequence at ");
index.setSequenceSeparator(" on page ");
Assert.assertTrue(index.hasSequenceName());

Assert.assertEquals(" INDEX  \\s MySequence \\e \"\tMySequence at \" \\d \" on page \"", index.getFieldCode());

// SEQ fields display a count that increments at each SEQ field.
// These fields also maintain separate counts for each unique named sequence
// identified by the SEQ field's "SequenceIdentifier" property.
// Insert a SEQ field which moves the "MySequence" sequence to 1.
// This field no different from normal document text. It will not appear on an INDEX field's table of contents.
builder.insertBreak(BreakType.PAGE_BREAK);
FieldSeq sequenceField = (FieldSeq) builder.insertField(FieldType.FIELD_SEQUENCE, true);
sequenceField.setSequenceIdentifier("MySequence");

Assert.assertEquals(" SEQ  MySequence", sequenceField.getFieldCode());

// Insert an XE field which will create an entry in the INDEX field.
// Since "MySequence" is at 1 and this XE field is on page 2, along with the custom separators we defined above,
// this field's INDEX entry will display "Cat" on the left side, and "MySequence at 1 on page 2" on the right.
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Cat");

Assert.assertEquals(" XE  Cat", indexEntry.getFieldCode());

// Insert a page break, and use SEQ fields to advance "MySequence" to 3.
builder.insertBreak(BreakType.PAGE_BREAK);
sequenceField = (FieldSeq) builder.insertField(FieldType.FIELD_SEQUENCE, true);
sequenceField.setSequenceIdentifier("MySequence");
sequenceField = (FieldSeq) builder.insertField(FieldType.FIELD_SEQUENCE, true);
sequenceField.setSequenceIdentifier("MySequence");

// Insert an XE field with the same Text property as the one above.
// The INDEX entry will group XE fields with matching values in the "Text" property
// into one entry as opposed to making an entry for each XE field.
// Since we are on page 2 with "MySequence" at 3, ", 3 on page 3" will be appended to the same INDEX entry as above.
// The page number portion of that INDEX entry will now display "MySequence at 1 on page 2, 3 on page 3".
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Cat");

// Insert an XE field with a new and unique Text property value.
// This will add a new entry, with MySequence at 3 on page 4.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Dog");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.Sequence.docx");</pre></example>
</DL>
<HR>

<A NAME="SequenceSeparator"><!-- --></A><A NAME="getSequenceSeparator()"><!-- --></A><A NAME="getSequenceSeparator--"><!-- --></A><A NAME="setSequenceSeparator(java.lang.String)"><!-- --></A><A NAME="setSequenceSeparator-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getSequenceSeparator/setSequenceSeparator</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getSequenceSeparator</B>()&nbsp;/&nbsp;public void&nbsp;<B>setSequenceSeparator</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the character sequence that is used to separate sequence numbers and page numbers.
            </summary><example><p><b>Example:</b></p>Shows how to split a document into portions by combining INDEX and SEQ fields.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// If the XE fields have the same value in their "Text" property,
// the INDEX field will group them into one entry.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);

// In the SequenceName property, name a SEQ field sequence. Each entry of this INDEX field will now also display
// the number that the sequence count is on at the XE field location that created this entry.
index.setSequenceName("MySequence");

// Set text that will around the sequence and page numbers to explain their meaning to the user.
// An entry created with this configuration will display something like "MySequence at 1 on page 1" at its page number.
// PageNumberSeparator and SequenceSeparator cannot be longer than 15 characters.
index.setPageNumberSeparator("\tMySequence at ");
index.setSequenceSeparator(" on page ");
Assert.assertTrue(index.hasSequenceName());

Assert.assertEquals(" INDEX  \\s MySequence \\e \"\tMySequence at \" \\d \" on page \"", index.getFieldCode());

// SEQ fields display a count that increments at each SEQ field.
// These fields also maintain separate counts for each unique named sequence
// identified by the SEQ field's "SequenceIdentifier" property.
// Insert a SEQ field which moves the "MySequence" sequence to 1.
// This field no different from normal document text. It will not appear on an INDEX field's table of contents.
builder.insertBreak(BreakType.PAGE_BREAK);
FieldSeq sequenceField = (FieldSeq) builder.insertField(FieldType.FIELD_SEQUENCE, true);
sequenceField.setSequenceIdentifier("MySequence");

Assert.assertEquals(" SEQ  MySequence", sequenceField.getFieldCode());

// Insert an XE field which will create an entry in the INDEX field.
// Since "MySequence" is at 1 and this XE field is on page 2, along with the custom separators we defined above,
// this field's INDEX entry will display "Cat" on the left side, and "MySequence at 1 on page 2" on the right.
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Cat");

Assert.assertEquals(" XE  Cat", indexEntry.getFieldCode());

// Insert a page break, and use SEQ fields to advance "MySequence" to 3.
builder.insertBreak(BreakType.PAGE_BREAK);
sequenceField = (FieldSeq) builder.insertField(FieldType.FIELD_SEQUENCE, true);
sequenceField.setSequenceIdentifier("MySequence");
sequenceField = (FieldSeq) builder.insertField(FieldType.FIELD_SEQUENCE, true);
sequenceField.setSequenceIdentifier("MySequence");

// Insert an XE field with the same Text property as the one above.
// The INDEX entry will group XE fields with matching values in the "Text" property
// into one entry as opposed to making an entry for each XE field.
// Since we are on page 2 with "MySequence" at 3, ", 3 on page 3" will be appended to the same INDEX entry as above.
// The page number portion of that INDEX entry will now display "MySequence at 1 on page 2, 3 on page 3".
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Cat");

// Insert an XE field with a new and unique Text property value.
// This will add a new entry, with MySequence at 3 on page 4.
builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("Dog");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.Sequence.docx");</pre></example>
</DL>
<HR>

<A NAME="Start"><!-- --></A><A NAME="getStart()"><!-- --></A><A NAME="getStart--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getStart</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="FieldStart.html" title="class in com.aspose.words">FieldStart</A>&nbsp;<B>getStart</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node that represents the start of the field.
            </summary><example><p><b>Example:</b></p>Shows how to work with a collection of fields.<pre>
public void fieldCollection() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    builder.insertField(" DATE \\@ \"dddd, d MMMM yyyy\" ");
    builder.insertField(" TIME ");
    builder.insertField(" REVNUM ");
    builder.insertField(" AUTHOR  \"John Doe\" ");
    builder.insertField(" SUBJECT \"My Subject\" ");
    builder.insertField(" QUOTE \"Hello world!\" ");
    doc.updateFields();

    FieldCollection fields = doc.getRange().getFields();

    Assert.assertEquals(6, fields.getCount());

    // Iterate over the field collection, and print contents and type
    // of every field using a custom visitor implementation.
    FieldVisitor fieldVisitor = new FieldVisitor();

    Iterator&lt;Field&gt; fieldEnumerator = fields.iterator();

    while (fieldEnumerator.hasNext()) {
        if (fieldEnumerator != null) {
            Field currentField = fieldEnumerator.next();

            currentField.getStart().accept(fieldVisitor);
            if (currentField.getSeparator() != null) {
                currentField.getSeparator().accept(fieldVisitor);
            }
            currentField.getEnd().accept(fieldVisitor);
        } else {
            System.out.println("There are no fields in the document.");
        }
    }

    System.out.println(fieldVisitor.getText());
}

/// &lt;summary&gt;
/// Document visitor implementation that prints field info.
/// &lt;/summary&gt;
public static class FieldVisitor extends DocumentVisitor {
    public FieldVisitor() {
        mBuilder = new StringBuilder();
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(final FieldStart fieldStart) {
        mBuilder.append("Found field: " + fieldStart.getFieldType() + "\r\n");
        mBuilder.append("\tField code: " + fieldStart.getField().getFieldCode() + "\r\n");
        mBuilder.append("\tDisplayed as: " + fieldStart.getField().getResult() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(final FieldSeparator fieldSeparator) {
        mBuilder.append("\tFound separator: " + fieldSeparator.getText() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(final FieldEnd fieldEnd) {
        mBuilder.append("End of field: " + fieldEnd.getFieldType() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    private final /*final*/ StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="Type"><!-- --></A><A NAME="getType()"><!-- --></A><A NAME="getType--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getType</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getType</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the Microsoft Word field type.
            The value of the property is <A HREF="FieldType.html" title="Utility class in com.aspose.words">FieldType</A> integer constant.</summary><example><p><b>Example:</b></p>Shows how to insert a field into a document using a field code.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

Field dateField = builder.insertField("DATE \\* MERGEFORMAT");

Assert.assertEquals(FieldType.FIELD_DATE, dateField.getType());
Assert.assertEquals("DATE \\* MERGEFORMAT", dateField.getFieldCode());</pre></example>
</DL>
<HR>

<A NAME="UseYomi"><!-- --></A><A NAME="getUseYomi()"><!-- --></A><A NAME="getUseYomi--"><!-- --></A><A NAME="setUseYomi(boolean)"><!-- --></A><A NAME="setUseYomi-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getUseYomi/setUseYomi</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getUseYomi</B>()&nbsp;/&nbsp;public void&nbsp;<B>setUseYomi</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets whether to enable the use of yomi text for index entries.
            </summary><example><p><b>Example:</b></p>Shows how to sort INDEX field entries phonetically.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create an INDEX field which will display an entry for each XE field found in the document.
// Each entry will display the XE field's Text property value on the left side,
// and the number of the page that contains the XE field on the right.
// The INDEX entry will collect all XE fields with matching values in the "Text" property
// into one entry as opposed to making an entry for each XE field.
FieldIndex index = (FieldIndex) builder.insertField(FieldType.FIELD_INDEX, true);

// The INDEX table automatically sorts its entries by the values of their Text properties in alphabetic order.
// Set the INDEX table to sort entries phonetically using Hiragana instead.
index.setUseYomi(sortEntriesUsingYomi);

if (sortEntriesUsingYomi)
    Assert.assertEquals(" INDEX  \\y", index.getFieldCode());
else
    Assert.assertEquals(" INDEX ", index.getFieldCode());

// Insert 4 XE fields, which would show up as entries in the INDEX field's table of contents.
// The "Text" property may contain a word's spelling in Kanji, whose pronunciation may be ambiguous,
// while the "Yomi" version of the word will spell exactly how it is pronounced using Hiragana.
// If we set our INDEX field to use Yomi, it will sort these entries
// by the value of their Yomi properties, instead of their Text values.
builder.insertBreak(BreakType.PAGE_BREAK);
FieldXE indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("愛子");
indexEntry.setYomi("あ");

Assert.assertEquals(" XE  愛子 \\y あ", indexEntry.getFieldCode());

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("明美");
indexEntry.setYomi("あ");

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("恵美");
indexEntry.setYomi("え");

builder.insertBreak(BreakType.PAGE_BREAK);
indexEntry = (FieldXE) builder.insertField(FieldType.FIELD_INDEX_ENTRY, true);
indexEntry.setText("愛美");
indexEntry.setYomi("え");

doc.updatePageLayout();
doc.updateFields();
doc.save(getArtifactsDir() + "Field.INDEX.XE.Yomi.docx");</pre></example>
</DL>
<HR>



<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getFieldCode()"><!-- --></A><A NAME="getFieldCode--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFieldCode</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getFieldCode</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns text between field start and field separator (or field end if there is no separator).
            Both field code and field result of child fields are included.
            </summary><example><p><b>Example:</b></p>Shows how to get a field's field code.<pre>
// Open a document which contains a MERGEFIELD inside an IF field.
Document doc = new Document(getMyDir() + "Nested fields.docx");
FieldIf fieldIf = (FieldIf) doc.getRange().getFields().get(0);

// There are two ways of getting a field's field code:
// 1 -  Omit its inner fields:
Assert.assertEquals(" IF  &gt; 0 \" (surplus of ) \" \"\" ", fieldIf.getFieldCode(false));

// 2 -  Include its inner fields:
Assert.assertEquals(" IF \u0013 MERGEFIELD NetIncome \u0014\u0015 &gt; 0 \" (surplus of \u0013 MERGEFIELD  NetIncome \\f $ \u0014\u0015) \" \"\" ",
        fieldIf.getFieldCode(true));

// By default, the GetFieldCode method displays inner fields.
Assert.assertEquals(fieldIf.getFieldCode(), fieldIf.getFieldCode(true));</pre></example><example><p><b>Example:</b></p>Shows how to insert a field into a document using a field code.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

Field dateField = builder.insertField("DATE \\* MERGEFORMAT");

Assert.assertEquals(FieldType.FIELD_DATE, dateField.getType());
Assert.assertEquals("DATE \\* MERGEFORMAT", dateField.getFieldCode());</pre></example>
</DL>
<HR>

<A NAME="getFieldCode(boolean)"><!-- --></A><A NAME="getFieldCode-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFieldCode</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getFieldCode</B>(boolean&nbsp;includeChildFieldCodes)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns text between field start and field separator (or field end if there is no separator).
            </summary><DL><DT><B>Parameters:</B></DT><DD param="includeChildFieldCodes"><CODE>includeChildFieldCodes</CODE> - <code>true</code> if child field codes should be included.
            </DD></DL><example><p><b>Example:</b></p>Shows how to get a field's field code.<pre>
// Open a document which contains a MERGEFIELD inside an IF field.
Document doc = new Document(getMyDir() + "Nested fields.docx");
FieldIf fieldIf = (FieldIf) doc.getRange().getFields().get(0);

// There are two ways of getting a field's field code:
// 1 -  Omit its inner fields:
Assert.assertEquals(" IF  &gt; 0 \" (surplus of ) \" \"\" ", fieldIf.getFieldCode(false));

// 2 -  Include its inner fields:
Assert.assertEquals(" IF \u0013 MERGEFIELD NetIncome \u0014\u0015 &gt; 0 \" (surplus of \u0013 MERGEFIELD  NetIncome \\f $ \u0014\u0015) \" \"\" ",
        fieldIf.getFieldCode(true));

// By default, the GetFieldCode method displays inner fields.
Assert.assertEquals(fieldIf.getFieldCode(), fieldIf.getFieldCode(true));</pre></example>
</DL>
<HR>

<A NAME="remove()"><!-- --></A><A NAME="remove--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>remove</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>remove</B>()
           throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes the field from the document. Returns a node right after the field. If the field's end is the last child
            of its parent node, returns its parent paragraph. If the field is already removed, returns <code>null</code>.
            </summary><example><p><b>Example:</b></p>Shows how to process PRIVATE fields.<pre>
public void fieldPrivate() throws Exception {
    // Open a Corel WordPerfect document which we have converted to .docx format.
    Document doc = new Document(getMyDir() + "Field sample - PRIVATE.docx");

    // WordPerfect 5.x/6.x documents like the one we have loaded may contain PRIVATE fields.
    // Microsoft Word preserves PRIVATE fields during load/save operations,
    // but provides no functionality for them.
    FieldPrivate field = (FieldPrivate) doc.getRange().getFields().get(0);

    Assert.assertEquals(" PRIVATE \"My value\" ", field.getFieldCode());
    Assert.assertEquals(FieldType.FIELD_PRIVATE, field.getType());

    // We can also insert PRIVATE fields using a document builder.
    DocumentBuilder builder = new DocumentBuilder(doc);
    builder.insertField(FieldType.FIELD_PRIVATE, true);

    // These fields are not a viable way of protecting sensitive information.
    // Unless backward compatibility with older versions of WordPerfect is essential,
    // we can safely remove these fields. We can do this using a DocumentVisiitor implementation.
    Assert.assertEquals(2, doc.getRange().getFields().getCount());

    FieldPrivateRemover remover = new FieldPrivateRemover();
    doc.accept(remover);

    Assert.assertEquals(remover.getFieldsRemovedCount(), 2);
    Assert.assertEquals(doc.getRange().getFields().getCount(), 0);
}

/// &lt;summary&gt;
/// Removes all encountered PRIVATE fields.
/// &lt;/summary&gt;
public static class FieldPrivateRemover extends DocumentVisitor {
    public FieldPrivateRemover() {
        mFieldsRemovedCount = 0;
    }

    public int getFieldsRemovedCount() {
        return mFieldsRemovedCount;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// If the node belongs to a PRIVATE field, the entire field is removed.
    /// &lt;/summary&gt;
    public int visitFieldEnd(final FieldEnd fieldEnd) throws Exception {
        if (fieldEnd.getFieldType() == FieldType.FIELD_PRIVATE) {
            fieldEnd.getField().remove();
            mFieldsRemovedCount++;
        }

        return VisitorAction.CONTINUE;
    }

    private int mFieldsRemovedCount;
}</pre></example><example><p><b>Example:</b></p>Shows how to remove fields from a field collection.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.insertField(" DATE \\@ \"dddd, d MMMM yyyy\" ");
builder.insertField(" TIME ");
builder.insertField(" REVNUM ");
builder.insertField(" AUTHOR  \"John Doe\" ");
builder.insertField(" SUBJECT \"My Subject\" ");
builder.insertField(" QUOTE \"Hello world!\" ");
doc.updateFields();

FieldCollection fields = doc.getRange().getFields();

Assert.assertEquals(6, fields.getCount());

// Below are four ways of removing fields from a field collection.
// 1 -  Get a field to remove itself:
fields.get(0).remove();
Assert.assertEquals(5, fields.getCount());

// 2 -  Get the collection to remove a field that we pass to its removal method:
Field lastField = fields.get(3);
fields.remove(lastField);
Assert.assertEquals(4, fields.getCount());

// 3 -  Remove a field from a collection at an index:
fields.removeAt(2);
Assert.assertEquals(3, fields.getCount());

// 4 -  Remove all the fields from the collection at once:
fields.clear();
Assert.assertEquals(0, fields.getCount());</pre></example>
</DL>
<HR>

<A NAME="unlink()"><!-- --></A><A NAME="unlink--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>unlink</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>unlink</B>()
              throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Performs the field unlink.
            </summary><remarks><p>Replaces the field with its most recent result.</p><p>Some fields, such as XE (Index Entry) fields and SEQ (Sequence) fields, cannot be unlinked.</p></remarks><DL><DT><B>Returns:</B></DT><DD returns=""><code>true</code> if the field has been unlinked, otherwise <code>false</code>.
            </DD></DL><example><p><b>Example:</b></p>Shows how to unlink a field.<pre>
Document doc = new Document(getMyDir() + "Linked fields.docx");
doc.getRange().getFields().get(1).unlink();</pre></example>
</DL>
<HR>

<A NAME="update()"><!-- --></A><A NAME="update--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>update</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>update</B>()
           throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Performs the field update. Throws if the field is being updated already.
            </summary><example><p><b>Example:</b></p>Shows how to format field results.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Use a document builder to insert a field that displays a result with no format applied.
Field field = builder.insertField("= 2 + 3");

Assert.assertEquals("= 2 + 3", field.getFieldCode());
Assert.assertEquals("5", field.getResult());

// We can apply a format to a field's result using the field's properties.
// Below are three types of formats that we can apply to a field's result.
// 1 -  Numeric format:
FieldFormat format = field.getFormat();
format.setNumericFormat("$###.00");
field.update();

Assert.assertEquals("= 2 + 3 \\# $###.00", field.getFieldCode());
Assert.assertEquals("$  5.00", field.getResult());

// 2 -  Date/time format:
field = builder.insertField("DATE");
format = field.getFormat();
format.setDateTimeFormat("dddd, MMMM dd, yyyy");
field.update();

Assert.assertEquals("DATE \\@ \"dddd, MMMM dd, yyyy\"", field.getFieldCode());
System.out.println("Today's date, in {format.DateTimeFormat} format:\n\t{field.Result}");

// 3 -  General format:
field = builder.insertField("= 25 + 33");
format = field.getFormat();
format.getGeneralFormats().add(GeneralFormat.LOWERCASE_ROMAN);
format.getGeneralFormats().add(GeneralFormat.UPPER);
field.update();

int index = 0;
Iterator&lt;Integer&gt; generalFormatEnumerator = format.getGeneralFormats().iterator();
while (generalFormatEnumerator.hasNext()) {
    int value = generalFormatEnumerator.next();
    System.out.println(MessageFormat.format("General format index {0}: {1}", index++, value));
}

Assert.assertEquals("= 25 + 33 \\* roman \\* Upper", field.getFieldCode());
Assert.assertEquals("LVIII", field.getResult());
Assert.assertEquals(2, format.getGeneralFormats().getCount());
Assert.assertEquals(GeneralFormat.LOWERCASE_ROMAN, format.getGeneralFormats().get(0));

// We can remove our formats to revert the field's result to its original form.
format.getGeneralFormats().remove(GeneralFormat.LOWERCASE_ROMAN);
format.getGeneralFormats().removeAt(0);
Assert.assertEquals(0, format.getGeneralFormats().getCount());
field.update();

Assert.assertEquals("= 25 + 33  ", field.getFieldCode());
Assert.assertEquals("58", field.getResult());
Assert.assertEquals(0, format.getGeneralFormats().getCount());</pre></example><example><p><b>Example:</b></p>Shows how to insert a field into a document using FieldType.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Insert two fields while passing a flag which determines whether to update them as the builder inserts them.
// In some cases, updating fields could be computationally expensive, and it may be a good idea to defer the update.
doc.getBuiltInDocumentProperties().setAuthor("John Doe");
builder.write("This document was written by ");
builder.insertField(FieldType.FIELD_AUTHOR, updateInsertedFieldsImmediately);

builder.insertParagraph();
builder.write("\nThis is page ");
builder.insertField(FieldType.FIELD_PAGE, updateInsertedFieldsImmediately);

Assert.assertEquals(" AUTHOR ", doc.getRange().getFields().get(0).getFieldCode());
Assert.assertEquals(" PAGE ", doc.getRange().getFields().get(1).getFieldCode());

if (updateInsertedFieldsImmediately) {
    Assert.assertEquals("John Doe", doc.getRange().getFields().get(0).getResult());
    Assert.assertEquals("1", doc.getRange().getFields().get(1).getResult());
} else {
    Assert.assertEquals("", doc.getRange().getFields().get(0).getResult());
    Assert.assertEquals("", doc.getRange().getFields().get(1).getResult());

    // We will need to update these fields using the update methods manually.
    doc.getRange().getFields().get(0).update();

    Assert.assertEquals("John Doe", doc.getRange().getFields().get(0).getResult());

    doc.updateFields();

    Assert.assertEquals("1", doc.getRange().getFields().get(1).getResult());
}</pre></example>
</DL>
<HR>

<A NAME="update(boolean)"><!-- --></A><A NAME="update-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>update</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Field.html" title="class in com.aspose.words">Field</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>update</B>(boolean&nbsp;ignoreMergeFormat)
           throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Performs a field update. Throws if the field is being updated already.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="ignoreMergeFormat"><CODE>ignoreMergeFormat</CODE> - 
            If <code>true</code> then direct field result formatting is abandoned, regardless of the MERGEFORMAT switch, otherwise normal update is performed.
            </DD></DL><example><p><b>Example:</b></p>Shows how to preserve or discard INCLUDEPICTURE fields when loading a document.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

FieldIncludePicture includePicture = (FieldIncludePicture) builder.insertField(FieldType.FIELD_INCLUDE_PICTURE, true);
includePicture.setSourceFullName(getImageDir() + "Transparent background logo.png");
includePicture.update(true);

try (ByteArrayOutputStream docStream = new ByteArrayOutputStream()) {
    doc.save(docStream, new OoxmlSaveOptions(SaveFormat.DOCX));

    // We can set a flag in a LoadOptions object to decide whether to convert all INCLUDEPICTURE fields
    // into image shapes when loading a document that contains them.
    LoadOptions loadOptions = new LoadOptions();
    {
        loadOptions.setPreserveIncludePictureField(preserveIncludePictureField);
    }

    doc = new Document(new ByteArrayInputStream(docStream.toByteArray()), loadOptions);
    FieldCollection fieldCollection = doc.getRange().getFields();

    if (preserveIncludePictureField) {
        Assert.assertTrue(IterableUtils.matchesAny(fieldCollection, f -&gt; f.getType() == FieldType.FIELD_INCLUDE_PICTURE));

        doc.updateFields();
        doc.save(getArtifactsDir() + "Field.PreserveIncludePicture.docx");
    } else {
        Assert.assertFalse(IterableUtils.matchesAny(fieldCollection, f -&gt; f.getType() == FieldType.FIELD_INCLUDE_PICTURE));
    }
}</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>