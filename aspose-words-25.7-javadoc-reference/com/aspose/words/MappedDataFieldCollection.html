<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 19 Jul 2025 -->
<TITLE>MappedDataFieldCollection</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class MappedDataFieldCollection</H2>
<PRE>
java.lang.Object
    <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.MappedDataFieldCollection</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Iterable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>MappedDataFieldCollection </B><DT>extends java.lang.Object</DL>
</PRE>

<P>

<summary>
             Allows to automatically map between names of fields in your data source
             and names of mail merge fields in the document.
             <p>To learn more, visit the <a href="https://docs.aspose.com/words/net/mail-merge-and-reporting/">Mail Merge and Reporting</a> documentation article.</p></summary><remarks><p>This is implemented as a collection of string keys into string values.
             The keys are the names of mail merge fields in the document and the values
             are the names of fields in your data source.</p></remarks><example><p><b>Example:</b></p>Shows how to map data columns and MERGEFIELDs with different names so the data is transferred between them during a mail merge.<pre>
public void mappedDataFieldCollection() throws Exception {
    // Create a document and table that we will merge
    Document doc = createSourceDocMappedDataFields();
    DataTable dataTable = createSourceTableMappedDataFields();

    // We have a column "Column2" in the data table that doesn't have a respective MERGEFIELD in the document
    // Also, we have a MERGEFIELD named "Column3" that does not exist as a column in the data source
    // If data from "Column2" is suitable for the "Column3" MERGEFIELD,
    // we can map that column name to the MERGEFIELD in the "MappedDataFields" key/value pair
    MappedDataFieldCollection mappedDataFields = doc.getMailMerge().getMappedDataFields();

    // A data source column name is linked to a MERGEFIELD name by adding an element like this
    mappedDataFields.add("MergeFieldName", "DataSourceColumnName");

    // So, values from "Column2" will now go into MERGEFIELDs named "Column3" as well as "Column2", if there are any
    mappedDataFields.add("Column3", "Column2");

    // The MERGEFIELD name is the "key" to the respective data source column name "value"
    Assert.assertEquals(mappedDataFields.get("MergeFieldName"), "DataSourceColumnName");
    Assert.assertTrue(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertTrue(mappedDataFields.containsValue("DataSourceColumnName"));

    // Now if we run this mail merge, the "Column3" MERGEFIELDs will take data from "Column2" of the table
    doc.getMailMerge().execute(dataTable);

    // We can count and iterate over the mapped columns/fields
    Assert.assertEquals(mappedDataFields.getCount(), 2);

    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; enumerator = mappedDataFields.iterator();
    try {
        while (enumerator.hasNext()) {
            Map.Entry&lt;String, String&gt; dataField = enumerator.next();
            System.out.println(MessageFormat.format("Column named {0} is mapped to MERGEFIELDs named {1}", dataField.getValue(), dataField.getKey()));
        }
    } finally {
        if (enumerator != null) enumerator.remove();
    }

    // We can also remove some or all of the elements
    mappedDataFields.remove("MergeFieldName");
    Assert.assertFalse(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertFalse(mappedDataFields.containsValue("DataSourceColumnName"));

    mappedDataFields.clear();
    Assert.assertEquals(mappedDataFields.getCount(), 0);

    // Removing the mapped key/value pairs has no effect on the document because the merge was already done with them in place
    doc.save(getArtifactsDir() + "MailMerge.MappedDataFieldCollection.docx");
}

/// &lt;summary&gt;
/// Create a document with 2 MERGEFIELDs, one of which does not have a corresponding column in the data table.
/// &lt;/summary&gt;
private static Document createSourceDocMappedDataFields() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Insert two MERGEFIELDs that will accept data from that table
    builder.insertField(" MERGEFIELD Column1");
    builder.write(", ");
    builder.insertField(" MERGEFIELD Column3");

    return doc;
}

/// &lt;summary&gt;
/// Create a data table with 2 columns, one of which does not have a corresponding MERGEFIELD in our source document.
/// &lt;/summary&gt;
private static DataTable createSourceTableMappedDataFields() {
    // Create a data table that will be used in a mail merge
    DataTable dataTable = new DataTable("MyTable");
    dataTable.getColumns().add("Column1");
    dataTable.getColumns().add("Column2");
    dataTable.getRows().add("Value1", "Value2");

    return dataTable;
}</pre></example><DL><DT><B>See Also:</B></DT><DD><cref seealso=""><A HREF="MailMerge.html" title="class in com.aspose.words">MailMerge</A></cref>, <cref seealso=""><A HREF="MailMerge.html#MappedDataFields" title="property in class com.aspose.words.MailMerge">MailMerge.MappedDataFields</A></cref></DD></DL>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE RULES="GROUPS" BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Property Getters/Setters Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#Count">getCount</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the number of elements contained in the collection.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#Item(java.lang.String)">get</A></B>(java.lang.String&nbsp;documentFieldName)</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#Item(java.lang.String)">set</A></B>(java.lang.String&nbsp;documentFieldName, java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the name of the field in the data source associated with the specified mail merge field.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#add(java.lang.String,java.lang.String)">add</A></B>(java.lang.String&nbsp;documentFieldName, java.lang.String&nbsp;dataSourceFieldName)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Adds a new field mapping.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#clear()">clear</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes all elements from the collection.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#containsKey(java.lang.String)">containsKey</A></B>(java.lang.String&nbsp;documentFieldName)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Determines whether a mapping from the specified field in the document exists in the collection.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#containsValue(java.lang.String)">containsValue</A></B>(java.lang.String&nbsp;dataSourceFieldName)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Determines whether a mapping from the specified field in the data source exists in the collection.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.util.Iterator&lt;java.util.Map.Entry&lt;java.lang.String, java.lang.String&gt;&gt;</CODE></TD><TD><CODE><B><A HREF="#iterator()">iterator</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a dictionary iterator object that can be used to iterate over all items in the collection.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#remove(java.lang.String)">remove</A></B>(java.lang.String&nbsp;documentFieldName)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes a field mapping.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ============ PROPERTY DETAIL ========== -->

<A NAME="property_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Property Getters/Setters Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Count"><!-- --></A><A NAME="getCount()"><!-- --></A><A NAME="getCount--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCount</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getCount</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the number of elements contained in the collection.
            </summary><example><p><b>Example:</b></p>Shows how to map data columns and MERGEFIELDs with different names so the data is transferred between them during a mail merge.<pre>
public void mappedDataFieldCollection() throws Exception {
    // Create a document and table that we will merge
    Document doc = createSourceDocMappedDataFields();
    DataTable dataTable = createSourceTableMappedDataFields();

    // We have a column "Column2" in the data table that doesn't have a respective MERGEFIELD in the document
    // Also, we have a MERGEFIELD named "Column3" that does not exist as a column in the data source
    // If data from "Column2" is suitable for the "Column3" MERGEFIELD,
    // we can map that column name to the MERGEFIELD in the "MappedDataFields" key/value pair
    MappedDataFieldCollection mappedDataFields = doc.getMailMerge().getMappedDataFields();

    // A data source column name is linked to a MERGEFIELD name by adding an element like this
    mappedDataFields.add("MergeFieldName", "DataSourceColumnName");

    // So, values from "Column2" will now go into MERGEFIELDs named "Column3" as well as "Column2", if there are any
    mappedDataFields.add("Column3", "Column2");

    // The MERGEFIELD name is the "key" to the respective data source column name "value"
    Assert.assertEquals(mappedDataFields.get("MergeFieldName"), "DataSourceColumnName");
    Assert.assertTrue(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertTrue(mappedDataFields.containsValue("DataSourceColumnName"));

    // Now if we run this mail merge, the "Column3" MERGEFIELDs will take data from "Column2" of the table
    doc.getMailMerge().execute(dataTable);

    // We can count and iterate over the mapped columns/fields
    Assert.assertEquals(mappedDataFields.getCount(), 2);

    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; enumerator = mappedDataFields.iterator();
    try {
        while (enumerator.hasNext()) {
            Map.Entry&lt;String, String&gt; dataField = enumerator.next();
            System.out.println(MessageFormat.format("Column named {0} is mapped to MERGEFIELDs named {1}", dataField.getValue(), dataField.getKey()));
        }
    } finally {
        if (enumerator != null) enumerator.remove();
    }

    // We can also remove some or all of the elements
    mappedDataFields.remove("MergeFieldName");
    Assert.assertFalse(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertFalse(mappedDataFields.containsValue("DataSourceColumnName"));

    mappedDataFields.clear();
    Assert.assertEquals(mappedDataFields.getCount(), 0);

    // Removing the mapped key/value pairs has no effect on the document because the merge was already done with them in place
    doc.save(getArtifactsDir() + "MailMerge.MappedDataFieldCollection.docx");
}

/// &lt;summary&gt;
/// Create a document with 2 MERGEFIELDs, one of which does not have a corresponding column in the data table.
/// &lt;/summary&gt;
private static Document createSourceDocMappedDataFields() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Insert two MERGEFIELDs that will accept data from that table
    builder.insertField(" MERGEFIELD Column1");
    builder.write(", ");
    builder.insertField(" MERGEFIELD Column3");

    return doc;
}

/// &lt;summary&gt;
/// Create a data table with 2 columns, one of which does not have a corresponding MERGEFIELD in our source document.
/// &lt;/summary&gt;
private static DataTable createSourceTableMappedDataFields() {
    // Create a data table that will be used in a mail merge
    DataTable dataTable = new DataTable("MyTable");
    dataTable.getColumns().add("Column1");
    dataTable.getColumns().add("Column2");
    dataTable.getRows().add("Value1", "Value2");

    return dataTable;
}</pre></example>
</DL>
<HR>

<A NAME="Item(java.lang.String)"><!-- --></A><A NAME="get(java.lang.String)"><!-- --></A><A NAME="get-java.lang.String-"><!-- --></A><A NAME="set(java.lang.String,java.lang.String)"><!-- --></A><A NAME="set-java.lang.String-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>get/set</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>get</B>(java.lang.String&nbsp;documentFieldName)&nbsp;/&nbsp;public void&nbsp;<B>set</B>(java.lang.String&nbsp;documentFieldName, java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the name of the field in the data source associated with the specified mail merge field.
            </summary><example><p><b>Example:</b></p>Shows how to map data columns and MERGEFIELDs with different names so the data is transferred between them during a mail merge.<pre>
public void mappedDataFieldCollection() throws Exception {
    // Create a document and table that we will merge
    Document doc = createSourceDocMappedDataFields();
    DataTable dataTable = createSourceTableMappedDataFields();

    // We have a column "Column2" in the data table that doesn't have a respective MERGEFIELD in the document
    // Also, we have a MERGEFIELD named "Column3" that does not exist as a column in the data source
    // If data from "Column2" is suitable for the "Column3" MERGEFIELD,
    // we can map that column name to the MERGEFIELD in the "MappedDataFields" key/value pair
    MappedDataFieldCollection mappedDataFields = doc.getMailMerge().getMappedDataFields();

    // A data source column name is linked to a MERGEFIELD name by adding an element like this
    mappedDataFields.add("MergeFieldName", "DataSourceColumnName");

    // So, values from "Column2" will now go into MERGEFIELDs named "Column3" as well as "Column2", if there are any
    mappedDataFields.add("Column3", "Column2");

    // The MERGEFIELD name is the "key" to the respective data source column name "value"
    Assert.assertEquals(mappedDataFields.get("MergeFieldName"), "DataSourceColumnName");
    Assert.assertTrue(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertTrue(mappedDataFields.containsValue("DataSourceColumnName"));

    // Now if we run this mail merge, the "Column3" MERGEFIELDs will take data from "Column2" of the table
    doc.getMailMerge().execute(dataTable);

    // We can count and iterate over the mapped columns/fields
    Assert.assertEquals(mappedDataFields.getCount(), 2);

    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; enumerator = mappedDataFields.iterator();
    try {
        while (enumerator.hasNext()) {
            Map.Entry&lt;String, String&gt; dataField = enumerator.next();
            System.out.println(MessageFormat.format("Column named {0} is mapped to MERGEFIELDs named {1}", dataField.getValue(), dataField.getKey()));
        }
    } finally {
        if (enumerator != null) enumerator.remove();
    }

    // We can also remove some or all of the elements
    mappedDataFields.remove("MergeFieldName");
    Assert.assertFalse(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertFalse(mappedDataFields.containsValue("DataSourceColumnName"));

    mappedDataFields.clear();
    Assert.assertEquals(mappedDataFields.getCount(), 0);

    // Removing the mapped key/value pairs has no effect on the document because the merge was already done with them in place
    doc.save(getArtifactsDir() + "MailMerge.MappedDataFieldCollection.docx");
}

/// &lt;summary&gt;
/// Create a document with 2 MERGEFIELDs, one of which does not have a corresponding column in the data table.
/// &lt;/summary&gt;
private static Document createSourceDocMappedDataFields() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Insert two MERGEFIELDs that will accept data from that table
    builder.insertField(" MERGEFIELD Column1");
    builder.write(", ");
    builder.insertField(" MERGEFIELD Column3");

    return doc;
}

/// &lt;summary&gt;
/// Create a data table with 2 columns, one of which does not have a corresponding MERGEFIELD in our source document.
/// &lt;/summary&gt;
private static DataTable createSourceTableMappedDataFields() {
    // Create a data table that will be used in a mail merge
    DataTable dataTable = new DataTable("MyTable");
    dataTable.getColumns().add("Column1");
    dataTable.getColumns().add("Column2");
    dataTable.getRows().add("Value1", "Value2");

    return dataTable;
}</pre></example>
</DL>
<HR>



<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="add(java.lang.String,java.lang.String)"><!-- --></A><A NAME="add-java.lang.String-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>add</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>add</B>(java.lang.String&nbsp;documentFieldName, java.lang.String&nbsp;dataSourceFieldName)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Adds a new field mapping.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="documentFieldName"><CODE>documentFieldName</CODE> - Case-sensitive name of the mail merge field in the document.</DD><DD param="dataSourceFieldName"><CODE>dataSourceFieldName</CODE> - Case-sensitive name of the field in the data source.</DD></DL><example><p><b>Example:</b></p>Shows how to map data columns and MERGEFIELDs with different names so the data is transferred between them during a mail merge.<pre>
public void mappedDataFieldCollection() throws Exception {
    // Create a document and table that we will merge
    Document doc = createSourceDocMappedDataFields();
    DataTable dataTable = createSourceTableMappedDataFields();

    // We have a column "Column2" in the data table that doesn't have a respective MERGEFIELD in the document
    // Also, we have a MERGEFIELD named "Column3" that does not exist as a column in the data source
    // If data from "Column2" is suitable for the "Column3" MERGEFIELD,
    // we can map that column name to the MERGEFIELD in the "MappedDataFields" key/value pair
    MappedDataFieldCollection mappedDataFields = doc.getMailMerge().getMappedDataFields();

    // A data source column name is linked to a MERGEFIELD name by adding an element like this
    mappedDataFields.add("MergeFieldName", "DataSourceColumnName");

    // So, values from "Column2" will now go into MERGEFIELDs named "Column3" as well as "Column2", if there are any
    mappedDataFields.add("Column3", "Column2");

    // The MERGEFIELD name is the "key" to the respective data source column name "value"
    Assert.assertEquals(mappedDataFields.get("MergeFieldName"), "DataSourceColumnName");
    Assert.assertTrue(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertTrue(mappedDataFields.containsValue("DataSourceColumnName"));

    // Now if we run this mail merge, the "Column3" MERGEFIELDs will take data from "Column2" of the table
    doc.getMailMerge().execute(dataTable);

    // We can count and iterate over the mapped columns/fields
    Assert.assertEquals(mappedDataFields.getCount(), 2);

    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; enumerator = mappedDataFields.iterator();
    try {
        while (enumerator.hasNext()) {
            Map.Entry&lt;String, String&gt; dataField = enumerator.next();
            System.out.println(MessageFormat.format("Column named {0} is mapped to MERGEFIELDs named {1}", dataField.getValue(), dataField.getKey()));
        }
    } finally {
        if (enumerator != null) enumerator.remove();
    }

    // We can also remove some or all of the elements
    mappedDataFields.remove("MergeFieldName");
    Assert.assertFalse(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertFalse(mappedDataFields.containsValue("DataSourceColumnName"));

    mappedDataFields.clear();
    Assert.assertEquals(mappedDataFields.getCount(), 0);

    // Removing the mapped key/value pairs has no effect on the document because the merge was already done with them in place
    doc.save(getArtifactsDir() + "MailMerge.MappedDataFieldCollection.docx");
}

/// &lt;summary&gt;
/// Create a document with 2 MERGEFIELDs, one of which does not have a corresponding column in the data table.
/// &lt;/summary&gt;
private static Document createSourceDocMappedDataFields() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Insert two MERGEFIELDs that will accept data from that table
    builder.insertField(" MERGEFIELD Column1");
    builder.write(", ");
    builder.insertField(" MERGEFIELD Column3");

    return doc;
}

/// &lt;summary&gt;
/// Create a data table with 2 columns, one of which does not have a corresponding MERGEFIELD in our source document.
/// &lt;/summary&gt;
private static DataTable createSourceTableMappedDataFields() {
    // Create a data table that will be used in a mail merge
    DataTable dataTable = new DataTable("MyTable");
    dataTable.getColumns().add("Column1");
    dataTable.getColumns().add("Column2");
    dataTable.getRows().add("Value1", "Value2");

    return dataTable;
}</pre></example>
</DL>
<HR>

<A NAME="clear()"><!-- --></A><A NAME="clear--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>clear</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>clear</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes all elements from the collection.
            </summary><example><p><b>Example:</b></p>Shows how to map data columns and MERGEFIELDs with different names so the data is transferred between them during a mail merge.<pre>
public void mappedDataFieldCollection() throws Exception {
    // Create a document and table that we will merge
    Document doc = createSourceDocMappedDataFields();
    DataTable dataTable = createSourceTableMappedDataFields();

    // We have a column "Column2" in the data table that doesn't have a respective MERGEFIELD in the document
    // Also, we have a MERGEFIELD named "Column3" that does not exist as a column in the data source
    // If data from "Column2" is suitable for the "Column3" MERGEFIELD,
    // we can map that column name to the MERGEFIELD in the "MappedDataFields" key/value pair
    MappedDataFieldCollection mappedDataFields = doc.getMailMerge().getMappedDataFields();

    // A data source column name is linked to a MERGEFIELD name by adding an element like this
    mappedDataFields.add("MergeFieldName", "DataSourceColumnName");

    // So, values from "Column2" will now go into MERGEFIELDs named "Column3" as well as "Column2", if there are any
    mappedDataFields.add("Column3", "Column2");

    // The MERGEFIELD name is the "key" to the respective data source column name "value"
    Assert.assertEquals(mappedDataFields.get("MergeFieldName"), "DataSourceColumnName");
    Assert.assertTrue(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertTrue(mappedDataFields.containsValue("DataSourceColumnName"));

    // Now if we run this mail merge, the "Column3" MERGEFIELDs will take data from "Column2" of the table
    doc.getMailMerge().execute(dataTable);

    // We can count and iterate over the mapped columns/fields
    Assert.assertEquals(mappedDataFields.getCount(), 2);

    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; enumerator = mappedDataFields.iterator();
    try {
        while (enumerator.hasNext()) {
            Map.Entry&lt;String, String&gt; dataField = enumerator.next();
            System.out.println(MessageFormat.format("Column named {0} is mapped to MERGEFIELDs named {1}", dataField.getValue(), dataField.getKey()));
        }
    } finally {
        if (enumerator != null) enumerator.remove();
    }

    // We can also remove some or all of the elements
    mappedDataFields.remove("MergeFieldName");
    Assert.assertFalse(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertFalse(mappedDataFields.containsValue("DataSourceColumnName"));

    mappedDataFields.clear();
    Assert.assertEquals(mappedDataFields.getCount(), 0);

    // Removing the mapped key/value pairs has no effect on the document because the merge was already done with them in place
    doc.save(getArtifactsDir() + "MailMerge.MappedDataFieldCollection.docx");
}

/// &lt;summary&gt;
/// Create a document with 2 MERGEFIELDs, one of which does not have a corresponding column in the data table.
/// &lt;/summary&gt;
private static Document createSourceDocMappedDataFields() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Insert two MERGEFIELDs that will accept data from that table
    builder.insertField(" MERGEFIELD Column1");
    builder.write(", ");
    builder.insertField(" MERGEFIELD Column3");

    return doc;
}

/// &lt;summary&gt;
/// Create a data table with 2 columns, one of which does not have a corresponding MERGEFIELD in our source document.
/// &lt;/summary&gt;
private static DataTable createSourceTableMappedDataFields() {
    // Create a data table that will be used in a mail merge
    DataTable dataTable = new DataTable("MyTable");
    dataTable.getColumns().add("Column1");
    dataTable.getColumns().add("Column2");
    dataTable.getRows().add("Value1", "Value2");

    return dataTable;
}</pre></example>
</DL>
<HR>

<A NAME="containsKey(java.lang.String)"><!-- --></A><A NAME="containsKey-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>containsKey</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>containsKey</B>(java.lang.String&nbsp;documentFieldName)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Determines whether a mapping from the specified field in the document exists in the collection.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="documentFieldName"><CODE>documentFieldName</CODE> - Case-sensitive name of the mail merge field in the document.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns=""><code>true</code> if item is found in the collection; otherwise, <code>false</code>.</DD></DL><example><p><b>Example:</b></p>Shows how to map data columns and MERGEFIELDs with different names so the data is transferred between them during a mail merge.<pre>
public void mappedDataFieldCollection() throws Exception {
    // Create a document and table that we will merge
    Document doc = createSourceDocMappedDataFields();
    DataTable dataTable = createSourceTableMappedDataFields();

    // We have a column "Column2" in the data table that doesn't have a respective MERGEFIELD in the document
    // Also, we have a MERGEFIELD named "Column3" that does not exist as a column in the data source
    // If data from "Column2" is suitable for the "Column3" MERGEFIELD,
    // we can map that column name to the MERGEFIELD in the "MappedDataFields" key/value pair
    MappedDataFieldCollection mappedDataFields = doc.getMailMerge().getMappedDataFields();

    // A data source column name is linked to a MERGEFIELD name by adding an element like this
    mappedDataFields.add("MergeFieldName", "DataSourceColumnName");

    // So, values from "Column2" will now go into MERGEFIELDs named "Column3" as well as "Column2", if there are any
    mappedDataFields.add("Column3", "Column2");

    // The MERGEFIELD name is the "key" to the respective data source column name "value"
    Assert.assertEquals(mappedDataFields.get("MergeFieldName"), "DataSourceColumnName");
    Assert.assertTrue(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertTrue(mappedDataFields.containsValue("DataSourceColumnName"));

    // Now if we run this mail merge, the "Column3" MERGEFIELDs will take data from "Column2" of the table
    doc.getMailMerge().execute(dataTable);

    // We can count and iterate over the mapped columns/fields
    Assert.assertEquals(mappedDataFields.getCount(), 2);

    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; enumerator = mappedDataFields.iterator();
    try {
        while (enumerator.hasNext()) {
            Map.Entry&lt;String, String&gt; dataField = enumerator.next();
            System.out.println(MessageFormat.format("Column named {0} is mapped to MERGEFIELDs named {1}", dataField.getValue(), dataField.getKey()));
        }
    } finally {
        if (enumerator != null) enumerator.remove();
    }

    // We can also remove some or all of the elements
    mappedDataFields.remove("MergeFieldName");
    Assert.assertFalse(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertFalse(mappedDataFields.containsValue("DataSourceColumnName"));

    mappedDataFields.clear();
    Assert.assertEquals(mappedDataFields.getCount(), 0);

    // Removing the mapped key/value pairs has no effect on the document because the merge was already done with them in place
    doc.save(getArtifactsDir() + "MailMerge.MappedDataFieldCollection.docx");
}

/// &lt;summary&gt;
/// Create a document with 2 MERGEFIELDs, one of which does not have a corresponding column in the data table.
/// &lt;/summary&gt;
private static Document createSourceDocMappedDataFields() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Insert two MERGEFIELDs that will accept data from that table
    builder.insertField(" MERGEFIELD Column1");
    builder.write(", ");
    builder.insertField(" MERGEFIELD Column3");

    return doc;
}

/// &lt;summary&gt;
/// Create a data table with 2 columns, one of which does not have a corresponding MERGEFIELD in our source document.
/// &lt;/summary&gt;
private static DataTable createSourceTableMappedDataFields() {
    // Create a data table that will be used in a mail merge
    DataTable dataTable = new DataTable("MyTable");
    dataTable.getColumns().add("Column1");
    dataTable.getColumns().add("Column2");
    dataTable.getRows().add("Value1", "Value2");

    return dataTable;
}</pre></example>
</DL>
<HR>

<A NAME="containsValue(java.lang.String)"><!-- --></A><A NAME="containsValue-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>containsValue</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>containsValue</B>(java.lang.String&nbsp;dataSourceFieldName)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Determines whether a mapping from the specified field in the data source exists in the collection.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="dataSourceFieldName"><CODE>dataSourceFieldName</CODE> - Case-sensitive name of the field in the data source.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns=""><code>true</code> if item is found in the collection; otherwise, <code>false</code>.</DD></DL><example><p><b>Example:</b></p>Shows how to map data columns and MERGEFIELDs with different names so the data is transferred between them during a mail merge.<pre>
public void mappedDataFieldCollection() throws Exception {
    // Create a document and table that we will merge
    Document doc = createSourceDocMappedDataFields();
    DataTable dataTable = createSourceTableMappedDataFields();

    // We have a column "Column2" in the data table that doesn't have a respective MERGEFIELD in the document
    // Also, we have a MERGEFIELD named "Column3" that does not exist as a column in the data source
    // If data from "Column2" is suitable for the "Column3" MERGEFIELD,
    // we can map that column name to the MERGEFIELD in the "MappedDataFields" key/value pair
    MappedDataFieldCollection mappedDataFields = doc.getMailMerge().getMappedDataFields();

    // A data source column name is linked to a MERGEFIELD name by adding an element like this
    mappedDataFields.add("MergeFieldName", "DataSourceColumnName");

    // So, values from "Column2" will now go into MERGEFIELDs named "Column3" as well as "Column2", if there are any
    mappedDataFields.add("Column3", "Column2");

    // The MERGEFIELD name is the "key" to the respective data source column name "value"
    Assert.assertEquals(mappedDataFields.get("MergeFieldName"), "DataSourceColumnName");
    Assert.assertTrue(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertTrue(mappedDataFields.containsValue("DataSourceColumnName"));

    // Now if we run this mail merge, the "Column3" MERGEFIELDs will take data from "Column2" of the table
    doc.getMailMerge().execute(dataTable);

    // We can count and iterate over the mapped columns/fields
    Assert.assertEquals(mappedDataFields.getCount(), 2);

    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; enumerator = mappedDataFields.iterator();
    try {
        while (enumerator.hasNext()) {
            Map.Entry&lt;String, String&gt; dataField = enumerator.next();
            System.out.println(MessageFormat.format("Column named {0} is mapped to MERGEFIELDs named {1}", dataField.getValue(), dataField.getKey()));
        }
    } finally {
        if (enumerator != null) enumerator.remove();
    }

    // We can also remove some or all of the elements
    mappedDataFields.remove("MergeFieldName");
    Assert.assertFalse(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertFalse(mappedDataFields.containsValue("DataSourceColumnName"));

    mappedDataFields.clear();
    Assert.assertEquals(mappedDataFields.getCount(), 0);

    // Removing the mapped key/value pairs has no effect on the document because the merge was already done with them in place
    doc.save(getArtifactsDir() + "MailMerge.MappedDataFieldCollection.docx");
}

/// &lt;summary&gt;
/// Create a document with 2 MERGEFIELDs, one of which does not have a corresponding column in the data table.
/// &lt;/summary&gt;
private static Document createSourceDocMappedDataFields() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Insert two MERGEFIELDs that will accept data from that table
    builder.insertField(" MERGEFIELD Column1");
    builder.write(", ");
    builder.insertField(" MERGEFIELD Column3");

    return doc;
}

/// &lt;summary&gt;
/// Create a data table with 2 columns, one of which does not have a corresponding MERGEFIELD in our source document.
/// &lt;/summary&gt;
private static DataTable createSourceTableMappedDataFields() {
    // Create a data table that will be used in a mail merge
    DataTable dataTable = new DataTable("MyTable");
    dataTable.getColumns().add("Column1");
    dataTable.getColumns().add("Column2");
    dataTable.getRows().add("Value1", "Value2");

    return dataTable;
}</pre></example>
</DL>
<HR>

<A NAME="iterator()"><!-- --></A><A NAME="iterator--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>iterator</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.util.Iterator&lt;java.util.Map.Entry&lt;java.lang.String, java.lang.String&gt;&gt;&nbsp;<B>iterator</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a dictionary iterator object that can be used to iterate over all items in the collection.
            </summary><example><p><b>Example:</b></p>Shows how to map data columns and MERGEFIELDs with different names so the data is transferred between them during a mail merge.<pre>
public void mappedDataFieldCollection() throws Exception {
    // Create a document and table that we will merge
    Document doc = createSourceDocMappedDataFields();
    DataTable dataTable = createSourceTableMappedDataFields();

    // We have a column "Column2" in the data table that doesn't have a respective MERGEFIELD in the document
    // Also, we have a MERGEFIELD named "Column3" that does not exist as a column in the data source
    // If data from "Column2" is suitable for the "Column3" MERGEFIELD,
    // we can map that column name to the MERGEFIELD in the "MappedDataFields" key/value pair
    MappedDataFieldCollection mappedDataFields = doc.getMailMerge().getMappedDataFields();

    // A data source column name is linked to a MERGEFIELD name by adding an element like this
    mappedDataFields.add("MergeFieldName", "DataSourceColumnName");

    // So, values from "Column2" will now go into MERGEFIELDs named "Column3" as well as "Column2", if there are any
    mappedDataFields.add("Column3", "Column2");

    // The MERGEFIELD name is the "key" to the respective data source column name "value"
    Assert.assertEquals(mappedDataFields.get("MergeFieldName"), "DataSourceColumnName");
    Assert.assertTrue(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertTrue(mappedDataFields.containsValue("DataSourceColumnName"));

    // Now if we run this mail merge, the "Column3" MERGEFIELDs will take data from "Column2" of the table
    doc.getMailMerge().execute(dataTable);

    // We can count and iterate over the mapped columns/fields
    Assert.assertEquals(mappedDataFields.getCount(), 2);

    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; enumerator = mappedDataFields.iterator();
    try {
        while (enumerator.hasNext()) {
            Map.Entry&lt;String, String&gt; dataField = enumerator.next();
            System.out.println(MessageFormat.format("Column named {0} is mapped to MERGEFIELDs named {1}", dataField.getValue(), dataField.getKey()));
        }
    } finally {
        if (enumerator != null) enumerator.remove();
    }

    // We can also remove some or all of the elements
    mappedDataFields.remove("MergeFieldName");
    Assert.assertFalse(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertFalse(mappedDataFields.containsValue("DataSourceColumnName"));

    mappedDataFields.clear();
    Assert.assertEquals(mappedDataFields.getCount(), 0);

    // Removing the mapped key/value pairs has no effect on the document because the merge was already done with them in place
    doc.save(getArtifactsDir() + "MailMerge.MappedDataFieldCollection.docx");
}

/// &lt;summary&gt;
/// Create a document with 2 MERGEFIELDs, one of which does not have a corresponding column in the data table.
/// &lt;/summary&gt;
private static Document createSourceDocMappedDataFields() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Insert two MERGEFIELDs that will accept data from that table
    builder.insertField(" MERGEFIELD Column1");
    builder.write(", ");
    builder.insertField(" MERGEFIELD Column3");

    return doc;
}

/// &lt;summary&gt;
/// Create a data table with 2 columns, one of which does not have a corresponding MERGEFIELD in our source document.
/// &lt;/summary&gt;
private static DataTable createSourceTableMappedDataFields() {
    // Create a data table that will be used in a mail merge
    DataTable dataTable = new DataTable("MyTable");
    dataTable.getColumns().add("Column1");
    dataTable.getColumns().add("Column2");
    dataTable.getRows().add("Value1", "Value2");

    return dataTable;
}</pre></example>
</DL>
<HR>

<A NAME="remove(java.lang.String)"><!-- --></A><A NAME="remove-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>remove</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>remove</B>(java.lang.String&nbsp;documentFieldName)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes a field mapping.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="documentFieldName"><CODE>documentFieldName</CODE> - Case-sensitive name of the mail merge field in the document.</DD></DL><example><p><b>Example:</b></p>Shows how to map data columns and MERGEFIELDs with different names so the data is transferred between them during a mail merge.<pre>
public void mappedDataFieldCollection() throws Exception {
    // Create a document and table that we will merge
    Document doc = createSourceDocMappedDataFields();
    DataTable dataTable = createSourceTableMappedDataFields();

    // We have a column "Column2" in the data table that doesn't have a respective MERGEFIELD in the document
    // Also, we have a MERGEFIELD named "Column3" that does not exist as a column in the data source
    // If data from "Column2" is suitable for the "Column3" MERGEFIELD,
    // we can map that column name to the MERGEFIELD in the "MappedDataFields" key/value pair
    MappedDataFieldCollection mappedDataFields = doc.getMailMerge().getMappedDataFields();

    // A data source column name is linked to a MERGEFIELD name by adding an element like this
    mappedDataFields.add("MergeFieldName", "DataSourceColumnName");

    // So, values from "Column2" will now go into MERGEFIELDs named "Column3" as well as "Column2", if there are any
    mappedDataFields.add("Column3", "Column2");

    // The MERGEFIELD name is the "key" to the respective data source column name "value"
    Assert.assertEquals(mappedDataFields.get("MergeFieldName"), "DataSourceColumnName");
    Assert.assertTrue(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertTrue(mappedDataFields.containsValue("DataSourceColumnName"));

    // Now if we run this mail merge, the "Column3" MERGEFIELDs will take data from "Column2" of the table
    doc.getMailMerge().execute(dataTable);

    // We can count and iterate over the mapped columns/fields
    Assert.assertEquals(mappedDataFields.getCount(), 2);

    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; enumerator = mappedDataFields.iterator();
    try {
        while (enumerator.hasNext()) {
            Map.Entry&lt;String, String&gt; dataField = enumerator.next();
            System.out.println(MessageFormat.format("Column named {0} is mapped to MERGEFIELDs named {1}", dataField.getValue(), dataField.getKey()));
        }
    } finally {
        if (enumerator != null) enumerator.remove();
    }

    // We can also remove some or all of the elements
    mappedDataFields.remove("MergeFieldName");
    Assert.assertFalse(mappedDataFields.containsKey("MergeFieldName"));
    Assert.assertFalse(mappedDataFields.containsValue("DataSourceColumnName"));

    mappedDataFields.clear();
    Assert.assertEquals(mappedDataFields.getCount(), 0);

    // Removing the mapped key/value pairs has no effect on the document because the merge was already done with them in place
    doc.save(getArtifactsDir() + "MailMerge.MappedDataFieldCollection.docx");
}

/// &lt;summary&gt;
/// Create a document with 2 MERGEFIELDs, one of which does not have a corresponding column in the data table.
/// &lt;/summary&gt;
private static Document createSourceDocMappedDataFields() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Insert two MERGEFIELDs that will accept data from that table
    builder.insertField(" MERGEFIELD Column1");
    builder.write(", ");
    builder.insertField(" MERGEFIELD Column3");

    return doc;
}

/// &lt;summary&gt;
/// Create a data table with 2 columns, one of which does not have a corresponding MERGEFIELD in our source document.
/// &lt;/summary&gt;
private static DataTable createSourceTableMappedDataFields() {
    // Create a data table that will be used in a mail merge
    DataTable dataTable = new DataTable("MyTable");
    dataTable.getColumns().add("Column1");
    dataTable.getColumns().add("Column2");
    dataTable.getRows().add("Value1", "Value2");

    return dataTable;
}</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>