<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 19 Jul 2025 -->
<TITLE>Section</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class Section</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="Node.html" title="class in com.aspose.words">Node</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>
          <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.Section</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Cloneable, java.lang.Iterable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Section </B><DT>extends <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></DL>
</PRE>

<P>

<summary>
             Represents a single section in a document.
             <p>To learn more, visit the <a href="https://docs.aspose.com/words/net/working-with-sections/">Working with Sections</a> documentation article.</p></summary><remarks><p><cref><i>Section</i></cref> can have one <cref><A HREF="Body.html" title="class in com.aspose.words">Body</A></cref> and maximum one <cref><A HREF="HeaderFooter.html" title="class in com.aspose.words">HeaderFooter</A></cref>
             of each <cref><A HREF="HeaderFooterType.html" title="Utility class in com.aspose.words">HeaderFooterType</A></cref>. <cref><A HREF="Body.html" title="class in com.aspose.words">Body</A></cref> and <cref><A HREF="HeaderFooter.html" title="class in com.aspose.words">HeaderFooter</A></cref> nodes
             can be in any order inside <cref><i>Section</i></cref>.</p><p>A minimal valid section needs to have <cref><A HREF="Body.html" title="class in com.aspose.words">Body</A></cref> with one <cref><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></cref>.</p><p>Each section has its own set of properties that specify page size, orientation, margins etc.</p><p>You can create a copy of a section using <cref><A HREF="#deepClone(boolean)" title="method in class com.aspose.words.Section">deepClone(boolean)</A></cref>. The copy can be inserted into
             the same or different document.</p><p>To add, insert or remove a whole section including section break and
             section properties use methods of the <cref><A HREF="Document.html#Sections" title="property in class com.aspose.words.Document">Document.Sections</A></cref> object.</p><p>To copy and insert just content of the section excluding the section break
             and section properties use <cref><A HREF="#appendContent(com.aspose.words.Section)" title="method in class com.aspose.words.Section">appendContent(com.aspose.words.Section)</A></cref> and <cref><A HREF="#prependContent(com.aspose.words.Section)" title="method in class com.aspose.words.Section">prependContent(com.aspose.words.Section)</A></cref> methods.</p></remarks><example><p><b>Example:</b></p>Shows how to construct an Aspose.Words document by hand.<pre>
Document doc = new Document();

// A blank document contains one section, one body and one paragraph.
// Call the "RemoveAllChildren" method to remove all those nodes,
// and end up with a document node with no children.
doc.removeAllChildren();

// This document now has no composite child nodes that we can add content to.
// If we wish to edit it, we will need to repopulate its node collection.
// First, create a new section, and then append it as a child to the root document node.
Section section = new Section(doc);
doc.appendChild(section);

// Set some page setup properties for the section.
section.getPageSetup().setSectionStart(SectionStart.NEW_PAGE);
section.getPageSetup().setPaperSize(PaperSize.LETTER);

// A section needs a body, which will contain and display all its contents
// on the page between the section's header and footer.
Body body = new Body(doc);
section.appendChild(body);

// Create a paragraph, set some formatting properties, and then append it as a child to the body.
Paragraph para = new Paragraph(doc);

para.getParagraphFormat().setStyleName("Heading 1");
para.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER);

body.appendChild(para);

// Finally, add some content to do the document. Create a run,
// set its appearance and contents, and then append it as a child to the paragraph.
Run run = new Run(doc);
run.setText("Hello World!");
run.getFont().setColor(Color.RED);
para.appendChild(run);

Assert.assertEquals("Hello World!", doc.getText().trim());

doc.save(getArtifactsDir() + "Section.CreateManually.docx");</pre></example>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" ><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="#Section(com.aspose.words.DocumentBase)">Section</A></B>(<A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A>&nbsp;doc)</CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Initializes a new instance of the Section class.
            </TD>
</TR>
</TABLE>&nbsp;

<!-- ========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE RULES="GROUPS" BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Property Getters/Setters Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Body.html" title="class in com.aspose.words">Body</A></CODE></TD><TD><CODE><B><A HREF="#Body">getBody</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns the <cref><A HREF="Body.html" title="class in com.aspose.words">Body</A></cref> child node of the section.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#Count">getCount</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the number of immediate children of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#CustomNodeId">getCustomNodeId</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#CustomNodeId">setCustomNodeId</A></B>(int&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Specifies custom node identifier.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A></CODE></TD><TD><CODE><B><A HREF="#Document">getDocument</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the document to which this node belongs.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#FirstChild">getFirstChild</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first child of the node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#HasChildNodes">hasChildNodes</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns <code>true</code> if this node has any child nodes.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="HeaderFooterCollection.html" title="class in com.aspose.words">HeaderFooterCollection</A></CODE></TD><TD><CODE><B><A HREF="#HeadersFooters">getHeadersFooters</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Provides access to the headers and footers nodes of the section.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsComposite">isComposite</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns <code>true</code> as this node can have child nodes.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#LastChild">getLastChild</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the last child of the node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#NextSibling">getNextSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately following this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#NodeType">getNodeType</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns <cref><A HREF="NodeType.html#SECTION" title="field in class com.aspose.words.NodeType">NodeType.SECTION</A></cref>.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="PageSetup.html" title="class in com.aspose.words">PageSetup</A></CODE></TD><TD><CODE><B><A HREF="#PageSetup">getPageSetup</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns an object that represents page setup and section properties.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#ParentNode">getParentNode</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the immediate parent of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#PreviousSibling">getPreviousSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately preceding this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#ProtectedForForms">getProtectedForForms</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#ProtectedForForms">setProtectedForForms</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            True if the section is protected for forms. When a section is protected for forms,
            users can select and modify text only in form fields in Microsoft Word.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Range.html" title="class in com.aspose.words">Range</A></CODE></TD><TD><CODE><B><A HREF="#Range">getRange</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a <cref><A HREF="Range.html" title="class in com.aspose.words">Range</A></cref> object that represents the portion of a document that is contained in this node.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#accept(com.aspose.words.DocumentVisitor)">accept</A></B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Accepts a visitor.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#acceptEnd(com.aspose.words.DocumentVisitor)">acceptEnd</A></B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#acceptStart(com.aspose.words.DocumentVisitor)">acceptStart</A></B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#appendContent(com.aspose.words.Section)">appendContent</A></B>(<A HREF="Section.html" title="class in com.aspose.words">Section</A>&nbsp;sourceSection)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Inserts a copy of content of the source section at the end of this section.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#clearContent()">clearContent</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Clears the section.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#clearHeadersFooters()">clearHeadersFooters</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Clears the headers and footers of this section.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#clearHeadersFooters(boolean)">clearHeadersFooters</A></B>(boolean&nbsp;preserveWatermarks)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Clears the headers and footers of this section.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Section.html" title="class in com.aspose.words">Section</A></CODE></TD><TD><CODE><B><A HREF="#deepClone()">deepClone</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Creates a duplicate of this section.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#deepClone(boolean)">deepClone</A></B>(boolean&nbsp;isCloneChildren)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Creates a duplicate of the node.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#deleteHeaderFooterShapes()">deleteHeaderFooterShapes</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Deletes all shapes (drawing objects) from the headers and footers of this section.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#ensureMinimum()">ensureMinimum</A></B>()</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Ensures that the section has <cref><A HREF="#Body" title="property in class com.aspose.words.Section">Body</A></cref> with one <cref><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></cref>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(int)">getAncestor</A></B>(int&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(java.lang.Class)">getAncestor</A></B>(java.lang.Class&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified object type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#getChild(int,int,boolean)">getChild</A></B>(int&nbsp;nodeType, int&nbsp;index, boolean&nbsp;isDeep)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns an Nth child node that matches the specified type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="NodeCollection.html" title="class in com.aspose.words">NodeCollection</A></CODE></TD><TD><CODE><B><A HREF="#getChildNodes(int,boolean)">getChildNodes</A></B>(int&nbsp;nodeType, boolean&nbsp;isDeep)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a live collection of child nodes that match the specified type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#getText()">getText</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Gets the text of this node and of all its children.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#indexOf(com.aspose.words.Node)">indexOf</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;child)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns the index of the specified child node in the child node array.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.util.Iterator&lt;<A HREF="Node.html" title="class in com.aspose.words">Node</A>&gt;</CODE></TD><TD><CODE><B><A HREF="#iterator()">iterator</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Provides support for the for each style iteration over the child nodes of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#nextPreOrder(com.aspose.words.Node)">nextPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets next node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#prependContent(com.aspose.words.Section)">prependContent</A></B>(<A HREF="Section.html" title="class in com.aspose.words">Section</A>&nbsp;sourceSection)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Inserts a copy of content of the source section at the beginning of this section.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#previousPreOrder(com.aspose.words.Node)">previousPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the previous node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#remove()">remove</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes itself from the parent.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#removeAllChildren()">removeAllChildren</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes all the child nodes of the current node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#removeSmartTags()">removeSmartTags</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes all <cref><A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A></cref> descendant nodes of the current node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="NodeList.html" title="class in com.aspose.words">NodeList</A></CODE></TD><TD><CODE><B><A HREF="#selectNodes(java.lang.String)">selectNodes</A></B>(java.lang.String&nbsp;xpath)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Selects a list of nodes matching the XPath expression.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#selectSingleNode(java.lang.String)">selectSingleNode</A></B>(java.lang.String&nbsp;xpath)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Selects the first <cref><A HREF="Node.html" title="class in com.aspose.words">Node</A></cref> that matches the XPath expression.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(com.aspose.words.SaveOptions)">toString</A></B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string using the specified save options.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(int)">toString</A></B>(int&nbsp;saveFormat)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string in the specified format.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Section(com.aspose.words.DocumentBase)"><!-- --></A><A NAME="Section-com.aspose.words.DocumentBase-"><!-- --></A><H3>
Section</H3>
<PRE>
public <B>Section</B>(<A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A>&nbsp;doc)</PRE>
<DL><DD><summary>
            Initializes a new instance of the Section class.
            </summary><remarks><p>When the section is created, it belongs to the specified document, but is not
            yet part of the document and <cref><A HREF="#ParentNode" title="property in class com.aspose.words.Section">ParentNode</A></cref> is <code>null</code>.</p><p>To include <cref><i>Section</i></cref> into a document use <cref><B>InsertAfter``1</B></cref> and 
            <cref><B>InsertBefore``1</B></cref> methods of the <cref><A HREF="Document.html" title="class in com.aspose.words">Document</A></cref> OR
            <cref><A HREF="NodeCollection.html#add(com.aspose.words.Node)" title="method in class com.aspose.words.NodeCollection">NodeCollection.add(com.aspose.words.Node)</A></cref> and <cref><A HREF="NodeCollection.html#insert(int,com.aspose.words.Node)" title="method in class com.aspose.words.NodeCollection">NodeCollection.insert(int,com.aspose.words.Node)</A></cref> methods of the <cref><A HREF="Document.html#Sections" title="property in class com.aspose.words.Document">Document.Sections</A></cref> property.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="doc"><CODE>doc</CODE> - The owner document.</DD></DL><example><p><b>Example:</b></p>Shows how to construct an Aspose.Words document by hand.<pre>
Document doc = new Document();

// A blank document contains one section, one body and one paragraph.
// Call the "RemoveAllChildren" method to remove all those nodes,
// and end up with a document node with no children.
doc.removeAllChildren();

// This document now has no composite child nodes that we can add content to.
// If we wish to edit it, we will need to repopulate its node collection.
// First, create a new section, and then append it as a child to the root document node.
Section section = new Section(doc);
doc.appendChild(section);

// Set some page setup properties for the section.
section.getPageSetup().setSectionStart(SectionStart.NEW_PAGE);
section.getPageSetup().setPaperSize(PaperSize.LETTER);

// A section needs a body, which will contain and display all its contents
// on the page between the section's header and footer.
Body body = new Body(doc);
section.appendChild(body);

// Create a paragraph, set some formatting properties, and then append it as a child to the body.
Paragraph para = new Paragraph(doc);

para.getParagraphFormat().setStyleName("Heading 1");
para.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER);

body.appendChild(para);

// Finally, add some content to do the document. Create a run,
// set its appearance and contents, and then append it as a child to the paragraph.
Run run = new Run(doc);
run.setText("Hello World!");
run.getFont().setColor(Color.RED);
para.appendChild(run);

Assert.assertEquals("Hello World!", doc.getText().trim());

doc.save(getArtifactsDir() + "Section.CreateManually.docx");</pre></example>
</DL>
<HR>



<!-- ============ PROPERTY DETAIL ========== -->

<A NAME="property_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Property Getters/Setters Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Body"><!-- --></A><A NAME="getBody()"><!-- --></A><A NAME="getBody--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getBody</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Body.html" title="class in com.aspose.words">Body</A>&nbsp;<B>getBody</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns the <cref><A HREF="Body.html" title="class in com.aspose.words">Body</A></cref> child node of the section.
            </summary><remarks><p><cref><A HREF="Body.html" title="class in com.aspose.words">Body</A></cref> contains main text of the section.</p><p>Returns <code>null</code> if the section does not have a <cref><A HREF="Body.html" title="class in com.aspose.words">Body</A></cref> node among its children.</p></remarks><example><p><b>Example:</b></p>Clears main text from all sections from the document leaving the sections themselves.<pre>
Document doc = new Document();

// A blank document contains one section, one body and one paragraph.
// Call the "RemoveAllChildren" method to remove all those nodes,
// and end up with a document node with no children.
doc.removeAllChildren();

// This document now has no composite child nodes that we can add content to.
// If we wish to edit it, we will need to repopulate its node collection.
// First, create a new section, and then append it as a child to the root document node.
Section section = new Section(doc);
doc.appendChild(section);

// A section needs a body, which will contain and display all its contents
// on the page between the section's header and footer.
Body body = new Body(doc);
section.appendChild(body);

// This body has no children, so we cannot add runs to it yet.
Assert.assertEquals(0, doc.getFirstSection().getBody().getChildNodes(NodeType.ANY, true).getCount());

// Call the "EnsureMinimum" to make sure that this body contains at least one empty paragraph. 
body.ensureMinimum();

// Now, we can add runs to the body, and get the document to display them.
body.getFirstParagraph().appendChild(new Run(doc, "Hello world!"));

Assert.assertEquals("Hello world!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="Count"><!-- --></A><A NAME="getCount()"><!-- --></A><A NAME="getCount--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCount</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getCount</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the number of immediate children of this node.
            </summary><example><p><b>Example:</b></p>Shows how to add, update and delete child nodes in a CompositeNode's collection of children.<pre>
Document doc = new Document();

// An empty document, by default, has one paragraph.
Assert.assertEquals(1, doc.getFirstSection().getBody().getParagraphs().getCount());

// Composite nodes such as our paragraph can contain other composite and inline nodes as children.
Paragraph paragraph = doc.getFirstSection().getBody().getFirstParagraph();
Run paragraphText = new Run(doc, "Initial text. ");
paragraph.appendChild(paragraphText);

// Create three more run nodes.
Run run1 = new Run(doc, "Run 1. ");
Run run2 = new Run(doc, "Run 2. ");
Run run3 = new Run(doc, "Run 3. ");

// The document body will not display these runs until we insert them into a composite node
// that itself is a part of the document's node tree, as we did with the first run.
// We can determine where the text contents of nodes that we insert
// appears in the document by specifying an insertion location relative to another node in the paragraph.
Assert.assertEquals("Initial text.", paragraph.getText().trim());

// Insert the second run into the paragraph in front of the initial run.
paragraph.insertBefore(run2, paragraphText);

Assert.assertEquals("Run 2. Initial text.", paragraph.getText().trim());

// Insert the third run after the initial run.
paragraph.insertAfter(run3, paragraphText);

Assert.assertEquals("Run 2. Initial text. Run 3.", paragraph.getText().trim());

// Insert the first run to the start of the paragraph's child nodes collection.
paragraph.prependChild(run1);

Assert.assertEquals("Run 1. Run 2. Initial text. Run 3.", paragraph.getText().trim());
Assert.assertEquals(4, paragraph.getChildNodes(NodeType.ANY, true).getCount());

// We can modify the contents of the run by editing and deleting existing child nodes.
((Run) paragraph.getChildNodes(NodeType.RUN, true).get(1)).setText("Updated run 2. ");
paragraph.getChildNodes(NodeType.RUN, true).remove(paragraphText);

Assert.assertEquals("Run 1. Updated run 2. Run 3.", paragraph.getText().trim());
Assert.assertEquals(3, paragraph.getChildNodes(NodeType.ANY, true).getCount());</pre></example>
</DL>
<HR>

<A NAME="CustomNodeId"><!-- --></A><A NAME="getCustomNodeId()"><!-- --></A><A NAME="getCustomNodeId--"><!-- --></A><A NAME="setCustomNodeId(int)"><!-- --></A><A NAME="setCustomNodeId-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCustomNodeId/setCustomNodeId</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getCustomNodeId</B>()&nbsp;/&nbsp;public void&nbsp;<B>setCustomNodeId</B>(int&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Specifies custom node identifier.
            </summary><remarks><p>Default is zero.</p><p>This identifier can be set and used arbitrarily. For example, as a key to get external data.</p><p>Important note, specified value is not saved to an output file and exists only during the node lifetime.</p></remarks><example><p><b>Example:</b></p>Shows how to traverse through a composite node's collection of child nodes.<pre>
Document doc = new Document();

// Add two runs and one shape as child nodes to the first paragraph of this document.
Paragraph paragraph = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 0, true);
paragraph.appendChild(new Run(doc, "Hello world! "));

Shape shape = new Shape(doc, ShapeType.RECTANGLE);
shape.setWidth(200.0);
shape.setHeight(200.0);
// Note that the 'CustomNodeId' is not saved to an output file and exists only during the node lifetime.
shape.setCustomNodeId(100);
shape.setWrapType(WrapType.INLINE);
paragraph.appendChild(shape);

paragraph.appendChild(new Run(doc, "Hello again!"));

// Iterate through the paragraph's collection of immediate children,
// and print any runs or shapes that we find within.
NodeCollection children = paragraph.getChildNodes(NodeType.ANY, false);

Assert.assertEquals(3, paragraph.getChildNodes(NodeType.ANY, false).getCount());

for (Node child : (Iterable&lt;Node&gt;) children)
    switch (child.getNodeType()) {
        case NodeType.RUN:
            System.out.println("Run contents:");
            System.out.println(MessageFormat.format("\t\"{0}\"", child.getText().trim()));
            break;
        case NodeType.SHAPE:
            Shape childShape = (Shape)child;
            System.out.println("Shape:");
            System.out.println(MessageFormat.format("\t{0}, {1}x{2}", childShape.getShapeType(), childShape.getWidth(), childShape.getHeight()));
            break;
    }</pre></example>
</DL>
<HR>

<A NAME="Document"><!-- --></A><A NAME="getDocument()"><!-- --></A><A NAME="getDocument--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getDocument</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A>&nbsp;<B>getDocument</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the document to which this node belongs.
            </summary><remarks><p>The node always belongs to a document even if it has just been created
            and not yet added to the tree, or if it has been removed from the tree.</p></remarks><example><p><b>Example:</b></p>Shows how to create a node and set its owning document.<pre>
Document doc = new Document();
Paragraph para = new Paragraph(doc);
para.appendChild(new Run(doc, "Hello world!"));

// We have not yet appended this paragraph as a child to any composite node.
Assert.assertNull(para.getParentNode());

// If a node is an appropriate child node type of another composite node,
// we can attach it as a child only if both nodes have the same owner document.
// The owner document is the document we passed to the node's constructor.
// We have not attached this paragraph to the document, so the document does not contain its text.
Assert.assertEquals(para.getDocument(), doc);
Assert.assertEquals("", doc.getText().trim());

// Since the document owns this paragraph, we can apply one of its styles to the paragraph's contents.
para.getParagraphFormat().setStyleName("Heading 1");

// Add this node to the document, and then verify its contents.
doc.getFirstSection().getBody().appendChild(para);

Assert.assertEquals(doc.getFirstSection().getBody(), para.getParentNode());
Assert.assertEquals("Hello world!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="FirstChild"><!-- --></A><A NAME="getFirstChild()"><!-- --></A><A NAME="getFirstChild--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFirstChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getFirstChild</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first child of the node.
            </summary><remarks>
            If there is no first child node, a <code>null</code> is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to use a node's NextSibling property to enumerate through its immediate children.<pre>
Document doc = new Document(getMyDir() + "Paragraphs.docx");

for (Node node = doc.getFirstSection().getBody().getFirstChild(); node != null; node = node.getNextSibling()) {
    System.out.println(Node.nodeTypeToString(node.getNodeType()));
}</pre></example><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="HasChildNodes"><!-- --></A><A NAME="hasChildNodes()"><!-- --></A><A NAME="hasChildNodes--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>hasChildNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>hasChildNodes</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns <code>true</code> if this node has any child nodes.
            </summary><example><p><b>Example:</b></p>Shows how to combine the rows from two tables into one.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");

// Below are two ways of getting a table from a document.
// 1 -  From the "Tables" collection of a Body node:
Table firstTable = doc.getFirstSection().getBody().getTables().get(0);

// 2 -  Using the "GetChild" method:
Table secondTable = (Table) doc.getChild(NodeType.TABLE, 1, true);

// Append all rows from the current table to the next.
while (secondTable.hasChildNodes())
    firstTable.getRows().add(secondTable.getFirstRow());

// Remove the empty table container.
secondTable.remove();

doc.save(getArtifactsDir() + "Table.CombineTables.docx");</pre></example>
</DL>
<HR>

<A NAME="HeadersFooters"><!-- --></A><A NAME="getHeadersFooters()"><!-- --></A><A NAME="getHeadersFooters--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getHeadersFooters</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="HeaderFooterCollection.html" title="class in com.aspose.words">HeaderFooterCollection</A>&nbsp;<B>getHeadersFooters</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Provides access to the headers and footers nodes of the section.
            </summary><example><p><b>Example:</b></p>Shows how to replace text in a document's footer.<pre>
Document doc = new Document(getMyDir() + "Footer.docx");

HeaderFooterCollection headersFooters = doc.getFirstSection().getHeadersFooters();
HeaderFooter footer = headersFooters.getByHeaderFooterType(HeaderFooterType.FOOTER_PRIMARY);

FindReplaceOptions options = new FindReplaceOptions();
options.setMatchCase(false);
options.setFindWholeWordsOnly(false);

int currentYear = Calendar.YEAR;
footer.getRange().replace("(C) 2006 Aspose Pty Ltd.", MessageFormat.format("Copyright (C) {0} by Aspose Pty Ltd.", currentYear), options);

doc.save(getArtifactsDir() + "HeaderFooter.ReplaceText.docx");</pre></example><example><p><b>Example:</b></p>Shows how to delete all footers from a document.<pre>
Document doc = new Document(getMyDir() + "Header and footer types.docx");

// Iterate through each section and remove footers of every kind.
for (Section section : doc.getSections()) {
    // There are three kinds of footer and header types.
    // 1 -  The "First" header/footer, which only appears on the first page of a section.
    HeaderFooter footer = section.getHeadersFooters().getByHeaderFooterType(HeaderFooterType.FOOTER_FIRST);
    if (footer != null) {
        footer.remove();
    }

    // 2 -  The "Primary" header/footer, which appears on odd pages.
    footer = section.getHeadersFooters().getByHeaderFooterType(HeaderFooterType.FOOTER_PRIMARY);
    if (footer != null) {
        footer.remove();
    }

    // 3 -  The "Even" header/footer, which appears on even pages.
    footer = section.getHeadersFooters().getByHeaderFooterType(HeaderFooterType.FOOTER_EVEN);
    if (footer != null) {
        footer.remove();
    }

    Assert.assertEquals(0, IterableUtils.countMatches(section.getHeadersFooters(), s -&gt; !s.isHeader()));
}

doc.save(getArtifactsDir() + "HeaderFooter.RemoveFooters.docx");</pre></example>
</DL>
<HR>

<A NAME="IsComposite"><!-- --></A><A NAME="isComposite()"><!-- --></A><A NAME="isComposite--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isComposite</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isComposite</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns <code>true</code> as this node can have child nodes.
            </summary><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="LastChild"><!-- --></A><A NAME="getLastChild()"><!-- --></A><A NAME="getLastChild--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getLastChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getLastChild</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the last child of the node.
            </summary><remarks>
            If there is no last child node, a <code>null</code> is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to use of methods of Node and CompositeNode to remove a section before the last section in the document.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Section 1 text.");
builder.insertBreak(BreakType.SECTION_BREAK_CONTINUOUS);
builder.writeln("Section 2 text.");

// Both sections are siblings of each other.
Section lastSection = (Section) doc.getLastChild();
Section firstSection = (Section) lastSection.getPreviousSibling();

// Remove a section based on its sibling relationship with another section.
if (lastSection.getPreviousSibling() != null)
    doc.removeChild(firstSection);

// The section we removed was the first one, leaving the document with only the second.
Assert.assertEquals("Section 2 text.", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="NextSibling"><!-- --></A><A NAME="getNextSibling()"><!-- --></A><A NAME="getNextSibling--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNextSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getNextSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately following this node.
            </summary><remarks>
            If there is no next node, a <code>null</code> is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to use a node's NextSibling property to enumerate through its immediate children.<pre>
Document doc = new Document(getMyDir() + "Paragraphs.docx");

for (Node node = doc.getFirstSection().getBody().getFirstChild(); node != null; node = node.getNextSibling()) {
    System.out.println(Node.nodeTypeToString(node.getNodeType()));
}</pre></example><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="NodeType"><!-- --></A><A NAME="getNodeType()"><!-- --></A><A NAME="getNodeType--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNodeType</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getNodeType</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns <cref><A HREF="NodeType.html#SECTION" title="field in class com.aspose.words.NodeType">NodeType.SECTION</A></cref>.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</summary><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="PageSetup"><!-- --></A><A NAME="getPageSetup()"><!-- --></A><A NAME="getPageSetup--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPageSetup</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="PageSetup.html" title="class in com.aspose.words">PageSetup</A>&nbsp;<B>getPageSetup</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns an object that represents page setup and section properties.
            </summary><example><p><b>Example:</b></p>Shows how to create a wide blue band border at the top of the first page.<pre>
Document doc = new Document();

PageSetup pageSetup = doc.getSections().get(0).getPageSetup();
pageSetup.setBorderAlwaysInFront(false);
pageSetup.setBorderDistanceFrom(PageBorderDistanceFrom.PAGE_EDGE);
pageSetup.setBorderAppliesTo(PageBorderAppliesTo.FIRST_PAGE);

Border border = pageSetup.getBorders().getByBorderType(BorderType.TOP);
border.setLineStyle(LineStyle.SINGLE);
border.setLineWidth(30.0);
border.setColor(Color.BLUE);
border.setDistanceFromText(0.0);

doc.save(getArtifactsDir() + "PageSetup.PageBorderProperties.docx");</pre></example><example><p><b>Example:</b></p>Shows how to construct an Aspose.Words document by hand.<pre>
Document doc = new Document();

// A blank document contains one section, one body and one paragraph.
// Call the "RemoveAllChildren" method to remove all those nodes,
// and end up with a document node with no children.
doc.removeAllChildren();

// This document now has no composite child nodes that we can add content to.
// If we wish to edit it, we will need to repopulate its node collection.
// First, create a new section, and then append it as a child to the root document node.
Section section = new Section(doc);
doc.appendChild(section);

// Set some page setup properties for the section.
section.getPageSetup().setSectionStart(SectionStart.NEW_PAGE);
section.getPageSetup().setPaperSize(PaperSize.LETTER);

// A section needs a body, which will contain and display all its contents
// on the page between the section's header and footer.
Body body = new Body(doc);
section.appendChild(body);

// Create a paragraph, set some formatting properties, and then append it as a child to the body.
Paragraph para = new Paragraph(doc);

para.getParagraphFormat().setStyleName("Heading 1");
para.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER);

body.appendChild(para);

// Finally, add some content to do the document. Create a run,
// set its appearance and contents, and then append it as a child to the paragraph.
Run run = new Run(doc);
run.setText("Hello World!");
run.getFont().setColor(Color.RED);
para.appendChild(run);

Assert.assertEquals("Hello World!", doc.getText().trim());

doc.save(getArtifactsDir() + "Section.CreateManually.docx");</pre></example>
</DL>
<HR>

<A NAME="ParentNode"><!-- --></A><A NAME="getParentNode()"><!-- --></A><A NAME="getParentNode--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getParentNode</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getParentNode</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the immediate parent of this node.
            </summary><remarks><p>If a node has just been created and not yet added to the tree,
            or if it has been removed from the tree, the parent is <code>null</code>.</p></remarks><example><p><b>Example:</b></p>Shows how to access a node's parent node.<pre>
Document doc = new Document();
Paragraph para = doc.getFirstSection().getBody().getFirstParagraph();

// Append a child Run node to the document's first paragraph.
Run run = new Run(doc, "Hello world!");
para.appendChild(run);

// The paragraph is the parent node of the run node. We can trace this lineage
// all the way to the document node, which is the root of the document's node tree.
Assert.assertEquals(para, run.getParentNode());
Assert.assertEquals(doc.getFirstSection().getBody(), para.getParentNode());
Assert.assertEquals(doc.getFirstSection(), doc.getFirstSection().getBody().getParentNode());
Assert.assertEquals(doc, doc.getFirstSection().getParentNode());</pre></example><example><p><b>Example:</b></p>Shows how to create a node and set its owning document.<pre>
Document doc = new Document();
Paragraph para = new Paragraph(doc);
para.appendChild(new Run(doc, "Hello world!"));

// We have not yet appended this paragraph as a child to any composite node.
Assert.assertNull(para.getParentNode());

// If a node is an appropriate child node type of another composite node,
// we can attach it as a child only if both nodes have the same owner document.
// The owner document is the document we passed to the node's constructor.
// We have not attached this paragraph to the document, so the document does not contain its text.
Assert.assertEquals(para.getDocument(), doc);
Assert.assertEquals("", doc.getText().trim());

// Since the document owns this paragraph, we can apply one of its styles to the paragraph's contents.
para.getParagraphFormat().setStyleName("Heading 1");

// Add this node to the document, and then verify its contents.
doc.getFirstSection().getBody().appendChild(para);

Assert.assertEquals(doc.getFirstSection().getBody(), para.getParentNode());
Assert.assertEquals("Hello world!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="PreviousSibling"><!-- --></A><A NAME="getPreviousSibling()"><!-- --></A><A NAME="getPreviousSibling--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPreviousSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getPreviousSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately preceding this node.
            </summary><remarks>
            If there is no preceding node, a <code>null</code> is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to use of methods of Node and CompositeNode to remove a section before the last section in the document.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Section 1 text.");
builder.insertBreak(BreakType.SECTION_BREAK_CONTINUOUS);
builder.writeln("Section 2 text.");

// Both sections are siblings of each other.
Section lastSection = (Section) doc.getLastChild();
Section firstSection = (Section) lastSection.getPreviousSibling();

// Remove a section based on its sibling relationship with another section.
if (lastSection.getPreviousSibling() != null)
    doc.removeChild(firstSection);

// The section we removed was the first one, leaving the document with only the second.
Assert.assertEquals("Section 2 text.", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="ProtectedForForms"><!-- --></A><A NAME="getProtectedForForms()"><!-- --></A><A NAME="getProtectedForForms--"><!-- --></A><A NAME="setProtectedForForms(boolean)"><!-- --></A><A NAME="setProtectedForForms-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getProtectedForForms/setProtectedForForms</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getProtectedForForms</B>()&nbsp;/&nbsp;public void&nbsp;<B>setProtectedForForms</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            True if the section is protected for forms. When a section is protected for forms,
            users can select and modify text only in form fields in Microsoft Word.
            </summary><example><p><b>Example:</b></p>Shows how to turn off protection for a section.<pre>
Document doc = new Document();

DocumentBuilder builder = new DocumentBuilder(doc);
builder.writeln("Section 1. Hello world!");
builder.insertBreak(BreakType.SECTION_BREAK_NEW_PAGE);

builder.writeln("Section 2. Hello again!");
builder.write("Please enter text here: ");
builder.insertTextInput("TextInput1", TextFormFieldType.REGULAR, "", "Placeholder text", 0);

// Apply write protection to every section in the document.
doc.protect(ProtectionType.ALLOW_ONLY_FORM_FIELDS);

// Turn off write protection for the first section.
doc.getSections().get(0).setProtectedForForms(false);

// In this output document, we will be able to edit the first section freely,
// and we will only be able to edit the contents of the form field in the second section.
doc.save(getArtifactsDir() + "Section.Protect.docx");</pre></example>
</DL>
<HR>

<A NAME="Range"><!-- --></A><A NAME="getRange()"><!-- --></A><A NAME="getRange--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRange</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Range.html" title="class in com.aspose.words">Range</A>&nbsp;<B>getRange</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a <cref><A HREF="Range.html" title="class in com.aspose.words">Range</A></cref> object that represents the portion of a document that is contained in this node.
            </summary><example><p><b>Example:</b></p>Shows how to delete all the nodes from a range.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Add text to the first section in the document, and then add another section.
builder.write("Section 1. ");
builder.insertBreak(BreakType.SECTION_BREAK_CONTINUOUS);
builder.write("Section 2.");

Assert.assertEquals("Section 1. \fSection 2.", doc.getText().trim());

// Remove the first section entirely by removing all the nodes
// within its range, including the section itself.
doc.getSections().get(0).getRange().delete();

Assert.assertEquals(1, doc.getSections().getCount());
Assert.assertEquals("Section 2.", doc.getText().trim());</pre></example>
</DL>
<HR>



<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="accept(com.aspose.words.DocumentVisitor)"><!-- --></A><A NAME="accept-com.aspose.words.DocumentVisitor-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>accept</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>accept</B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)
              throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
Accepts a visitor.
</summary><remarks><p>Enumerates over this node and all of its children. Each node calls a corresponding method on <cref><A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A></cref>.</p><p>For more info see the Visitor design pattern.</p></remarks><remarks>
            Calls <cref><A HREF="DocumentVisitor.html#visitSectionStart(com.aspose.words.Section)" title="method in class com.aspose.words.DocumentVisitor">DocumentVisitor.visitSectionStart(com.aspose.words.Section)</A></cref>, then calls <cref><A HREF="#accept(com.aspose.words.DocumentVisitor)" title="method in class com.aspose.words.Section">accept(com.aspose.words.DocumentVisitor)</A></cref> for all child nodes of the section
            and calls <cref><A HREF="DocumentVisitor.html#visitSectionEnd(com.aspose.words.Section)" title="method in class com.aspose.words.DocumentVisitor">DocumentVisitor.visitSectionEnd(com.aspose.words.Section)</A></cref> at the end.
            </remarks><DL><DT><B>Parameters:</B></DT><DD param="visitor"><CODE>visitor</CODE> - The visitor that will visit the nodes.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">True if all nodes were visited; false if <cref><A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A></cref> stopped the operation before visiting all nodes.</DD></DL><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
</DL>
<HR>

<A NAME="acceptEnd(com.aspose.words.DocumentVisitor)"><!-- --></A><A NAME="acceptEnd-com.aspose.words.DocumentVisitor-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>acceptEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>acceptEnd</B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)
             throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary />
</DL>
<HR>

<A NAME="acceptStart(com.aspose.words.DocumentVisitor)"><!-- --></A><A NAME="acceptStart-com.aspose.words.DocumentVisitor-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>acceptStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>acceptStart</B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary />
</DL>
<HR>

<A NAME="appendContent(com.aspose.words.Section)"><!-- --></A><A NAME="appendContent-com.aspose.words.Section-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>appendContent</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>appendContent</B>(<A HREF="Section.html" title="class in com.aspose.words">Section</A>&nbsp;sourceSection)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Inserts a copy of content of the source section at the end of this section.
            </summary><remarks><p>Only content of <cref><A HREF="#Body" title="property in class com.aspose.words.Section">Body</A></cref> of the source section is copied, page setup,
            headers and footers are not copied.</p><p>The nodes are automatically imported if the source section belongs to a different document.</p><p>No new section is created in the destination document.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="sourceSection"><CODE>sourceSection</CODE> - The section to copy content from.</DD></DL><example><p><b>Example:</b></p>Shows how to append the contents of a section to another section.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.write("Section 1");
builder.insertBreak(BreakType.SECTION_BREAK_NEW_PAGE);
builder.write("Section 2");
builder.insertBreak(BreakType.SECTION_BREAK_NEW_PAGE);
builder.write("Section 3");

Section section = doc.getSections().get(2);

Assert.assertEquals("Section 3" + ControlChar.SECTION_BREAK, section.getText());

// Insert the contents of the first section to the beginning of the third section.
Section sectionToPrepend = doc.getSections().get(0);
section.prependContent(sectionToPrepend);

// Insert the contents of the second section to the end of the third section.
Section sectionToAppend = doc.getSections().get(1);
section.appendContent(sectionToAppend);

// The "PrependContent" and "AppendContent" methods did not create any new sections.
Assert.assertEquals(3, doc.getSections().getCount());
Assert.assertEquals("Section 1" + ControlChar.PARAGRAPH_BREAK +
        "Section 3" + ControlChar.PARAGRAPH_BREAK +
        "Section 2" + ControlChar.SECTION_BREAK, section.getText());</pre></example>
</DL>
<HR>

<A NAME="clearContent()"><!-- --></A><A NAME="clearContent--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>clearContent</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>clearContent</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Clears the section.
            </summary><remarks><p>The text of <cref><A HREF="#Body" title="property in class com.aspose.words.Section">Body</A></cref> is cleared, only one empty paragraph is left that represents the section break.</p><p>The text of all headers and footers is cleared, but <cref><A HREF="HeaderFooter.html" title="class in com.aspose.words">HeaderFooter</A></cref> objects themselves are not removed.</p></remarks><example><p><b>Example:</b></p>Shows how to clear the contents of a section.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.write("Hello world!");

Assert.assertEquals("Hello world!", doc.getText().trim());
Assert.assertEquals(1, doc.getFirstSection().getBody().getParagraphs().getCount());

// Running the "ClearContent" method will remove all the section contents
// but leave a blank paragraph to add content again.
doc.getFirstSection().clearContent();

Assert.assertEquals("", doc.getText().trim());
Assert.assertEquals(1, doc.getFirstSection().getBody().getParagraphs().getCount());</pre></example>
</DL>
<HR>

<A NAME="clearHeadersFooters()"><!-- --></A><A NAME="clearHeadersFooters--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>clearHeadersFooters</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>clearHeadersFooters</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Clears the headers and footers of this section.
            </summary><remarks><p>The text of all headers and footers is cleared, but <cref><A HREF="HeaderFooter.html" title="class in com.aspose.words">HeaderFooter</A></cref> objects themselves are not removed.</p><p>This makes headers and footers of this section linked to headers and footers of the previous section.</p></remarks><example><p><b>Example:</b></p>Shows how to clear the contents of all headers and footers in a section.<pre>
Document doc = new Document();

Assert.assertEquals(0, doc.getFirstSection().getHeadersFooters().getCount());

DocumentBuilder builder = new DocumentBuilder(doc);

builder.moveToHeaderFooter(HeaderFooterType.HEADER_PRIMARY);
builder.writeln("This is the primary header.");
builder.moveToHeaderFooter(HeaderFooterType.FOOTER_PRIMARY);
builder.writeln("This is the primary footer.");

Assert.assertEquals(2, doc.getFirstSection().getHeadersFooters().getCount());

Assert.assertEquals("This is the primary header.", doc.getFirstSection().getHeadersFooters().getByHeaderFooterType(HeaderFooterType.HEADER_PRIMARY).getText().trim());
Assert.assertEquals("This is the primary footer.", doc.getFirstSection().getHeadersFooters().getByHeaderFooterType(HeaderFooterType.FOOTER_PRIMARY).getText().trim());

// Empty all the headers and footers in this section of all their contents.
// The headers and footers themselves will still be present but will have nothing to display.
doc.getFirstSection().clearHeadersFooters();

Assert.assertEquals(2, doc.getFirstSection().getHeadersFooters().getCount());

Assert.assertEquals("", doc.getFirstSection().getHeadersFooters().getByHeaderFooterType(HeaderFooterType.HEADER_PRIMARY).getText().trim());
Assert.assertEquals("", doc.getFirstSection().getHeadersFooters().getByHeaderFooterType(HeaderFooterType.FOOTER_PRIMARY).getText().trim());</pre></example>
</DL>
<HR>

<A NAME="clearHeadersFooters(boolean)"><!-- --></A><A NAME="clearHeadersFooters-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>clearHeadersFooters</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>clearHeadersFooters</B>(boolean&nbsp;preserveWatermarks)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Clears the headers and footers of this section.
            </summary><remarks><p>The text of all headers and footers is cleared, but <cref><A HREF="HeaderFooter.html" title="class in com.aspose.words">HeaderFooter</A></cref> objects themselves are not removed.</p><p>This makes headers and footers of this section linked to headers and footers of the previous section.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="preserveWatermarks"><CODE>preserveWatermarks</CODE> - True if the watermarks shall not be removed.</DD></DL><example><p><b>Example:</b></p>Shows how to clear the contents of header and footer with or without a watermark.<pre>
Document doc = new Document(getMyDir() + "Header and footer types.docx");

// Add a plain text watermark.
doc.getWatermark().setText("Aspose Watermark");

// Make sure the headers and footers have content.
HeaderFooterCollection headersFooters = doc.getFirstSection().getHeadersFooters();
Assert.assertEquals("First header", headersFooters.getByHeaderFooterType(HeaderFooterType.HEADER_FIRST).getText().trim());
Assert.assertEquals("Second header", headersFooters.getByHeaderFooterType(HeaderFooterType.HEADER_EVEN).getText().trim());
Assert.assertEquals("Third header", headersFooters.getByHeaderFooterType(HeaderFooterType.HEADER_PRIMARY).getText().trim());
Assert.assertEquals("First footer", headersFooters.getByHeaderFooterType(HeaderFooterType.FOOTER_FIRST).getText().trim());
Assert.assertEquals("Second footer", headersFooters.getByHeaderFooterType(HeaderFooterType.FOOTER_EVEN).getText().trim());
Assert.assertEquals("Third footer", headersFooters.getByHeaderFooterType(HeaderFooterType.FOOTER_PRIMARY).getText().trim());

// Removes all header and footer content except watermarks.
doc.getFirstSection().clearHeadersFooters(true);

headersFooters = doc.getFirstSection().getHeadersFooters();
Assert.assertEquals("", headersFooters.getByHeaderFooterType(HeaderFooterType.HEADER_FIRST).getText().trim());
Assert.assertEquals("", headersFooters.getByHeaderFooterType(HeaderFooterType.HEADER_EVEN).getText().trim());
Assert.assertEquals("", headersFooters.getByHeaderFooterType(HeaderFooterType.HEADER_PRIMARY).getText().trim());
Assert.assertEquals("", headersFooters.getByHeaderFooterType(HeaderFooterType.FOOTER_FIRST).getText().trim());
Assert.assertEquals("", headersFooters.getByHeaderFooterType(HeaderFooterType.FOOTER_EVEN).getText().trim());
Assert.assertEquals("", headersFooters.getByHeaderFooterType(HeaderFooterType.FOOTER_PRIMARY).getText().trim());
Assert.assertEquals(WatermarkType.TEXT, doc.getWatermark().getType());

// Removes all header and footer content including watermarks.
doc.getFirstSection().clearHeadersFooters(false);
Assert.assertEquals(WatermarkType.NONE, doc.getWatermark().getType());</pre></example>
</DL>
<HR>

<A NAME="deepClone()"><!-- --></A><A NAME="deepClone--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>deepClone</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Section.html" title="class in com.aspose.words">Section</A>&nbsp;<B>deepClone</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Creates a duplicate of this section.
            </summary><example><p><b>Example:</b></p>Shows how to add and remove sections in a document.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.write("Section 1");
builder.insertBreak(BreakType.SECTION_BREAK_NEW_PAGE);
builder.write("Section 2");

Assert.assertEquals("Section 1\fSection 2", doc.getText().trim());

// Delete the first section from the document.
doc.getSections().removeAt(0);

Assert.assertEquals("Section 2", doc.getText().trim());

// Append a copy of what is now the first section to the end of the document.
int lastSectionIdx = doc.getSections().getCount() - 1;
Section newSection = doc.getSections().get(lastSectionIdx).deepClone();
doc.getSections().add(newSection);

Assert.assertEquals("Section 2\fSection 2", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="deepClone(boolean)"><!-- --></A><A NAME="deepClone-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>deepClone</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>deepClone</B>(boolean&nbsp;isCloneChildren)</PRE></TD></TR></TABLE>
<DL><DD><summary>
Creates a duplicate of the node.
</summary><remarks><p>This method serves as a copy constructor for nodes. 
The cloned node has no parent, but belongs to the same document as the original node.</p><p>This method always performs a deep copy of the node. The <i>isCloneChildren</i> parameter
specifies whether to perform copy all child nodes as well.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="isCloneChildren"><CODE>isCloneChildren</CODE> - True to recursively clone the subtree under the specified node; 
false to clone only the node itself.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The cloned node.</DD></DL><example><p><b>Example:</b></p>Shows how to clone a composite node.<pre>
Document doc = new Document();
Paragraph para = doc.getFirstSection().getBody().getFirstParagraph();
para.appendChild(new Run(doc, "Hello world!"));

// Below are two ways of cloning a composite node.
// 1 -  Create a clone of a node, and create a clone of each of its child nodes as well.
Node cloneWithChildren = para.deepClone(true);

Assert.assertTrue(((CompositeNode) cloneWithChildren).hasChildNodes());
Assert.assertEquals("Hello world!", cloneWithChildren.getText().trim());

// 2 -  Create a clone of a node just by itself without any children.
Node cloneWithoutChildren = para.deepClone(false);

Assert.assertFalse(((CompositeNode) cloneWithoutChildren).hasChildNodes());
Assert.assertEquals("", cloneWithoutChildren.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="deleteHeaderFooterShapes()"><!-- --></A><A NAME="deleteHeaderFooterShapes--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>deleteHeaderFooterShapes</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>deleteHeaderFooterShapes</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Deletes all shapes (drawing objects) from the headers and footers of this section.
            </summary><example><p><b>Example:</b></p>Shows how to remove all shapes from all headers footers in a section.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create a primary header with a shape.
builder.moveToHeaderFooter(HeaderFooterType.HEADER_PRIMARY);
builder.insertShape(ShapeType.RECTANGLE, 100.0, 100.0);

// Create a primary footer with an image.
builder.moveToHeaderFooter(HeaderFooterType.FOOTER_PRIMARY);
builder.insertImage(getImageDir() + "Logo Icon.ico");

Assert.assertEquals(1, doc.getFirstSection().getHeadersFooters().getByHeaderFooterType(HeaderFooterType.HEADER_PRIMARY).getChildNodes(NodeType.SHAPE, true).getCount());
Assert.assertEquals(1, doc.getFirstSection().getHeadersFooters().getByHeaderFooterType(HeaderFooterType.FOOTER_PRIMARY).getChildNodes(NodeType.SHAPE, true).getCount());

// Remove all shapes from the headers and footers in the first section.
doc.getFirstSection().deleteHeaderFooterShapes();

Assert.assertEquals(0, doc.getFirstSection().getHeadersFooters().getByHeaderFooterType(HeaderFooterType.HEADER_PRIMARY).getChildNodes(NodeType.SHAPE, true).getCount());
Assert.assertEquals(0, doc.getFirstSection().getHeadersFooters().getByHeaderFooterType(HeaderFooterType.FOOTER_PRIMARY).getChildNodes(NodeType.SHAPE, true).getCount());</pre></example>
</DL>
<HR>

<A NAME="ensureMinimum()"><!-- --></A><A NAME="ensureMinimum--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>ensureMinimum</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>ensureMinimum</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Ensures that the section has <cref><A HREF="#Body" title="property in class com.aspose.words.Section">Body</A></cref> with one <cref><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></cref>.
            </summary><example><p><b>Example:</b></p>Shows how to prepare a new section node for editing.<pre>
Document doc = new Document();

// A blank document comes with a section, which has a body, which in turn has a paragraph.
// We can add contents to this document by adding elements such as text runs, shapes, or tables to that paragraph.
Assert.assertEquals(NodeType.SECTION, doc.getChild(NodeType.ANY, 0, true).getNodeType());
Assert.assertEquals(NodeType.BODY, doc.getSections().get(0).getChild(NodeType.ANY, 0, true).getNodeType());
Assert.assertEquals(NodeType.PARAGRAPH, doc.getSections().get(0).getBody().getChild(NodeType.ANY, 0, true).getNodeType());

// If we add a new section like this, it will not have a body, or any other child nodes.
doc.getSections().add(new Section(doc));

Assert.assertEquals(0, doc.getSections().get(1).getChildNodes(NodeType.ANY, true).getCount());

// Run the "EnsureMinimum" method to add a body and a paragraph to this section to begin editing it.
doc.getLastSection().ensureMinimum();

Assert.assertEquals(NodeType.BODY, doc.getSections().get(1).getChild(NodeType.ANY, 0, true).getNodeType());
Assert.assertEquals(NodeType.PARAGRAPH, doc.getSections().get(1).getBody().getChild(NodeType.ANY, 0, true).getNodeType());

doc.getSections().get(0).getBody().getFirstParagraph().appendChild(new Run(doc, "Hello world!"));

Assert.assertEquals("Hello world!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="getAncestor(int)"><!-- --></A><A NAME="getAncestor-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(int&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. The node type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or <code>null</code> if no ancestor of this type was found.</DD></DL><example><p><b>Example:</b></p>Shows how to find out if a tables are nested.<pre>
public void calculateDepthOfNestedTables() throws Exception {
    Document doc = new Document(getMyDir() + "Nested tables.docx");
    NodeCollection tables = doc.getChildNodes(NodeType.TABLE, true);
    for (int i = 0; i &lt; tables.getCount(); i++) {
        Table table = (Table) tables.get(i);

        // Find out if any cells in the table have other tables as children.
        int count = getChildTableCount(table);
        System.out.print(MessageFormat.format("Table #{0} has {1} tables directly within its cells", i, count));

        // Find out if the table is nested inside another table, and, if so, at what depth.
        int tableDepth = getNestedDepthOfTable(table);

        if (tableDepth &gt; 0)
            System.out.println(MessageFormat.format("Table #{0} is nested inside another table at depth of {1}", i, tableDepth));
        else
            System.out.println(MessageFormat.format("Table #{0} is a non nested table (is not a child of another table)", i));
    }
}

// Calculates what level a table is nested inside other tables.
//
// Returns An integer containing the level the table is nested at.
// 0 = Table is not nested inside any other table
// 1 = Table is nested within one parent table
// 2 = Table is nested within two parent tables etc..
private static int getNestedDepthOfTable(final Table table) {
    int depth = 0;
    Node parent = table.getAncestor(table.getNodeType());

    while (parent != null) {
        depth++;
        parent = parent.getAncestor(Table.class);
    }

    return depth;
}

// Determines if a table contains any immediate child table within its cells.
// Does not recursively traverse through those tables to check for further tables.
//
// Returns true if at least one child cell contains a table.
// Returns false if no cells in the table contains a table.
private static int getChildTableCount(final Table table) {
    int childTableCount = 0;

    for (Row row : table.getRows()) {
        for (Cell cell : row.getCells()) {
            TableCollection childTables = cell.getTables();

            if (childTables.getCount() &gt; 0) childTableCount++;
        }
    }

    return childTableCount;
}</pre></example>
</DL>
<HR>

<A NAME="getAncestor(java.lang.Class)"><!-- --></A><A NAME="getAncestor-java.lang.Class-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(java.lang.Class&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified object type.
            </summary><remarks><p>The ancestor type matches if it is equal to <i>ancestorType</i> or derived from <i>ancestorType</i>.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - The object type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or <code>null</code> if no ancestor of this type was found.</DD></DL><example><p><b>Example:</b></p>Shows how to find out if a tables are nested.<pre>
public void calculateDepthOfNestedTables() throws Exception {
    Document doc = new Document(getMyDir() + "Nested tables.docx");
    NodeCollection tables = doc.getChildNodes(NodeType.TABLE, true);
    for (int i = 0; i &lt; tables.getCount(); i++) {
        Table table = (Table) tables.get(i);

        // Find out if any cells in the table have other tables as children.
        int count = getChildTableCount(table);
        System.out.print(MessageFormat.format("Table #{0} has {1} tables directly within its cells", i, count));

        // Find out if the table is nested inside another table, and, if so, at what depth.
        int tableDepth = getNestedDepthOfTable(table);

        if (tableDepth &gt; 0)
            System.out.println(MessageFormat.format("Table #{0} is nested inside another table at depth of {1}", i, tableDepth));
        else
            System.out.println(MessageFormat.format("Table #{0} is a non nested table (is not a child of another table)", i));
    }
}

// Calculates what level a table is nested inside other tables.
//
// Returns An integer containing the level the table is nested at.
// 0 = Table is not nested inside any other table
// 1 = Table is nested within one parent table
// 2 = Table is nested within two parent tables etc..
private static int getNestedDepthOfTable(final Table table) {
    int depth = 0;
    Node parent = table.getAncestor(table.getNodeType());

    while (parent != null) {
        depth++;
        parent = parent.getAncestor(Table.class);
    }

    return depth;
}

// Determines if a table contains any immediate child table within its cells.
// Does not recursively traverse through those tables to check for further tables.
//
// Returns true if at least one child cell contains a table.
// Returns false if no cells in the table contains a table.
private static int getChildTableCount(final Table table) {
    int childTableCount = 0;

    for (Row row : table.getRows()) {
        for (Cell cell : row.getCells()) {
            TableCollection childTables = cell.getTables();

            if (childTables.getCount() &gt; 0) childTableCount++;
        }
    }

    return childTableCount;
}</pre></example>
</DL>
<HR>

<A NAME="getChild(int,int,boolean)"><!-- --></A><A NAME="getChild-int-int-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getChild</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getChild</B>(int&nbsp;nodeType, int&nbsp;index, boolean&nbsp;isDeep)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns an Nth child node that matches the specified type.
            </summary><remarks><p>If index is out of range, a <code>null</code> is returned.</p></remarks><remarks>Note that markup nodes (<cref><A HREF="NodeType.html#STRUCTURED_DOCUMENT_TAG" title="field in class com.aspose.words.NodeType">NodeType.STRUCTURED_DOCUMENT_TAG</A></cref> and <cref><A HREF="NodeType.html#SMART_TAG" title="field in class com.aspose.words.NodeType">NodeType.SMART_TAG</A></cref>)
            are traversed even when <i>isDeep</i> = <code>false</code> and <cref><A HREF="#getChild(int,int,boolean)" title="method in class com.aspose.words.Section">getChild(int,int,boolean)</A></cref> is invoked for non-markup node type. For example if the first run in a para
            is wrapped in a <cref><A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A></cref>, it will still be returned by <cref><A HREF="#getChild(int,int,boolean)" title="method in class com.aspose.words.Section">getChild(int,int,boolean)</A></cref>(<cref><A HREF="NodeType.html#RUN" title="field in class com.aspose.words.NodeType">NodeType.RUN</A></cref>, 0, <code>false</code>).</remarks><DL><DT><B>Parameters:</B></DT><DD param="nodeType"><CODE>nodeType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. Specifies the type of the child node.</DD><DD param="index"><CODE>index</CODE> - Zero based index of the child node to select.
            Negative indexes are also allowed and indicate access from the end,
            that is -1 means the last node.</DD><DD param="isDeep"><CODE>isDeep</CODE> - <code>true</code> to select from all child nodes recursively;
            <code>false</code> to select only among immediate children. See remarks for more info.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The child node that matches the criteria or <code>null</code> if no matching node is found.</DD></DL><example><p><b>Example:</b></p>Shows how to traverse through a composite node's collection of child nodes.<pre>
Document doc = new Document();

// Add two runs and one shape as child nodes to the first paragraph of this document.
Paragraph paragraph = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 0, true);
paragraph.appendChild(new Run(doc, "Hello world! "));

Shape shape = new Shape(doc, ShapeType.RECTANGLE);
shape.setWidth(200.0);
shape.setHeight(200.0);
// Note that the 'CustomNodeId' is not saved to an output file and exists only during the node lifetime.
shape.setCustomNodeId(100);
shape.setWrapType(WrapType.INLINE);
paragraph.appendChild(shape);

paragraph.appendChild(new Run(doc, "Hello again!"));

// Iterate through the paragraph's collection of immediate children,
// and print any runs or shapes that we find within.
NodeCollection children = paragraph.getChildNodes(NodeType.ANY, false);

Assert.assertEquals(3, paragraph.getChildNodes(NodeType.ANY, false).getCount());

for (Node child : (Iterable&lt;Node&gt;) children)
    switch (child.getNodeType()) {
        case NodeType.RUN:
            System.out.println("Run contents:");
            System.out.println(MessageFormat.format("\t\"{0}\"", child.getText().trim()));
            break;
        case NodeType.SHAPE:
            Shape childShape = (Shape)child;
            System.out.println("Shape:");
            System.out.println(MessageFormat.format("\t{0}, {1}x{2}", childShape.getShapeType(), childShape.getWidth(), childShape.getHeight()));
            break;
    }</pre></example><example><p><b>Example:</b></p>Shows how to apply the properties of a table's style directly to the table's elements.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

Table table = builder.startTable();
builder.insertCell();
builder.write("Hello world!");
builder.endTable();

TableStyle tableStyle = (TableStyle) doc.getStyles().add(StyleType.TABLE, "MyTableStyle1");
tableStyle.setRowStripe(3);
tableStyle.setCellSpacing(5.0);
tableStyle.getShading().setBackgroundPatternColor(Color.WHITE);
tableStyle.getBorders().setColor(Color.BLUE);
tableStyle.getBorders().setLineStyle(LineStyle.DOT_DASH);

table.setStyle(tableStyle);

// This method concerns table style properties such as the ones we set above.
doc.expandTableStylesToDirectFormatting();

doc.save(getArtifactsDir() + "Document.TableStyleToDirectFormatting.docx");</pre></example>
</DL>
<HR>

<A NAME="getChildNodes(int,boolean)"><!-- --></A><A NAME="getChildNodes-int-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getChildNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="NodeCollection.html" title="class in com.aspose.words">NodeCollection</A>&nbsp;<B>getChildNodes</B>(int&nbsp;nodeType, boolean&nbsp;isDeep)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a live collection of child nodes that match the specified type.
            </summary><remarks><p>The collection of nodes returned by this method is always live.</p></remarks><remarks><p>A live collection is always in sync with the document. For example, if you
selected all sections in a document and enumerate through the collection
deleting the sections, the section is removed from the collection immediately
when it is removed from the document.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="nodeType"><CODE>nodeType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. Specifies the type of nodes to select.</DD><DD param="isDeep"><CODE>isDeep</CODE> - <code>true</code> to select from all child nodes recursively;
            <code>false</code> to select only among immediate children. </DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A live collection of child nodes of the specified type.</DD></DL><example><p><b>Example:</b></p>Shows how to add, update and delete child nodes in a CompositeNode's collection of children.<pre>
Document doc = new Document();

// An empty document, by default, has one paragraph.
Assert.assertEquals(1, doc.getFirstSection().getBody().getParagraphs().getCount());

// Composite nodes such as our paragraph can contain other composite and inline nodes as children.
Paragraph paragraph = doc.getFirstSection().getBody().getFirstParagraph();
Run paragraphText = new Run(doc, "Initial text. ");
paragraph.appendChild(paragraphText);

// Create three more run nodes.
Run run1 = new Run(doc, "Run 1. ");
Run run2 = new Run(doc, "Run 2. ");
Run run3 = new Run(doc, "Run 3. ");

// The document body will not display these runs until we insert them into a composite node
// that itself is a part of the document's node tree, as we did with the first run.
// We can determine where the text contents of nodes that we insert
// appears in the document by specifying an insertion location relative to another node in the paragraph.
Assert.assertEquals("Initial text.", paragraph.getText().trim());

// Insert the second run into the paragraph in front of the initial run.
paragraph.insertBefore(run2, paragraphText);

Assert.assertEquals("Run 2. Initial text.", paragraph.getText().trim());

// Insert the third run after the initial run.
paragraph.insertAfter(run3, paragraphText);

Assert.assertEquals("Run 2. Initial text. Run 3.", paragraph.getText().trim());

// Insert the first run to the start of the paragraph's child nodes collection.
paragraph.prependChild(run1);

Assert.assertEquals("Run 1. Run 2. Initial text. Run 3.", paragraph.getText().trim());
Assert.assertEquals(4, paragraph.getChildNodes(NodeType.ANY, true).getCount());

// We can modify the contents of the run by editing and deleting existing child nodes.
((Run) paragraph.getChildNodes(NodeType.RUN, true).get(1)).setText("Updated run 2. ");
paragraph.getChildNodes(NodeType.RUN, true).remove(paragraphText);

Assert.assertEquals("Run 1. Updated run 2. Run 3.", paragraph.getText().trim());
Assert.assertEquals(3, paragraph.getChildNodes(NodeType.ANY, true).getCount());</pre></example><example><p><b>Example:</b></p>Shows how to traverse through a composite node's collection of child nodes.<pre>
Document doc = new Document();

// Add two runs and one shape as child nodes to the first paragraph of this document.
Paragraph paragraph = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 0, true);
paragraph.appendChild(new Run(doc, "Hello world! "));

Shape shape = new Shape(doc, ShapeType.RECTANGLE);
shape.setWidth(200.0);
shape.setHeight(200.0);
// Note that the 'CustomNodeId' is not saved to an output file and exists only during the node lifetime.
shape.setCustomNodeId(100);
shape.setWrapType(WrapType.INLINE);
paragraph.appendChild(shape);

paragraph.appendChild(new Run(doc, "Hello again!"));

// Iterate through the paragraph's collection of immediate children,
// and print any runs or shapes that we find within.
NodeCollection children = paragraph.getChildNodes(NodeType.ANY, false);

Assert.assertEquals(3, paragraph.getChildNodes(NodeType.ANY, false).getCount());

for (Node child : (Iterable&lt;Node&gt;) children)
    switch (child.getNodeType()) {
        case NodeType.RUN:
            System.out.println("Run contents:");
            System.out.println(MessageFormat.format("\t\"{0}\"", child.getText().trim()));
            break;
        case NodeType.SHAPE:
            Shape childShape = (Shape)child;
            System.out.println("Shape:");
            System.out.println(MessageFormat.format("\t{0}, {1}x{2}", childShape.getShapeType(), childShape.getWidth(), childShape.getHeight()));
            break;
    }</pre></example><example><p><b>Example:</b></p>Shows how to extract images from a document, and save them to the local file system as individual files.<pre>
Document doc = new Document(getMyDir() + "Images.docx");

// Get the collection of shapes from the document,
// and save the image data of every shape with an image as a file to the local file system.
NodeCollection shapes = doc.getChildNodes(NodeType.SHAPE, true);

int imageIndex = 0;
for (Shape shape : (Iterable&lt;Shape&gt;) shapes) {
    if (shape.hasImage()) {
        // The image data of shapes may contain images of many possible image formats. 
        // We can determine a file extension for each image automatically, based on its format.
        String imageFileName = MessageFormat.format("File.ExtractImages.{0}{1}", imageIndex, FileFormatUtil.imageTypeToExtension(shape.getImageData().getImageType()));
        shape.getImageData().save(getArtifactsDir() + imageFileName);
        imageIndex++;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to print all of a document's comments and their replies.<pre>
Document doc = new Document(getMyDir() + "Comments.docx");

NodeCollection comments = doc.getChildNodes(NodeType.COMMENT, true);
// If a comment has no ancestor, it is a "top-level" comment as opposed to a reply-type comment.
// Print all top-level comments along with any replies they may have.
for (Comment comment : (Iterable&lt;Comment&gt;) comments) {
    if (comment.getAncestor() == null) {
        System.out.println("Top-level comment:");
        System.out.println("\t\"{comment.GetText().Trim()}\", by {comment.Author}");
        System.out.println("Has {comment.Replies.Count} replies");
        for (Comment commentReply : comment.getReplies()) {
            System.out.println("\t\"{commentReply.GetText().Trim()}\", by {commentReply.Author}");
        }
        System.out.println();
    }
}</pre></example>
</DL>
<HR>

<A NAME="getText()"><!-- --></A><A NAME="getText--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getText</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getText</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Gets the text of this node and of all its children.
             </summary><remarks><p>The returned string includes all control and special characters as described in <cref><A HREF="ControlChar.html" title="class in com.aspose.words">ControlChar</A></cref>.</p></remarks><example><p><b>Example:</b></p>Shows how to output all paragraphs in a document that are list items.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.getListFormat().applyNumberDefault();
builder.writeln("Numbered list item 1");
builder.writeln("Numbered list item 2");
builder.writeln("Numbered list item 3");
builder.getListFormat().removeNumbers();

builder.getListFormat().applyBulletDefault();
builder.writeln("Bulleted list item 1");
builder.writeln("Bulleted list item 2");
builder.writeln("Bulleted list item 3");
builder.getListFormat().removeNumbers();

NodeCollection paras = doc.getChildNodes(NodeType.PARAGRAPH, true);
for (Paragraph para : (Iterable&lt;Paragraph&gt;) paras) {
    if (para.getListFormat().isListItem()) {
        System.out.println(java.text.MessageFormat.format("*** A paragraph belongs to list {0}", para.getListFormat().getList().getListId()));
        System.out.println(para.getText());
    }
}</pre></example><example><p><b>Example:</b></p>Shows the difference between calling the GetText and ToString methods on a node.<pre>
Document doc = new Document();

DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField("MERGEFIELD Field");

// GetText will retrieve the visible text as well as field codes and special characters.
Assert.assertEquals("\u0013MERGEFIELD Field\u0014«Field»\u0015\f", doc.getText());

// ToString will give us the document's appearance if saved to a passed save format.
Assert.assertEquals("«Field»\r\n", doc.toString(SaveFormat.TEXT));</pre></example>
</DL>
<HR>

<A NAME="indexOf(com.aspose.words.Node)"><!-- --></A><A NAME="indexOf-com.aspose.words.Node-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>indexOf</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>indexOf</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;child)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns the index of the specified child node in the child node array.
            </summary><remarks>
            Returns -1 if the node is not found in the child nodes.
            </remarks><example><p><b>Example:</b></p>Shows how to get the index of a given child node from its parent.<pre>
Document doc = new Document(getMyDir() + "Rendering.docx");

Body body = doc.getFirstSection().getBody();

// Retrieve the index of the last paragraph in the body of the first section.
Assert.assertEquals(24, body.getChildNodes(NodeType.ANY, false).indexOf(body.getLastParagraph()));</pre></example>
</DL>
<HR>

<A NAME="iterator()"><!-- --></A><A NAME="iterator--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>iterator</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.util.Iterator&lt;<A HREF="Node.html" title="class in com.aspose.words">Node</A>&gt;&nbsp;<B>iterator</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Provides support for the for each style iteration over the child nodes of this node.
            </summary><example><p><b>Example:</b></p>Shows how to print all of a document's comments and their replies.<pre>
Document doc = new Document(getMyDir() + "Comments.docx");

NodeCollection comments = doc.getChildNodes(NodeType.COMMENT, true);
// If a comment has no ancestor, it is a "top-level" comment as opposed to a reply-type comment.
// Print all top-level comments along with any replies they may have.
for (Comment comment : (Iterable&lt;Comment&gt;) comments) {
    if (comment.getAncestor() == null) {
        System.out.println("Top-level comment:");
        System.out.println("\t\"{comment.GetText().Trim()}\", by {comment.Author}");
        System.out.println("Has {comment.Replies.Count} replies");
        for (Comment commentReply : comment.getReplies()) {
            System.out.println("\t\"{commentReply.GetText().Trim()}\", by {commentReply.Author}");
        }
        System.out.println();
    }
}</pre></example>
</DL>
<HR>

<A NAME="nextPreOrder(com.aspose.words.Node)"><!-- --></A><A NAME="nextPreOrder-com.aspose.words.Node-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>nextPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>nextPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets next node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Next node in pre-order order. Null if reached the <i>rootNode</i>.</DD></DL><example><p><b>Example:</b></p>Shows how to traverse the document's node tree using the pre-order traversal algorithm, and delete any encountered shape with an image.<pre>
Document doc = new Document(getMyDir() + "Images.docx");
ArrayList&lt;Shape&gt; shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(9, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));

Node curNode = doc;
while (curNode != null) {
    Node nextNode = curNode.nextPreOrder(doc);

    if (curNode.previousPreOrder(doc) != null &amp;&amp; nextNode != null)
        Assert.assertEquals(curNode, nextNode.previousPreOrder(doc));

    if (curNode.getNodeType() == NodeType.SHAPE &amp;&amp; ((Shape) curNode).hasImage())
        curNode.remove();

    curNode = nextNode;
}

shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(0, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));</pre></example>
</DL>
<HR>

<A NAME="prependContent(com.aspose.words.Section)"><!-- --></A><A NAME="prependContent-com.aspose.words.Section-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>prependContent</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>prependContent</B>(<A HREF="Section.html" title="class in com.aspose.words">Section</A>&nbsp;sourceSection)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Inserts a copy of content of the source section at the beginning of this section.
            </summary><remarks><p>Only content of <cref><A HREF="#Body" title="property in class com.aspose.words.Section">Body</A></cref> of the source section is copied, page setup,
            headers and footers are not copied.</p><p>The nodes are automatically imported if the source section belongs to a different document.</p><p>No new section is created in the destination document.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="sourceSection"><CODE>sourceSection</CODE> - The section to copy content from.</DD></DL><example><p><b>Example:</b></p>Shows how to append the contents of a section to another section.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.write("Section 1");
builder.insertBreak(BreakType.SECTION_BREAK_NEW_PAGE);
builder.write("Section 2");
builder.insertBreak(BreakType.SECTION_BREAK_NEW_PAGE);
builder.write("Section 3");

Section section = doc.getSections().get(2);

Assert.assertEquals("Section 3" + ControlChar.SECTION_BREAK, section.getText());

// Insert the contents of the first section to the beginning of the third section.
Section sectionToPrepend = doc.getSections().get(0);
section.prependContent(sectionToPrepend);

// Insert the contents of the second section to the end of the third section.
Section sectionToAppend = doc.getSections().get(1);
section.appendContent(sectionToAppend);

// The "PrependContent" and "AppendContent" methods did not create any new sections.
Assert.assertEquals(3, doc.getSections().getCount());
Assert.assertEquals("Section 1" + ControlChar.PARAGRAPH_BREAK +
        "Section 3" + ControlChar.PARAGRAPH_BREAK +
        "Section 2" + ControlChar.SECTION_BREAK, section.getText());</pre></example>
</DL>
<HR>

<A NAME="previousPreOrder(com.aspose.words.Node)"><!-- --></A><A NAME="previousPreOrder-com.aspose.words.Node-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>previousPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>previousPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the previous node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Previous node in pre-order order. Null if reached the <i>rootNode</i>.</DD></DL><example><p><b>Example:</b></p>Shows how to traverse the document's node tree using the pre-order traversal algorithm, and delete any encountered shape with an image.<pre>
Document doc = new Document(getMyDir() + "Images.docx");
ArrayList&lt;Shape&gt; shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(9, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));

Node curNode = doc;
while (curNode != null) {
    Node nextNode = curNode.nextPreOrder(doc);

    if (curNode.previousPreOrder(doc) != null &amp;&amp; nextNode != null)
        Assert.assertEquals(curNode, nextNode.previousPreOrder(doc));

    if (curNode.getNodeType() == NodeType.SHAPE &amp;&amp; ((Shape) curNode).hasImage())
        curNode.remove();

    curNode = nextNode;
}

shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(0, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));</pre></example>
</DL>
<HR>

<A NAME="remove()"><!-- --></A><A NAME="remove--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>remove</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>remove</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes itself from the parent.
            </summary><example><p><b>Example:</b></p>Shows how to delete all shapes with images from a document.<pre>
Document doc = new Document(getMyDir() + "Images.docx");
ArrayList&lt;Shape&gt; shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(9, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));

for (Shape shape : shapes)
    if (shape.hasImage())
        shape.remove();

shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(0, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));</pre></example><example><p><b>Example:</b></p>Shows how to remove all child nodes of a specific type from a composite node.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");

Assert.assertEquals(2, doc.getChildNodes(NodeType.TABLE, true).getCount());

Node curNode = doc.getFirstSection().getBody().getFirstChild();

while (curNode != null) {
    // Save the next sibling node as a variable in case we want to move to it after deleting this node.
    Node nextNode = curNode.getNextSibling();

    // A section body can contain Paragraph and Table nodes.
    // If the node is a Table, remove it from the parent.
    if (curNode.getNodeType() == NodeType.TABLE) {
        curNode.remove();
    }

    curNode = nextNode;
}

Assert.assertEquals(0, doc.getChildNodes(NodeType.TABLE, true).getCount());</pre></example>
</DL>
<HR>

<A NAME="removeAllChildren()"><!-- --></A><A NAME="removeAllChildren--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>removeAllChildren</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>removeAllChildren</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes all the child nodes of the current node.
            </summary><example><p><b>Example:</b></p>Shows how to construct an Aspose.Words document by hand.<pre>
Document doc = new Document();

// A blank document contains one section, one body and one paragraph.
// Call the "RemoveAllChildren" method to remove all those nodes,
// and end up with a document node with no children.
doc.removeAllChildren();

// This document now has no composite child nodes that we can add content to.
// If we wish to edit it, we will need to repopulate its node collection.
// First, create a new section, and then append it as a child to the root document node.
Section section = new Section(doc);
doc.appendChild(section);

// Set some page setup properties for the section.
section.getPageSetup().setSectionStart(SectionStart.NEW_PAGE);
section.getPageSetup().setPaperSize(PaperSize.LETTER);

// A section needs a body, which will contain and display all its contents
// on the page between the section's header and footer.
Body body = new Body(doc);
section.appendChild(body);

// Create a paragraph, set some formatting properties, and then append it as a child to the body.
Paragraph para = new Paragraph(doc);

para.getParagraphFormat().setStyleName("Heading 1");
para.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER);

body.appendChild(para);

// Finally, add some content to do the document. Create a run,
// set its appearance and contents, and then append it as a child to the paragraph.
Run run = new Run(doc);
run.setText("Hello World!");
run.getFont().setColor(Color.RED);
para.appendChild(run);

Assert.assertEquals("Hello World!", doc.getText().trim());

doc.save(getArtifactsDir() + "Section.CreateManually.docx");</pre></example>
</DL>
<HR>

<A NAME="removeSmartTags()"><!-- --></A><A NAME="removeSmartTags--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>removeSmartTags</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>removeSmartTags</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes all <cref><A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A></cref> descendant nodes of the current node.
            </summary><remarks>This method does not remove the content of the smart tags.</remarks><example><p><b>Example:</b></p>Shows how to create smart tags.<pre>
public void create() throws Exception {
    Document doc = new Document();

    // A smart tag appears in a document with Microsoft Word recognizes a part of its text as some form of data,
    // such as a name, date, or address, and converts it to a hyperlink that displays a purple dotted underline.
    SmartTag smartTag = new SmartTag(doc);

    // Smart tags are composite nodes that contain their recognized text in its entirety.
    // Add contents to this smart tag manually.
    smartTag.appendChild(new Run(doc, "May 29, 2019"));

    // Microsoft Word may recognize the above contents as being a date.
    // Smart tags use the "Element" property to reflect the type of data they contain.
    smartTag.setElement("date");

    // Some smart tag types process their contents further into custom XML properties.
    smartTag.getProperties().add(new CustomXmlProperty("Day", "", "29"));
    smartTag.getProperties().add(new CustomXmlProperty("Month", "", "5"));
    smartTag.getProperties().add(new CustomXmlProperty("Year", "", "2019"));

    // Set the smart tag's URI to the default value.
    smartTag.setUri("urn:schemas-microsoft-com:office:smarttags");

    doc.getFirstSection().getBody().getFirstParagraph().appendChild(smartTag);
    doc.getFirstSection().getBody().getFirstParagraph().appendChild(new Run(doc, " is a date. "));

    // Create another smart tag for a stock ticker.
    smartTag = new SmartTag(doc);
    smartTag.setElement("stockticker");
    smartTag.setUri("urn:schemas-microsoft-com:office:smarttags");

    smartTag.appendChild(new Run(doc, "MSFT"));

    doc.getFirstSection().getBody().getFirstParagraph().appendChild(smartTag);
    doc.getFirstSection().getBody().getFirstParagraph().appendChild(new Run(doc, " is a stock ticker."));

    // Print all the smart tags in our document using a document visitor.
    doc.accept(new SmartTagPrinter());

    // Older versions of Microsoft Word support smart tags.
    doc.save(getArtifactsDir() + "SmartTag.Create.doc");

    // Use the "RemoveSmartTags" method to remove all smart tags from a document.
    Assert.assertEquals(2, doc.getChildNodes(NodeType.SMART_TAG, true).getCount());

    doc.removeSmartTags();

    Assert.assertEquals(0, doc.getChildNodes(NodeType.SMART_TAG, true).getCount());
}

/// &lt;summary&gt;
/// Prints visited smart tags and their contents.
/// &lt;/summary&gt;
private static class SmartTagPrinter extends DocumentVisitor {
    /// &lt;summary&gt;
    /// Called when a SmartTag node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitSmartTagStart(SmartTag smartTag) {
        System.out.println("Smart tag type: {smartTag.Element}");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when the visiting of a SmartTag node is ended.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitSmartTagEnd(SmartTag smartTag) {
        System.out.println("\tContents: \"{smartTag.ToString(SaveFormat.Text)}\"");

        if (smartTag.getProperties().getCount() == 0) {
            System.out.println("\tContains no properties");
        } else {
            System.out.println("\tProperties: ");
            String[] properties = new String[smartTag.getProperties().getCount()];
            int index = 0;

            for (CustomXmlProperty cxp : smartTag.getProperties())
                properties[index++] = MessageFormat.format("\"{0}\" = \"{1}\"", cxp.getName(), cxp.getValue());

            System.out.println(StringUtils.join(properties, ", "));
        }

        return VisitorAction.CONTINUE;
    }
}</pre></example><example><p><b>Example:</b></p>Removes all smart tags from descendant nodes of a composite node.<pre>
Document doc = new Document(getMyDir() + "Smart tags.doc");

Assert.assertEquals(8, doc.getChildNodes(NodeType.SMART_TAG, true).getCount());

doc.removeSmartTags();

Assert.assertEquals(0, doc.getChildNodes(NodeType.SMART_TAG, true).getCount());</pre></example>
</DL>
<HR>

<A NAME="selectNodes(java.lang.String)"><!-- --></A><A NAME="selectNodes-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>selectNodes</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="NodeList.html" title="class in com.aspose.words">NodeList</A>&nbsp;<B>selectNodes</B>(java.lang.String&nbsp;xpath)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Selects a list of nodes matching the XPath expression.
            </summary><remarks><p>Only expressions with element names are supported at the moment. Expressions
            that use attribute names are not supported.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="xpath"><CODE>xpath</CODE> - The XPath expression.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A list of nodes matching the XPath query.</DD></DL><example><p><b>Example:</b></p>Shows how to select certain nodes by using an XPath expression.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");

// This expression will extract all paragraph nodes,
// which are descendants of any table node in the document.
NodeList nodeList = doc.selectNodes("//Table//Paragraph");

// Iterate through the list with an enumerator and print the contents of every paragraph in each cell of the table.
int index = 0;

Iterator&lt;Node&gt; e = nodeList.iterator();
while (e.hasNext()) {
    Node currentNode = e.next();
    System.out.println(MessageFormat.format("Table paragraph index {0}, contents: \"{1}\"", index++, currentNode.getText().trim()));
}

// This expression will select any paragraphs that are direct children of any Body node in the document.
nodeList = doc.selectNodes("//Body/Paragraph");

// We can treat the list as an array.
Assert.assertEquals(nodeList.toArray().length, 4);

// Use SelectSingleNode to select the first result of the same expression as above.
Node node = doc.selectSingleNode("//Body/Paragraph");

Assert.assertEquals(Paragraph.class, node.getClass());</pre></example><example><p><b>Example:</b></p>Shows how to use an XPath expression to test whether a node is inside a field.<pre>
Document doc = new Document(getMyDir() + "Mail merge destination - Northwind employees.docx");

// The NodeList that results from this XPath expression will contain all nodes we find inside a field.
// However, FieldStart and FieldEnd nodes can be on the list if there are nested fields in the path.
// Currently does not find rare fields in which the FieldCode or FieldResult spans across multiple paragraphs.
NodeList resultList =
        doc.selectNodes("//FieldStart/following-sibling::node()[following-sibling::FieldEnd]");
Run[] runs = Arrays.stream(resultList.toArray()).filter(n -&gt; n.getNodeType() == NodeType.RUN).toArray(Run[]::new);
Run run = runs[0];

// Check if the specified run is one of the nodes that are inside the field.
System.out.println(MessageFormat.format("Contents of the first Run node that''s part of a field: {0}", run.getText().trim()));</pre></example>
</DL>
<HR>

<A NAME="selectSingleNode(java.lang.String)"><!-- --></A><A NAME="selectSingleNode-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>selectSingleNode</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>selectSingleNode</B>(java.lang.String&nbsp;xpath)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Selects the first <cref><A HREF="Node.html" title="class in com.aspose.words">Node</A></cref> that matches the XPath expression.
            </summary><remarks><p>Only expressions with element names are supported at the moment. Expressions
            that use attribute names are not supported.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="xpath"><CODE>xpath</CODE> - The XPath expression.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The first <cref><A HREF="Node.html" title="class in com.aspose.words">Node</A></cref> that matches the XPath query or <code>null</code> if no matching node is found.</DD></DL><example><p><b>Example:</b></p>Shows how to select certain nodes by using an XPath expression.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");

// This expression will extract all paragraph nodes,
// which are descendants of any table node in the document.
NodeList nodeList = doc.selectNodes("//Table//Paragraph");

// Iterate through the list with an enumerator and print the contents of every paragraph in each cell of the table.
int index = 0;

Iterator&lt;Node&gt; e = nodeList.iterator();
while (e.hasNext()) {
    Node currentNode = e.next();
    System.out.println(MessageFormat.format("Table paragraph index {0}, contents: \"{1}\"", index++, currentNode.getText().trim()));
}

// This expression will select any paragraphs that are direct children of any Body node in the document.
nodeList = doc.selectNodes("//Body/Paragraph");

// We can treat the list as an array.
Assert.assertEquals(nodeList.toArray().length, 4);

// Use SelectSingleNode to select the first result of the same expression as above.
Node node = doc.selectSingleNode("//Body/Paragraph");

Assert.assertEquals(Paragraph.class, node.getClass());</pre></example>
</DL>
<HR>

<A NAME="toString(com.aspose.words.SaveOptions)"><!-- --></A><A NAME="toString-com.aspose.words.SaveOptions-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string using the specified save options.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="saveOptions"><CODE>saveOptions</CODE> - Specifies the options that control how the node is saved.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><example><p><b>Example:</b></p>Exports the content of a node to String in HTML format.<pre>
Document doc = new Document(getMyDir() + "Document.docx");

Node node = doc.getLastSection().getBody().getLastParagraph();

// When we call the ToString method using the html SaveFormat overload,
// it converts the node's contents to their raw html representation.
Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%; font-size:12pt\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(SaveFormat.HTML));

// We can also modify the result of this conversion using a SaveOptions object.
HtmlSaveOptions saveOptions = new HtmlSaveOptions();
saveOptions.setExportRelativeFontSize(true);

Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(saveOptions));</pre></example>
</DL>
<HR>

<A NAME="toString(int)"><!-- --></A><A NAME="toString-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(int&nbsp;saveFormat)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string in the specified format.
            </summary><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><DL><DT><B>Parameters:</B></DT><DD><CODE>saveFormat</CODE> - A <A HREF="SaveFormat.html" title="Utility class in com.aspose.words">SaveFormat</A> value.</DD></DL><example><p><b>Example:</b></p>Shows how to extract the list labels of all paragraphs that are list items.<pre>
Document doc = new Document(getMyDir() + "Rendering.docx");
doc.updateListLabels();
int listParaCount = 1;

for (Paragraph paragraph : (Iterable&lt;Paragraph&gt;) doc.getChildNodes(NodeType.PARAGRAPH, true)) {
    // Find if we have the paragraph list. In our document, our list uses plain Arabic numbers,
    // which start at three and ends at six.
    if (paragraph.getListFormat().isListItem()) {
        System.out.println(MessageFormat.format("List item paragraph #{0}", listParaCount));

        // This is the text we get when getting when we output this node to text format.
        // This text output will omit list labels. Trim any paragraph formatting characters. 
        String paragraphText = paragraph.toString(SaveFormat.TEXT).trim();
        System.out.println("Exported Text: " + paragraphText);

        ListLabel label = paragraph.getListLabel();

        // This gets the position of the paragraph in the current level of the list. If we have a list with multiple levels,
        // this will tell us what position it is on that level.
        System.out.println("\tNumerical Id: {label.LabelValue}");

        // Combine them together to include the list label with the text in the output.
        System.out.println("\tList label combined with text: {label.LabelString} {paragraphText}");
    }</pre></example><example><p><b>Example:</b></p>Exports the content of a node to String in HTML format.<pre>
Document doc = new Document(getMyDir() + "Document.docx");

Node node = doc.getLastSection().getBody().getLastParagraph();

// When we call the ToString method using the html SaveFormat overload,
// it converts the node's contents to their raw html representation.
Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%; font-size:12pt\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(SaveFormat.HTML));

// We can also modify the result of this conversion using a SaveOptions object.
HtmlSaveOptions saveOptions = new HtmlSaveOptions();
saveOptions.setExportRelativeFontSize(true);

Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(saveOptions));</pre></example><example><p><b>Example:</b></p>Shows the difference between calling the GetText and ToString methods on a node.<pre>
Document doc = new Document();

DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField("MERGEFIELD Field");

// GetText will retrieve the visible text as well as field codes and special characters.
Assert.assertEquals("\u0013MERGEFIELD Field\u0014«Field»\u0015\f", doc.getText());

// ToString will give us the document's appearance if saved to a passed save format.
Assert.assertEquals("«Field»\r\n", doc.toString(SaveFormat.TEXT));</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>