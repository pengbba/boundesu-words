<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 19 Jul 2025 -->
<TITLE>BookmarkEnd</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class BookmarkEnd</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="Node.html" title="class in com.aspose.words">Node</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.BookmarkEnd</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Cloneable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>BookmarkEnd </B><DT>extends <A HREF="Node.html" title="class in com.aspose.words">Node</A></DL>
</PRE>

<P>

<summary>
             Represents an end of a bookmark in a Word document.
             <p>To learn more, visit the <a href="https://docs.aspose.com/words/net/working-with-bookmarks/">Working with Bookmarks</a> documentation article.</p></summary><remarks><p>A complete bookmark in a Word document consists of a <cref><A HREF="BookmarkStart.html" title="class in com.aspose.words">BookmarkStart</A></cref>
             and a matching <cref><i>BookmarkEnd</i></cref> with the same bookmark name.</p><p><cref><A HREF="BookmarkStart.html" title="class in com.aspose.words">BookmarkStart</A></cref> and <cref><i>BookmarkEnd</i></cref> are just markers inside a document
             that specify where the bookmark starts and ends.</p><p>Use the <cref><A HREF="Bookmark.html" title="class in com.aspose.words">Bookmark</A></cref> class as a "facade" to work with a bookmark
             as a single object.</p></remarks><example><p><b>Example:</b></p>Shows how to add bookmarks and update their contents.<pre>
public void createUpdateAndPrintBookmarks() throws Exception {
    // Create a document with three bookmarks, then use a custom document visitor implementation to print their contents.
    Document doc = createDocumentWithBookmarks(3);
    BookmarkCollection bookmarks = doc.getRange().getBookmarks();
    printAllBookmarkInfo(bookmarks);

    // Bookmarks can be accessed in the bookmark collection by index or name, and their names can be updated.
    bookmarks.get(0).setName("{bookmarks[0].Name}_NewName");
    bookmarks.get("MyBookmark_2").setText("Updated text contents of {bookmarks[1].Name}");

    // Print all bookmarks again to see updated values.
    printAllBookmarkInfo(bookmarks);
}

/// &lt;summary&gt;
/// Create a document with a given number of bookmarks.
/// &lt;/summary&gt;
private static Document createDocumentWithBookmarks(int numberOfBookmarks) throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    for (int i = 1; i &lt;= numberOfBookmarks; i++) {
        String bookmarkName = "MyBookmark_" + i;

        builder.write("Text before bookmark.");
        builder.startBookmark(bookmarkName);
        builder.write(MessageFormat.format("Text inside {0}.", bookmarkName));
        builder.endBookmark(bookmarkName);
        builder.writeln("Text after bookmark.");
    }

    return doc;
}

/// &lt;summary&gt;
/// Use an iterator and a visitor to print info of every bookmark in the collection.
/// &lt;/summary&gt;
private static void printAllBookmarkInfo(BookmarkCollection bookmarks) throws Exception {
    BookmarkInfoPrinter bookmarkVisitor = new BookmarkInfoPrinter();

    // Get each bookmark in the collection to accept a visitor that will print its contents.
    Iterator&lt;Bookmark&gt; enumerator = bookmarks.iterator();

    while (enumerator.hasNext()) {
        Bookmark currentBookmark = enumerator.next();

        if (currentBookmark != null) {
            currentBookmark.getBookmarkStart().accept(bookmarkVisitor);
            currentBookmark.getBookmarkEnd().accept(bookmarkVisitor);

            System.out.println(currentBookmark.getBookmarkStart().getText());
        }
    }
}

/// &lt;summary&gt;
/// Prints contents of every visited bookmark to the console.
/// &lt;/summary&gt;
public static class BookmarkInfoPrinter extends DocumentVisitor {
    public int visitBookmarkStart(BookmarkStart bookmarkStart) throws Exception {
        System.out.println(MessageFormat.format("BookmarkStart name: \"{0}\", Content: \"{1}\"", bookmarkStart.getName(),
                bookmarkStart.getBookmark().getText()));
        return VisitorAction.CONTINUE;
    }

    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd) {
        System.out.println(MessageFormat.format("BookmarkEnd name: \"{0}\"", bookmarkEnd.getName()));
        return VisitorAction.CONTINUE;
    }
}</pre></example>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" ><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="#BookmarkEnd(com.aspose.words.DocumentBase,java.lang.String)">BookmarkEnd</A></B>(<A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A>&nbsp;doc, java.lang.String&nbsp;name)</CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Initializes a new instance of the <cref><i>BookmarkEnd</i></cref> class.
            </TD>
</TR>
</TABLE>&nbsp;

<!-- ========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE RULES="GROUPS" BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Property Getters/Setters Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#CustomNodeId">getCustomNodeId</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#CustomNodeId">setCustomNodeId</A></B>(int&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Specifies custom node identifier.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A></CODE></TD><TD><CODE><B><A HREF="#Document">getDocument</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the document to which this node belongs.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsComposite">isComposite</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns <code>true</code> if this node can contain other nodes.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#Name">getName</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#Name">setName</A></B>(java.lang.String&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets the bookmark name.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#NextSibling">getNextSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately following this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#NodeType">getNodeType</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns <cref><A HREF="NodeType.html#BOOKMARK_END" title="field in class com.aspose.words.NodeType">NodeType.BOOKMARK_END</A></cref>.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#ParentNode">getParentNode</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the immediate parent of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#PreviousSibling">getPreviousSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately preceding this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Range.html" title="class in com.aspose.words">Range</A></CODE></TD><TD><CODE><B><A HREF="#Range">getRange</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a <cref><A HREF="Range.html" title="class in com.aspose.words">Range</A></cref> object that represents the portion of a document that is contained in this node.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#accept(com.aspose.words.DocumentVisitor)">accept</A></B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Accepts a visitor.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#deepClone(boolean)">deepClone</A></B>(boolean&nbsp;isCloneChildren)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Creates a duplicate of the node.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(int)">getAncestor</A></B>(int&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(java.lang.Class)">getAncestor</A></B>(java.lang.Class&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified object type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#getText()">getText</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
             Gets the text of this node and of all its children.
             </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#nextPreOrder(com.aspose.words.Node)">nextPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets next node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#previousPreOrder(com.aspose.words.Node)">previousPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the previous node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#remove()">remove</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes itself from the parent.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(com.aspose.words.SaveOptions)">toString</A></B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string using the specified save options.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(int)">toString</A></B>(int&nbsp;saveFormat)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string in the specified format.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="BookmarkEnd(com.aspose.words.DocumentBase,java.lang.String)"><!-- --></A><A NAME="BookmarkEnd-com.aspose.words.DocumentBase-java.lang.String-"><!-- --></A><H3>
BookmarkEnd</H3>
<PRE>
public <B>BookmarkEnd</B>(<A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A>&nbsp;doc, java.lang.String&nbsp;name)</PRE>
<DL><DD><summary>
            Initializes a new instance of the <cref><i>BookmarkEnd</i></cref> class.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="doc"><CODE>doc</CODE> - The owner document.</DD><DD param="name"><CODE>name</CODE> - The name of the bookmark. Cannot be <code>null</code>.</DD></DL><example><p><b>Example:</b></p>Shows how to add bookmarks and update their contents.<pre>
public void createUpdateAndPrintBookmarks() throws Exception {
    // Create a document with three bookmarks, then use a custom document visitor implementation to print their contents.
    Document doc = createDocumentWithBookmarks(3);
    BookmarkCollection bookmarks = doc.getRange().getBookmarks();
    printAllBookmarkInfo(bookmarks);

    // Bookmarks can be accessed in the bookmark collection by index or name, and their names can be updated.
    bookmarks.get(0).setName("{bookmarks[0].Name}_NewName");
    bookmarks.get("MyBookmark_2").setText("Updated text contents of {bookmarks[1].Name}");

    // Print all bookmarks again to see updated values.
    printAllBookmarkInfo(bookmarks);
}

/// &lt;summary&gt;
/// Create a document with a given number of bookmarks.
/// &lt;/summary&gt;
private static Document createDocumentWithBookmarks(int numberOfBookmarks) throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    for (int i = 1; i &lt;= numberOfBookmarks; i++) {
        String bookmarkName = "MyBookmark_" + i;

        builder.write("Text before bookmark.");
        builder.startBookmark(bookmarkName);
        builder.write(MessageFormat.format("Text inside {0}.", bookmarkName));
        builder.endBookmark(bookmarkName);
        builder.writeln("Text after bookmark.");
    }

    return doc;
}

/// &lt;summary&gt;
/// Use an iterator and a visitor to print info of every bookmark in the collection.
/// &lt;/summary&gt;
private static void printAllBookmarkInfo(BookmarkCollection bookmarks) throws Exception {
    BookmarkInfoPrinter bookmarkVisitor = new BookmarkInfoPrinter();

    // Get each bookmark in the collection to accept a visitor that will print its contents.
    Iterator&lt;Bookmark&gt; enumerator = bookmarks.iterator();

    while (enumerator.hasNext()) {
        Bookmark currentBookmark = enumerator.next();

        if (currentBookmark != null) {
            currentBookmark.getBookmarkStart().accept(bookmarkVisitor);
            currentBookmark.getBookmarkEnd().accept(bookmarkVisitor);

            System.out.println(currentBookmark.getBookmarkStart().getText());
        }
    }
}

/// &lt;summary&gt;
/// Prints contents of every visited bookmark to the console.
/// &lt;/summary&gt;
public static class BookmarkInfoPrinter extends DocumentVisitor {
    public int visitBookmarkStart(BookmarkStart bookmarkStart) throws Exception {
        System.out.println(MessageFormat.format("BookmarkStart name: \"{0}\", Content: \"{1}\"", bookmarkStart.getName(),
                bookmarkStart.getBookmark().getText()));
        return VisitorAction.CONTINUE;
    }

    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd) {
        System.out.println(MessageFormat.format("BookmarkEnd name: \"{0}\"", bookmarkEnd.getName()));
        return VisitorAction.CONTINUE;
    }
}</pre></example>
</DL>
<HR>



<!-- ============ PROPERTY DETAIL ========== -->

<A NAME="property_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Property Getters/Setters Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="CustomNodeId"><!-- --></A><A NAME="getCustomNodeId()"><!-- --></A><A NAME="getCustomNodeId--"><!-- --></A><A NAME="setCustomNodeId(int)"><!-- --></A><A NAME="setCustomNodeId-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCustomNodeId/setCustomNodeId</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getCustomNodeId</B>()&nbsp;/&nbsp;public void&nbsp;<B>setCustomNodeId</B>(int&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Specifies custom node identifier.
            </summary><remarks><p>Default is zero.</p><p>This identifier can be set and used arbitrarily. For example, as a key to get external data.</p><p>Important note, specified value is not saved to an output file and exists only during the node lifetime.</p></remarks><example><p><b>Example:</b></p>Shows how to traverse through a composite node's collection of child nodes.<pre>
Document doc = new Document();

// Add two runs and one shape as child nodes to the first paragraph of this document.
Paragraph paragraph = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 0, true);
paragraph.appendChild(new Run(doc, "Hello world! "));

Shape shape = new Shape(doc, ShapeType.RECTANGLE);
shape.setWidth(200.0);
shape.setHeight(200.0);
// Note that the 'CustomNodeId' is not saved to an output file and exists only during the node lifetime.
shape.setCustomNodeId(100);
shape.setWrapType(WrapType.INLINE);
paragraph.appendChild(shape);

paragraph.appendChild(new Run(doc, "Hello again!"));

// Iterate through the paragraph's collection of immediate children,
// and print any runs or shapes that we find within.
NodeCollection children = paragraph.getChildNodes(NodeType.ANY, false);

Assert.assertEquals(3, paragraph.getChildNodes(NodeType.ANY, false).getCount());

for (Node child : (Iterable&lt;Node&gt;) children)
    switch (child.getNodeType()) {
        case NodeType.RUN:
            System.out.println("Run contents:");
            System.out.println(MessageFormat.format("\t\"{0}\"", child.getText().trim()));
            break;
        case NodeType.SHAPE:
            Shape childShape = (Shape)child;
            System.out.println("Shape:");
            System.out.println(MessageFormat.format("\t{0}, {1}x{2}", childShape.getShapeType(), childShape.getWidth(), childShape.getHeight()));
            break;
    }</pre></example>
</DL>
<HR>

<A NAME="Document"><!-- --></A><A NAME="getDocument()"><!-- --></A><A NAME="getDocument--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getDocument</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A>&nbsp;<B>getDocument</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the document to which this node belongs.
            </summary><remarks><p>The node always belongs to a document even if it has just been created
            and not yet added to the tree, or if it has been removed from the tree.</p></remarks><example><p><b>Example:</b></p>Shows how to create a node and set its owning document.<pre>
Document doc = new Document();
Paragraph para = new Paragraph(doc);
para.appendChild(new Run(doc, "Hello world!"));

// We have not yet appended this paragraph as a child to any composite node.
Assert.assertNull(para.getParentNode());

// If a node is an appropriate child node type of another composite node,
// we can attach it as a child only if both nodes have the same owner document.
// The owner document is the document we passed to the node's constructor.
// We have not attached this paragraph to the document, so the document does not contain its text.
Assert.assertEquals(para.getDocument(), doc);
Assert.assertEquals("", doc.getText().trim());

// Since the document owns this paragraph, we can apply one of its styles to the paragraph's contents.
para.getParagraphFormat().setStyleName("Heading 1");

// Add this node to the document, and then verify its contents.
doc.getFirstSection().getBody().appendChild(para);

Assert.assertEquals(doc.getFirstSection().getBody(), para.getParentNode());
Assert.assertEquals("Hello world!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="IsComposite"><!-- --></A><A NAME="isComposite()"><!-- --></A><A NAME="isComposite--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isComposite</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isComposite</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns <code>true</code> if this node can contain other nodes.
            </summary><value>This method returns <code>false</code> as <cref><A HREF="Node.html" title="class in com.aspose.words">Node</A></cref> cannot have child nodes.</value><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="Name"><!-- --></A><A NAME="getName()"><!-- --></A><A NAME="getName--"><!-- --></A><A NAME="setName(java.lang.String)"><!-- --></A><A NAME="setName-java.lang.String-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getName/setName</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getName</B>()&nbsp;/&nbsp;public void&nbsp;<B>setName</B>(java.lang.String&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets the bookmark name.
            </summary><remarks><p>Cannot be <code>null</code>.</p></remarks><example><p><b>Example:</b></p>Shows how to add bookmarks and update their contents.<pre>
public void createUpdateAndPrintBookmarks() throws Exception {
    // Create a document with three bookmarks, then use a custom document visitor implementation to print their contents.
    Document doc = createDocumentWithBookmarks(3);
    BookmarkCollection bookmarks = doc.getRange().getBookmarks();
    printAllBookmarkInfo(bookmarks);

    // Bookmarks can be accessed in the bookmark collection by index or name, and their names can be updated.
    bookmarks.get(0).setName("{bookmarks[0].Name}_NewName");
    bookmarks.get("MyBookmark_2").setText("Updated text contents of {bookmarks[1].Name}");

    // Print all bookmarks again to see updated values.
    printAllBookmarkInfo(bookmarks);
}

/// &lt;summary&gt;
/// Create a document with a given number of bookmarks.
/// &lt;/summary&gt;
private static Document createDocumentWithBookmarks(int numberOfBookmarks) throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    for (int i = 1; i &lt;= numberOfBookmarks; i++) {
        String bookmarkName = "MyBookmark_" + i;

        builder.write("Text before bookmark.");
        builder.startBookmark(bookmarkName);
        builder.write(MessageFormat.format("Text inside {0}.", bookmarkName));
        builder.endBookmark(bookmarkName);
        builder.writeln("Text after bookmark.");
    }

    return doc;
}

/// &lt;summary&gt;
/// Use an iterator and a visitor to print info of every bookmark in the collection.
/// &lt;/summary&gt;
private static void printAllBookmarkInfo(BookmarkCollection bookmarks) throws Exception {
    BookmarkInfoPrinter bookmarkVisitor = new BookmarkInfoPrinter();

    // Get each bookmark in the collection to accept a visitor that will print its contents.
    Iterator&lt;Bookmark&gt; enumerator = bookmarks.iterator();

    while (enumerator.hasNext()) {
        Bookmark currentBookmark = enumerator.next();

        if (currentBookmark != null) {
            currentBookmark.getBookmarkStart().accept(bookmarkVisitor);
            currentBookmark.getBookmarkEnd().accept(bookmarkVisitor);

            System.out.println(currentBookmark.getBookmarkStart().getText());
        }
    }
}

/// &lt;summary&gt;
/// Prints contents of every visited bookmark to the console.
/// &lt;/summary&gt;
public static class BookmarkInfoPrinter extends DocumentVisitor {
    public int visitBookmarkStart(BookmarkStart bookmarkStart) throws Exception {
        System.out.println(MessageFormat.format("BookmarkStart name: \"{0}\", Content: \"{1}\"", bookmarkStart.getName(),
                bookmarkStart.getBookmark().getText()));
        return VisitorAction.CONTINUE;
    }

    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd) {
        System.out.println(MessageFormat.format("BookmarkEnd name: \"{0}\"", bookmarkEnd.getName()));
        return VisitorAction.CONTINUE;
    }
}</pre></example>
</DL>
<HR>

<A NAME="NextSibling"><!-- --></A><A NAME="getNextSibling()"><!-- --></A><A NAME="getNextSibling--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNextSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getNextSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately following this node.
            </summary><remarks>
            If there is no next node, a <code>null</code> is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to use a node's NextSibling property to enumerate through its immediate children.<pre>
Document doc = new Document(getMyDir() + "Paragraphs.docx");

for (Node node = doc.getFirstSection().getBody().getFirstChild(); node != null; node = node.getNextSibling()) {
    System.out.println(Node.nodeTypeToString(node.getNodeType()));
}</pre></example><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="NodeType"><!-- --></A><A NAME="getNodeType()"><!-- --></A><A NAME="getNodeType--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNodeType</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getNodeType</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns <cref><A HREF="NodeType.html#BOOKMARK_END" title="field in class com.aspose.words.NodeType">NodeType.BOOKMARK_END</A></cref>.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</summary><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="ParentNode"><!-- --></A><A NAME="getParentNode()"><!-- --></A><A NAME="getParentNode--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getParentNode</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getParentNode</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the immediate parent of this node.
            </summary><remarks><p>If a node has just been created and not yet added to the tree,
            or if it has been removed from the tree, the parent is <code>null</code>.</p></remarks><example><p><b>Example:</b></p>Shows how to access a node's parent node.<pre>
Document doc = new Document();
Paragraph para = doc.getFirstSection().getBody().getFirstParagraph();

// Append a child Run node to the document's first paragraph.
Run run = new Run(doc, "Hello world!");
para.appendChild(run);

// The paragraph is the parent node of the run node. We can trace this lineage
// all the way to the document node, which is the root of the document's node tree.
Assert.assertEquals(para, run.getParentNode());
Assert.assertEquals(doc.getFirstSection().getBody(), para.getParentNode());
Assert.assertEquals(doc.getFirstSection(), doc.getFirstSection().getBody().getParentNode());
Assert.assertEquals(doc, doc.getFirstSection().getParentNode());</pre></example><example><p><b>Example:</b></p>Shows how to create a node and set its owning document.<pre>
Document doc = new Document();
Paragraph para = new Paragraph(doc);
para.appendChild(new Run(doc, "Hello world!"));

// We have not yet appended this paragraph as a child to any composite node.
Assert.assertNull(para.getParentNode());

// If a node is an appropriate child node type of another composite node,
// we can attach it as a child only if both nodes have the same owner document.
// The owner document is the document we passed to the node's constructor.
// We have not attached this paragraph to the document, so the document does not contain its text.
Assert.assertEquals(para.getDocument(), doc);
Assert.assertEquals("", doc.getText().trim());

// Since the document owns this paragraph, we can apply one of its styles to the paragraph's contents.
para.getParagraphFormat().setStyleName("Heading 1");

// Add this node to the document, and then verify its contents.
doc.getFirstSection().getBody().appendChild(para);

Assert.assertEquals(doc.getFirstSection().getBody(), para.getParentNode());
Assert.assertEquals("Hello world!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="PreviousSibling"><!-- --></A><A NAME="getPreviousSibling()"><!-- --></A><A NAME="getPreviousSibling--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPreviousSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getPreviousSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately preceding this node.
            </summary><remarks>
            If there is no preceding node, a <code>null</code> is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to use of methods of Node and CompositeNode to remove a section before the last section in the document.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Section 1 text.");
builder.insertBreak(BreakType.SECTION_BREAK_CONTINUOUS);
builder.writeln("Section 2 text.");

// Both sections are siblings of each other.
Section lastSection = (Section) doc.getLastChild();
Section firstSection = (Section) lastSection.getPreviousSibling();

// Remove a section based on its sibling relationship with another section.
if (lastSection.getPreviousSibling() != null)
    doc.removeChild(firstSection);

// The section we removed was the first one, leaving the document with only the second.
Assert.assertEquals("Section 2 text.", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="Range"><!-- --></A><A NAME="getRange()"><!-- --></A><A NAME="getRange--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRange</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Range.html" title="class in com.aspose.words">Range</A>&nbsp;<B>getRange</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a <cref><A HREF="Range.html" title="class in com.aspose.words">Range</A></cref> object that represents the portion of a document that is contained in this node.
            </summary><example><p><b>Example:</b></p>Shows how to delete all the nodes from a range.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Add text to the first section in the document, and then add another section.
builder.write("Section 1. ");
builder.insertBreak(BreakType.SECTION_BREAK_CONTINUOUS);
builder.write("Section 2.");

Assert.assertEquals("Section 1. \fSection 2.", doc.getText().trim());

// Remove the first section entirely by removing all the nodes
// within its range, including the section itself.
doc.getSections().get(0).getRange().delete();

Assert.assertEquals(1, doc.getSections().getCount());
Assert.assertEquals("Section 2.", doc.getText().trim());</pre></example>
</DL>
<HR>



<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="accept(com.aspose.words.DocumentVisitor)"><!-- --></A><A NAME="accept-com.aspose.words.DocumentVisitor-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>accept</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>accept</B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)
              throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Accepts a visitor.
            </summary><remarks><p>Calls <cref><A HREF="DocumentVisitor.html#visitBookmarkEnd(com.aspose.words.BookmarkEnd)" title="method in class com.aspose.words.DocumentVisitor">DocumentVisitor.visitBookmarkEnd(com.aspose.words.BookmarkEnd)</A></cref>.</p><p>For more info see the Visitor design pattern.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="visitor"><CODE>visitor</CODE> - The visitor that will visit the node.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns=""><code>false</code> if the visitor requested the enumeration to stop.</DD></DL><example><p><b>Example:</b></p>Shows how to add bookmarks and update their contents.<pre>
public void createUpdateAndPrintBookmarks() throws Exception {
    // Create a document with three bookmarks, then use a custom document visitor implementation to print their contents.
    Document doc = createDocumentWithBookmarks(3);
    BookmarkCollection bookmarks = doc.getRange().getBookmarks();
    printAllBookmarkInfo(bookmarks);

    // Bookmarks can be accessed in the bookmark collection by index or name, and their names can be updated.
    bookmarks.get(0).setName("{bookmarks[0].Name}_NewName");
    bookmarks.get("MyBookmark_2").setText("Updated text contents of {bookmarks[1].Name}");

    // Print all bookmarks again to see updated values.
    printAllBookmarkInfo(bookmarks);
}

/// &lt;summary&gt;
/// Create a document with a given number of bookmarks.
/// &lt;/summary&gt;
private static Document createDocumentWithBookmarks(int numberOfBookmarks) throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    for (int i = 1; i &lt;= numberOfBookmarks; i++) {
        String bookmarkName = "MyBookmark_" + i;

        builder.write("Text before bookmark.");
        builder.startBookmark(bookmarkName);
        builder.write(MessageFormat.format("Text inside {0}.", bookmarkName));
        builder.endBookmark(bookmarkName);
        builder.writeln("Text after bookmark.");
    }

    return doc;
}

/// &lt;summary&gt;
/// Use an iterator and a visitor to print info of every bookmark in the collection.
/// &lt;/summary&gt;
private static void printAllBookmarkInfo(BookmarkCollection bookmarks) throws Exception {
    BookmarkInfoPrinter bookmarkVisitor = new BookmarkInfoPrinter();

    // Get each bookmark in the collection to accept a visitor that will print its contents.
    Iterator&lt;Bookmark&gt; enumerator = bookmarks.iterator();

    while (enumerator.hasNext()) {
        Bookmark currentBookmark = enumerator.next();

        if (currentBookmark != null) {
            currentBookmark.getBookmarkStart().accept(bookmarkVisitor);
            currentBookmark.getBookmarkEnd().accept(bookmarkVisitor);

            System.out.println(currentBookmark.getBookmarkStart().getText());
        }
    }
}

/// &lt;summary&gt;
/// Prints contents of every visited bookmark to the console.
/// &lt;/summary&gt;
public static class BookmarkInfoPrinter extends DocumentVisitor {
    public int visitBookmarkStart(BookmarkStart bookmarkStart) throws Exception {
        System.out.println(MessageFormat.format("BookmarkStart name: \"{0}\", Content: \"{1}\"", bookmarkStart.getName(),
                bookmarkStart.getBookmark().getText()));
        return VisitorAction.CONTINUE;
    }

    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd) {
        System.out.println(MessageFormat.format("BookmarkEnd name: \"{0}\"", bookmarkEnd.getName()));
        return VisitorAction.CONTINUE;
    }
}</pre></example>
</DL>
<HR>

<A NAME="deepClone(boolean)"><!-- --></A><A NAME="deepClone-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>deepClone</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>deepClone</B>(boolean&nbsp;isCloneChildren)</PRE></TD></TR></TABLE>
<DL><DD><summary>
Creates a duplicate of the node.
</summary><remarks><p>This method serves as a copy constructor for nodes. 
The cloned node has no parent, but belongs to the same document as the original node.</p><p>This method always performs a deep copy of the node. The <i>isCloneChildren</i> parameter
specifies whether to perform copy all child nodes as well.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="isCloneChildren"><CODE>isCloneChildren</CODE> - True to recursively clone the subtree under the specified node; 
false to clone only the node itself.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The cloned node.</DD></DL><example><p><b>Example:</b></p>Shows how to clone a composite node.<pre>
Document doc = new Document();
Paragraph para = doc.getFirstSection().getBody().getFirstParagraph();
para.appendChild(new Run(doc, "Hello world!"));

// Below are two ways of cloning a composite node.
// 1 -  Create a clone of a node, and create a clone of each of its child nodes as well.
Node cloneWithChildren = para.deepClone(true);

Assert.assertTrue(((CompositeNode) cloneWithChildren).hasChildNodes());
Assert.assertEquals("Hello world!", cloneWithChildren.getText().trim());

// 2 -  Create a clone of a node just by itself without any children.
Node cloneWithoutChildren = para.deepClone(false);

Assert.assertFalse(((CompositeNode) cloneWithoutChildren).hasChildNodes());
Assert.assertEquals("", cloneWithoutChildren.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="getAncestor(int)"><!-- --></A><A NAME="getAncestor-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(int&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. The node type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or <code>null</code> if no ancestor of this type was found.</DD></DL><example><p><b>Example:</b></p>Shows how to find out if a tables are nested.<pre>
public void calculateDepthOfNestedTables() throws Exception {
    Document doc = new Document(getMyDir() + "Nested tables.docx");
    NodeCollection tables = doc.getChildNodes(NodeType.TABLE, true);
    for (int i = 0; i &lt; tables.getCount(); i++) {
        Table table = (Table) tables.get(i);

        // Find out if any cells in the table have other tables as children.
        int count = getChildTableCount(table);
        System.out.print(MessageFormat.format("Table #{0} has {1} tables directly within its cells", i, count));

        // Find out if the table is nested inside another table, and, if so, at what depth.
        int tableDepth = getNestedDepthOfTable(table);

        if (tableDepth &gt; 0)
            System.out.println(MessageFormat.format("Table #{0} is nested inside another table at depth of {1}", i, tableDepth));
        else
            System.out.println(MessageFormat.format("Table #{0} is a non nested table (is not a child of another table)", i));
    }
}

// Calculates what level a table is nested inside other tables.
//
// Returns An integer containing the level the table is nested at.
// 0 = Table is not nested inside any other table
// 1 = Table is nested within one parent table
// 2 = Table is nested within two parent tables etc..
private static int getNestedDepthOfTable(final Table table) {
    int depth = 0;
    Node parent = table.getAncestor(table.getNodeType());

    while (parent != null) {
        depth++;
        parent = parent.getAncestor(Table.class);
    }

    return depth;
}

// Determines if a table contains any immediate child table within its cells.
// Does not recursively traverse through those tables to check for further tables.
//
// Returns true if at least one child cell contains a table.
// Returns false if no cells in the table contains a table.
private static int getChildTableCount(final Table table) {
    int childTableCount = 0;

    for (Row row : table.getRows()) {
        for (Cell cell : row.getCells()) {
            TableCollection childTables = cell.getTables();

            if (childTables.getCount() &gt; 0) childTableCount++;
        }
    }

    return childTableCount;
}</pre></example>
</DL>
<HR>

<A NAME="getAncestor(java.lang.Class)"><!-- --></A><A NAME="getAncestor-java.lang.Class-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(java.lang.Class&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified object type.
            </summary><remarks><p>The ancestor type matches if it is equal to <i>ancestorType</i> or derived from <i>ancestorType</i>.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - The object type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or <code>null</code> if no ancestor of this type was found.</DD></DL><example><p><b>Example:</b></p>Shows how to find out if a tables are nested.<pre>
public void calculateDepthOfNestedTables() throws Exception {
    Document doc = new Document(getMyDir() + "Nested tables.docx");
    NodeCollection tables = doc.getChildNodes(NodeType.TABLE, true);
    for (int i = 0; i &lt; tables.getCount(); i++) {
        Table table = (Table) tables.get(i);

        // Find out if any cells in the table have other tables as children.
        int count = getChildTableCount(table);
        System.out.print(MessageFormat.format("Table #{0} has {1} tables directly within its cells", i, count));

        // Find out if the table is nested inside another table, and, if so, at what depth.
        int tableDepth = getNestedDepthOfTable(table);

        if (tableDepth &gt; 0)
            System.out.println(MessageFormat.format("Table #{0} is nested inside another table at depth of {1}", i, tableDepth));
        else
            System.out.println(MessageFormat.format("Table #{0} is a non nested table (is not a child of another table)", i));
    }
}

// Calculates what level a table is nested inside other tables.
//
// Returns An integer containing the level the table is nested at.
// 0 = Table is not nested inside any other table
// 1 = Table is nested within one parent table
// 2 = Table is nested within two parent tables etc..
private static int getNestedDepthOfTable(final Table table) {
    int depth = 0;
    Node parent = table.getAncestor(table.getNodeType());

    while (parent != null) {
        depth++;
        parent = parent.getAncestor(Table.class);
    }

    return depth;
}

// Determines if a table contains any immediate child table within its cells.
// Does not recursively traverse through those tables to check for further tables.
//
// Returns true if at least one child cell contains a table.
// Returns false if no cells in the table contains a table.
private static int getChildTableCount(final Table table) {
    int childTableCount = 0;

    for (Row row : table.getRows()) {
        for (Cell cell : row.getCells()) {
            TableCollection childTables = cell.getTables();

            if (childTables.getCount() &gt; 0) childTableCount++;
        }
    }

    return childTableCount;
}</pre></example>
</DL>
<HR>

<A NAME="getText()"><!-- --></A><A NAME="getText--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getText</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getText</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
             Gets the text of this node and of all its children.
             </summary><remarks><p>The returned string includes all control and special characters as described in <cref><A HREF="ControlChar.html" title="class in com.aspose.words">ControlChar</A></cref>.</p></remarks><example><p><b>Example:</b></p>Shows how to construct an Aspose.Words document by hand.<pre>
Document doc = new Document();

// A blank document contains one section, one body and one paragraph.
// Call the "RemoveAllChildren" method to remove all those nodes,
// and end up with a document node with no children.
doc.removeAllChildren();

// This document now has no composite child nodes that we can add content to.
// If we wish to edit it, we will need to repopulate its node collection.
// First, create a new section, and then append it as a child to the root document node.
Section section = new Section(doc);
doc.appendChild(section);

// Set some page setup properties for the section.
section.getPageSetup().setSectionStart(SectionStart.NEW_PAGE);
section.getPageSetup().setPaperSize(PaperSize.LETTER);

// A section needs a body, which will contain and display all its contents
// on the page between the section's header and footer.
Body body = new Body(doc);
section.appendChild(body);

// Create a paragraph, set some formatting properties, and then append it as a child to the body.
Paragraph para = new Paragraph(doc);

para.getParagraphFormat().setStyleName("Heading 1");
para.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER);

body.appendChild(para);

// Finally, add some content to do the document. Create a run,
// set its appearance and contents, and then append it as a child to the paragraph.
Run run = new Run(doc);
run.setText("Hello World!");
run.getFont().setColor(Color.RED);
para.appendChild(run);

Assert.assertEquals("Hello World!", doc.getText().trim());

doc.save(getArtifactsDir() + "Section.CreateManually.docx");</pre></example><example><p><b>Example:</b></p>Shows how to use control characters.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Insert paragraphs with text with DocumentBuilder.
builder.writeln("Hello world!");
builder.writeln("Hello again!");

// Converting the document to text form reveals that control characters
// represent some of the document's structural elements, such as page breaks.
Assert.assertEquals(MessageFormat.format("Hello world!{0}", ControlChar.CR) +
        MessageFormat.format("Hello again!{0}", ControlChar.CR) +
        ControlChar.PAGE_BREAK, doc.getText());

// When converting a document to string form,
// we can omit some of the control characters with the Trim method.
Assert.assertEquals(MessageFormat.format("Hello world!{0}", ControlChar.CR) +
        "Hello again!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="nextPreOrder(com.aspose.words.Node)"><!-- --></A><A NAME="nextPreOrder-com.aspose.words.Node-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>nextPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>nextPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets next node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Next node in pre-order order. Null if reached the <i>rootNode</i>.</DD></DL><example><p><b>Example:</b></p>Shows how to traverse the document's node tree using the pre-order traversal algorithm, and delete any encountered shape with an image.<pre>
Document doc = new Document(getMyDir() + "Images.docx");
ArrayList&lt;Shape&gt; shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(9, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));

Node curNode = doc;
while (curNode != null) {
    Node nextNode = curNode.nextPreOrder(doc);

    if (curNode.previousPreOrder(doc) != null &amp;&amp; nextNode != null)
        Assert.assertEquals(curNode, nextNode.previousPreOrder(doc));

    if (curNode.getNodeType() == NodeType.SHAPE &amp;&amp; ((Shape) curNode).hasImage())
        curNode.remove();

    curNode = nextNode;
}

shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(0, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));</pre></example>
</DL>
<HR>

<A NAME="previousPreOrder(com.aspose.words.Node)"><!-- --></A><A NAME="previousPreOrder-com.aspose.words.Node-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>previousPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>previousPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the previous node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Previous node in pre-order order. Null if reached the <i>rootNode</i>.</DD></DL><example><p><b>Example:</b></p>Shows how to traverse the document's node tree using the pre-order traversal algorithm, and delete any encountered shape with an image.<pre>
Document doc = new Document(getMyDir() + "Images.docx");
ArrayList&lt;Shape&gt; shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(9, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));

Node curNode = doc;
while (curNode != null) {
    Node nextNode = curNode.nextPreOrder(doc);

    if (curNode.previousPreOrder(doc) != null &amp;&amp; nextNode != null)
        Assert.assertEquals(curNode, nextNode.previousPreOrder(doc));

    if (curNode.getNodeType() == NodeType.SHAPE &amp;&amp; ((Shape) curNode).hasImage())
        curNode.remove();

    curNode = nextNode;
}

shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(0, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));</pre></example>
</DL>
<HR>

<A NAME="remove()"><!-- --></A><A NAME="remove--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>remove</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>remove</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes itself from the parent.
            </summary><example><p><b>Example:</b></p>Shows how to delete all shapes with images from a document.<pre>
Document doc = new Document(getMyDir() + "Images.docx");
ArrayList&lt;Shape&gt; shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(9, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));

for (Shape shape : shapes)
    if (shape.hasImage())
        shape.remove();

shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(0, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));</pre></example><example><p><b>Example:</b></p>Shows how to remove all child nodes of a specific type from a composite node.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");

Assert.assertEquals(2, doc.getChildNodes(NodeType.TABLE, true).getCount());

Node curNode = doc.getFirstSection().getBody().getFirstChild();

while (curNode != null) {
    // Save the next sibling node as a variable in case we want to move to it after deleting this node.
    Node nextNode = curNode.getNextSibling();

    // A section body can contain Paragraph and Table nodes.
    // If the node is a Table, remove it from the parent.
    if (curNode.getNodeType() == NodeType.TABLE) {
        curNode.remove();
    }

    curNode = nextNode;
}

Assert.assertEquals(0, doc.getChildNodes(NodeType.TABLE, true).getCount());</pre></example>
</DL>
<HR>

<A NAME="toString(com.aspose.words.SaveOptions)"><!-- --></A><A NAME="toString-com.aspose.words.SaveOptions-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string using the specified save options.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="saveOptions"><CODE>saveOptions</CODE> - Specifies the options that control how the node is saved.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><example><p><b>Example:</b></p>Exports the content of a node to String in HTML format.<pre>
Document doc = new Document(getMyDir() + "Document.docx");

Node node = doc.getLastSection().getBody().getLastParagraph();

// When we call the ToString method using the html SaveFormat overload,
// it converts the node's contents to their raw html representation.
Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%; font-size:12pt\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(SaveFormat.HTML));

// We can also modify the result of this conversion using a SaveOptions object.
HtmlSaveOptions saveOptions = new HtmlSaveOptions();
saveOptions.setExportRelativeFontSize(true);

Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(saveOptions));</pre></example>
</DL>
<HR>

<A NAME="toString(int)"><!-- --></A><A NAME="toString-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(int&nbsp;saveFormat)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string in the specified format.
            </summary><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><DL><DT><B>Parameters:</B></DT><DD><CODE>saveFormat</CODE> - A <A HREF="SaveFormat.html" title="Utility class in com.aspose.words">SaveFormat</A> value.</DD></DL><example><p><b>Example:</b></p>Shows how to extract the list labels of all paragraphs that are list items.<pre>
Document doc = new Document(getMyDir() + "Rendering.docx");
doc.updateListLabels();
int listParaCount = 1;

for (Paragraph paragraph : (Iterable&lt;Paragraph&gt;) doc.getChildNodes(NodeType.PARAGRAPH, true)) {
    // Find if we have the paragraph list. In our document, our list uses plain Arabic numbers,
    // which start at three and ends at six.
    if (paragraph.getListFormat().isListItem()) {
        System.out.println(MessageFormat.format("List item paragraph #{0}", listParaCount));

        // This is the text we get when getting when we output this node to text format.
        // This text output will omit list labels. Trim any paragraph formatting characters. 
        String paragraphText = paragraph.toString(SaveFormat.TEXT).trim();
        System.out.println("Exported Text: " + paragraphText);

        ListLabel label = paragraph.getListLabel();

        // This gets the position of the paragraph in the current level of the list. If we have a list with multiple levels,
        // this will tell us what position it is on that level.
        System.out.println("\tNumerical Id: {label.LabelValue}");

        // Combine them together to include the list label with the text in the output.
        System.out.println("\tList label combined with text: {label.LabelString} {paragraphText}");
    }</pre></example><example><p><b>Example:</b></p>Exports the content of a node to String in HTML format.<pre>
Document doc = new Document(getMyDir() + "Document.docx");

Node node = doc.getLastSection().getBody().getLastParagraph();

// When we call the ToString method using the html SaveFormat overload,
// it converts the node's contents to their raw html representation.
Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%; font-size:12pt\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(SaveFormat.HTML));

// We can also modify the result of this conversion using a SaveOptions object.
HtmlSaveOptions saveOptions = new HtmlSaveOptions();
saveOptions.setExportRelativeFontSize(true);

Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(saveOptions));</pre></example><example><p><b>Example:</b></p>Shows the difference between calling the GetText and ToString methods on a node.<pre>
Document doc = new Document();

DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField("MERGEFIELD Field");

// GetText will retrieve the visible text as well as field codes and special characters.
Assert.assertEquals("\u0013MERGEFIELD Field\u0014Field\u0015\f", doc.getText());

// ToString will give us the document's appearance if saved to a passed save format.
Assert.assertEquals("Field\r\n", doc.toString(SaveFormat.TEXT));</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>