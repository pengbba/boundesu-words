<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 19 Jul 2025 -->
<TITLE>FieldSeparator</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class FieldSeparator</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="Node.html" title="class in com.aspose.words">Node</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="Inline.html" title="class in com.aspose.words">Inline</A>
          <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A>
              <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A>
                  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.FieldSeparator</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.lang.Cloneable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>FieldSeparator </B><DT>extends <A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></DL>
</PRE>

<P>

<summary>
            Represents a Word field separator that separates the field code from the field result.
            <p>To learn more, visit the <a href="https://docs.aspose.com/words/net/working-with-fields/">Working with Fields</a> documentation article.</p></summary><remarks><p><cref><i>FieldSeparator</i></cref> is an inline-level node and represented
            by the <cref><A HREF="ControlChar.html#FIELD_SEPARATOR_CHAR" title="field in class com.aspose.words.ControlChar">ControlChar.FIELD_SEPARATOR_CHAR</A></cref> control character in the document.</p><p><cref><i>FieldSeparator</i></cref> can only be a child of <cref><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></cref>.</p><p>A complete field in a Microsoft Word document is a complex structure consisting of
a field start character, field code, field separator character, field result
and field end character. Some fields only have field start, field code and field end.</p><p>To easily insert a new field into a document, use the <cref><A HREF="DocumentBuilder.html#insertField(java.lang.String)" title="method in class com.aspose.words.DocumentBuilder">DocumentBuilder.insertField(java.lang.String)</A></cref>
method.</p></remarks><example><p><b>Example:</b></p>Shows how to work with a collection of fields.<pre>
public void fieldCollection() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    builder.insertField(" DATE \\@ \"dddd, d MMMM yyyy\" ");
    builder.insertField(" TIME ");
    builder.insertField(" REVNUM ");
    builder.insertField(" AUTHOR  \"John Doe\" ");
    builder.insertField(" SUBJECT \"My Subject\" ");
    builder.insertField(" QUOTE \"Hello world!\" ");
    doc.updateFields();

    FieldCollection fields = doc.getRange().getFields();

    Assert.assertEquals(6, fields.getCount());

    // Iterate over the field collection, and print contents and type
    // of every field using a custom visitor implementation.
    FieldVisitor fieldVisitor = new FieldVisitor();

    Iterator&lt;Field&gt; fieldEnumerator = fields.iterator();

    while (fieldEnumerator.hasNext()) {
        if (fieldEnumerator != null) {
            Field currentField = fieldEnumerator.next();

            currentField.getStart().accept(fieldVisitor);
            if (currentField.getSeparator() != null) {
                currentField.getSeparator().accept(fieldVisitor);
            }
            currentField.getEnd().accept(fieldVisitor);
        } else {
            System.out.println("There are no fields in the document.");
        }
    }

    System.out.println(fieldVisitor.getText());
}

/// &lt;summary&gt;
/// Document visitor implementation that prints field info.
/// &lt;/summary&gt;
public static class FieldVisitor extends DocumentVisitor {
    public FieldVisitor() {
        mBuilder = new StringBuilder();
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(final FieldStart fieldStart) {
        mBuilder.append("Found field: " + fieldStart.getFieldType() + "\r\n");
        mBuilder.append("\tField code: " + fieldStart.getField().getFieldCode() + "\r\n");
        mBuilder.append("\tDisplayed as: " + fieldStart.getField().getResult() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(final FieldSeparator fieldSeparator) {
        mBuilder.append("\tFound separator: " + fieldSeparator.getText() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(final FieldEnd fieldEnd) {
        mBuilder.append("End of field: " + fieldEnd.getFieldType() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    private final /*final*/ StringBuilder mBuilder;
}</pre></example>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE RULES="GROUPS" BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Property Getters/Setters Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#CustomNodeId">getCustomNodeId</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#CustomNodeId">setCustomNodeId</A></B>(int&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Specifies custom node identifier.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A></CODE></TD><TD><CODE><B><A HREF="#Document">getDocument</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the document to which this node belongs.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#FieldType">getFieldType</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns the type of the field.
            The value of the property is <A HREF="FieldType.html" title="Utility class in com.aspose.words">FieldType</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Font.html" title="class in com.aspose.words">Font</A></CODE></TD><TD><CODE><B><A HREF="#Font">getFont</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Provides access to the font formatting of this object.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsComposite">isComposite</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns <code>true</code> if this node can contain other nodes.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsDeleteRevision">isDeleteRevision</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns true if this object was deleted in Microsoft Word while change tracking was enabled.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsDirty">isDirty</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#IsDirty">isDirty</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets whether the current result of the field is no longer correct (stale) due to other modifications
            made to the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsFormatRevision">isFormatRevision</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns true if formatting of the object was changed in Microsoft Word while change tracking was enabled.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsInsertRevision">isInsertRevision</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns true if this object was inserted in Microsoft Word while change tracking was enabled.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsLocked">isLocked</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#IsLocked">isLocked</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets whether the parent field is locked (should not recalculate its result).
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsMoveFromRevision">isMoveFromRevision</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns <code>true</code> if this object was moved (deleted) in Microsoft Word while change tracking was enabled.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IsMoveToRevision">isMoveToRevision</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns <code>true</code> if this object was moved (inserted) in Microsoft Word while change tracking was enabled.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#NextSibling">getNextSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately following this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#NodeType">getNodeType</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns <cref><A HREF="NodeType.html#FIELD_SEPARATOR" title="field in class com.aspose.words.NodeType">NodeType.FIELD_SEPARATOR</A></cref>.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#ParentNode">getParentNode</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the immediate parent of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></CODE></TD><TD><CODE><B><A HREF="#ParentParagraph">getParentParagraph</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Retrieves the parent <cref><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></cref> of this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#PreviousSibling">getPreviousSibling</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the node immediately preceding this node.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Range.html" title="class in com.aspose.words">Range</A></CODE></TD><TD><CODE><B><A HREF="#Range">getRange</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a <cref><A HREF="Range.html" title="class in com.aspose.words">Range</A></cref> object that represents the portion of a document that is contained in this node.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#accept(com.aspose.words.DocumentVisitor)">accept</A></B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Accepts a visitor.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#deepClone(boolean)">deepClone</A></B>(boolean&nbsp;isCloneChildren)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Creates a duplicate of the node.
</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(int)">getAncestor</A></B>(int&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A></CODE></TD><TD><CODE><B><A HREF="#getAncestor(java.lang.Class)">getAncestor</A></B>(java.lang.Class&nbsp;ancestorType)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the first ancestor of the specified object type.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Field.html" title="class in com.aspose.words">Field</A></CODE></TD><TD><CODE><B><A HREF="#getField()">getField</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Returns a field for the field char.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#getText()">getText</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the special character that this node represents.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#nextPreOrder(com.aspose.words.Node)">nextPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets next node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE><A HREF="Node.html" title="class in com.aspose.words">Node</A></CODE></TD><TD><CODE><B><A HREF="#previousPreOrder(com.aspose.words.Node)">previousPreOrder</A></B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets the previous node according to the pre-order tree traversal algorithm.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>void</CODE></TD><TD><CODE><B><A HREF="#remove()">remove</A></B>()</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Removes itself from the parent.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(com.aspose.words.SaveOptions)">toString</A></B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string using the specified save options.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>java.lang.String</CODE></TD><TD><CODE><B><A HREF="#toString(int)">toString</A></B>(int&nbsp;saveFormat)</CODE></TD><TD ALIGN="right" ><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Exports the content of the node into a string in the specified format.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ============ PROPERTY DETAIL ========== -->

<A NAME="property_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Property Getters/Setters Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="CustomNodeId"><!-- --></A><A NAME="getCustomNodeId()"><!-- --></A><A NAME="getCustomNodeId--"><!-- --></A><A NAME="setCustomNodeId(int)"><!-- --></A><A NAME="setCustomNodeId-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getCustomNodeId/setCustomNodeId</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getCustomNodeId</B>()&nbsp;/&nbsp;public void&nbsp;<B>setCustomNodeId</B>(int&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Specifies custom node identifier.
            </summary><remarks><p>Default is zero.</p><p>This identifier can be set and used arbitrarily. For example, as a key to get external data.</p><p>Important note, specified value is not saved to an output file and exists only during the node lifetime.</p></remarks><example><p><b>Example:</b></p>Shows how to traverse through a composite node's collection of child nodes.<pre>
Document doc = new Document();

// Add two runs and one shape as child nodes to the first paragraph of this document.
Paragraph paragraph = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 0, true);
paragraph.appendChild(new Run(doc, "Hello world! "));

Shape shape = new Shape(doc, ShapeType.RECTANGLE);
shape.setWidth(200.0);
shape.setHeight(200.0);
// Note that the 'CustomNodeId' is not saved to an output file and exists only during the node lifetime.
shape.setCustomNodeId(100);
shape.setWrapType(WrapType.INLINE);
paragraph.appendChild(shape);

paragraph.appendChild(new Run(doc, "Hello again!"));

// Iterate through the paragraph's collection of immediate children,
// and print any runs or shapes that we find within.
NodeCollection children = paragraph.getChildNodes(NodeType.ANY, false);

Assert.assertEquals(3, paragraph.getChildNodes(NodeType.ANY, false).getCount());

for (Node child : (Iterable&lt;Node&gt;) children)
    switch (child.getNodeType()) {
        case NodeType.RUN:
            System.out.println("Run contents:");
            System.out.println(MessageFormat.format("\t\"{0}\"", child.getText().trim()));
            break;
        case NodeType.SHAPE:
            Shape childShape = (Shape)child;
            System.out.println("Shape:");
            System.out.println(MessageFormat.format("\t{0}, {1}x{2}", childShape.getShapeType(), childShape.getWidth(), childShape.getHeight()));
            break;
    }</pre></example>
</DL>
<HR>

<A NAME="Document"><!-- --></A><A NAME="getDocument()"><!-- --></A><A NAME="getDocument--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getDocument</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="DocumentBase.html" title="class in com.aspose.words">DocumentBase</A>&nbsp;<B>getDocument</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the document to which this node belongs.
            </summary><remarks><p>The node always belongs to a document even if it has just been created
            and not yet added to the tree, or if it has been removed from the tree.</p></remarks><example><p><b>Example:</b></p>Shows how to create a node and set its owning document.<pre>
Document doc = new Document();
Paragraph para = new Paragraph(doc);
para.appendChild(new Run(doc, "Hello world!"));

// We have not yet appended this paragraph as a child to any composite node.
Assert.assertNull(para.getParentNode());

// If a node is an appropriate child node type of another composite node,
// we can attach it as a child only if both nodes have the same owner document.
// The owner document is the document we passed to the node's constructor.
// We have not attached this paragraph to the document, so the document does not contain its text.
Assert.assertEquals(para.getDocument(), doc);
Assert.assertEquals("", doc.getText().trim());

// Since the document owns this paragraph, we can apply one of its styles to the paragraph's contents.
para.getParagraphFormat().setStyleName("Heading 1");

// Add this node to the document, and then verify its contents.
doc.getFirstSection().getBody().appendChild(para);

Assert.assertEquals(doc.getFirstSection().getBody(), para.getParentNode());
Assert.assertEquals("Hello world!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="FieldType"><!-- --></A><A NAME="getFieldType()"><!-- --></A><A NAME="getFieldType--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFieldType</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getFieldType</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns the type of the field.
            The value of the property is <A HREF="FieldType.html" title="Utility class in com.aspose.words">FieldType</A> integer constant.</summary><example><p><b>Example:</b></p>Shows how to work with a FieldStart node.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

FieldDate field = (FieldDate) builder.insertField(FieldType.FIELD_DATE, true);
field.getFormat().setDateTimeFormat("dddd, MMMM dd, yyyy");
field.update();

FieldChar fieldStart = field.getStart();

Assert.assertEquals(FieldType.FIELD_DATE, fieldStart.getFieldType());
Assert.assertEquals(false, fieldStart.isDirty());
Assert.assertEquals(false, fieldStart.isLocked());

// Retrieve the facade object which represents the field in the document.
field = (FieldDate) fieldStart.getField();

Assert.assertEquals(false, field.isLocked());
Assert.assertEquals(" DATE  \\@ \"dddd, MMMM dd, yyyy\"", field.getFieldCode());

// Update the field to show the current date.
field.update();</pre></example>
</DL>
<HR>

<A NAME="Font"><!-- --></A><A NAME="getFont()"><!-- --></A><A NAME="getFont--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFont</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Font.html" title="class in com.aspose.words">Font</A>&nbsp;<B>getFont</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Provides access to the font formatting of this object.
            </summary><example><p><b>Example:</b></p>Shows how to construct an Aspose.Words document by hand.<pre>
Document doc = new Document();

// A blank document contains one section, one body and one paragraph.
// Call the "RemoveAllChildren" method to remove all those nodes,
// and end up with a document node with no children.
doc.removeAllChildren();

// This document now has no composite child nodes that we can add content to.
// If we wish to edit it, we will need to repopulate its node collection.
// First, create a new section, and then append it as a child to the root document node.
Section section = new Section(doc);
doc.appendChild(section);

// Set some page setup properties for the section.
section.getPageSetup().setSectionStart(SectionStart.NEW_PAGE);
section.getPageSetup().setPaperSize(PaperSize.LETTER);

// A section needs a body, which will contain and display all its contents
// on the page between the section's header and footer.
Body body = new Body(doc);
section.appendChild(body);

// Create a paragraph, set some formatting properties, and then append it as a child to the body.
Paragraph para = new Paragraph(doc);

para.getParagraphFormat().setStyleName("Heading 1");
para.getParagraphFormat().setAlignment(ParagraphAlignment.CENTER);

body.appendChild(para);

// Finally, add some content to do the document. Create a run,
// set its appearance and contents, and then append it as a child to the paragraph.
Run run = new Run(doc);
run.setText("Hello World!");
run.getFont().setColor(Color.RED);
para.appendChild(run);

Assert.assertEquals("Hello World!", doc.getText().trim());

doc.save(getArtifactsDir() + "Section.CreateManually.docx");</pre></example>
</DL>
<HR>

<A NAME="IsComposite"><!-- --></A><A NAME="isComposite()"><!-- --></A><A NAME="isComposite--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isComposite</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isComposite</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns <code>true</code> if this node can contain other nodes.
            </summary><value>This method returns <code>false</code> as <cref><A HREF="Node.html" title="class in com.aspose.words">Node</A></cref> cannot have child nodes.</value><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="IsDeleteRevision"><!-- --></A><A NAME="isDeleteRevision()"><!-- --></A><A NAME="isDeleteRevision--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isDeleteRevision</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isDeleteRevision</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
Returns true if this object was deleted in Microsoft Word while change tracking was enabled.
</summary><example><p><b>Example:</b></p>Shows how to determine the revision type of an inline node.<pre>
Document doc = new Document(getMyDir() + "Revision runs.docx");

// When we edit the document while the "Track Changes" option, found in via Review -&gt; Tracking,
// is turned on in Microsoft Word, the changes we apply count as revisions.
// When editing a document using Aspose.Words, we can begin tracking revisions by
// invoking the document's "StartTrackRevisions" method and stop tracking by using the "StopTrackRevisions" method.
// We can either accept revisions to assimilate them into the document
// or reject them to change the proposed change effectively.
Assert.assertEquals(6, doc.getRevisions().getCount());

// The parent node of a revision is the run that the revision concerns. A Run is an Inline node.
Run run = (Run) doc.getRevisions().get(0).getParentNode();

Paragraph firstParagraph = run.getParentParagraph();
RunCollection runs = firstParagraph.getRuns();

Assert.assertEquals(runs.getCount(), 6);

// Below are five types of revisions that can flag an Inline node.
// 1 -  An "insert" revision:
// This revision occurs when we insert text while tracking changes.
Assert.assertTrue(runs.get(2).isInsertRevision());

// 2 -  A "format" revision:
// This revision occurs when we change the formatting of text while tracking changes.
Assert.assertTrue(runs.get(2).isFormatRevision());

// 3 -  A "move from" revision:
// When we highlight text in Microsoft Word, and then drag it to a different place in the document
// while tracking changes, two revisions appear.
// The "move from" revision is a copy of the text originally before we moved it.
Assert.assertTrue(runs.get(4).isMoveFromRevision());

// 4 -  A "move to" revision:
// The "move to" revision is the text that we moved in its new position in the document.
// "Move from" and "move to" revisions appear in pairs for every move revision we carry out.
// Accepting a move revision deletes the "move from" revision and its text,
// and keeps the text from the "move to" revision.
// Rejecting a move revision conversely keeps the "move from" revision and deletes the "move to" revision.
Assert.assertTrue(runs.get(1).isMoveToRevision());

// 5 -  A "delete" revision:
// This revision occurs when we delete text while tracking changes. When we delete text like this,
// it will stay in the document as a revision until we either accept the revision,
// which will delete the text for good, or reject the revision, which will keep the text we deleted where it was.
Assert.assertTrue(runs.get(5).isDeleteRevision());</pre></example>
</DL>
<HR>

<A NAME="IsDirty"><!-- --></A><A NAME="isDirty()"><!-- --></A><A NAME="isDirty--"><!-- --></A><A NAME="isDirty(boolean)"><!-- --></A><A NAME="isDirty-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isDirty/isDirty</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isDirty</B>()&nbsp;/&nbsp;public void&nbsp;<B>isDirty</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets whether the current result of the field is no longer correct (stale) due to other modifications
            made to the document.
            </summary><example><p><b>Example:</b></p>Shows how to work with a FieldStart node.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

FieldDate field = (FieldDate) builder.insertField(FieldType.FIELD_DATE, true);
field.getFormat().setDateTimeFormat("dddd, MMMM dd, yyyy");
field.update();

FieldChar fieldStart = field.getStart();

Assert.assertEquals(FieldType.FIELD_DATE, fieldStart.getFieldType());
Assert.assertEquals(false, fieldStart.isDirty());
Assert.assertEquals(false, fieldStart.isLocked());

// Retrieve the facade object which represents the field in the document.
field = (FieldDate) fieldStart.getField();

Assert.assertEquals(false, field.isLocked());
Assert.assertEquals(" DATE  \\@ \"dddd, MMMM dd, yyyy\"", field.getFieldCode());

// Update the field to show the current date.
field.update();</pre></example>
</DL>
<HR>

<A NAME="IsFormatRevision"><!-- --></A><A NAME="isFormatRevision()"><!-- --></A><A NAME="isFormatRevision--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isFormatRevision</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isFormatRevision</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
Returns true if formatting of the object was changed in Microsoft Word while change tracking was enabled.
</summary><example><p><b>Example:</b></p>Shows how to determine the revision type of an inline node.<pre>
Document doc = new Document(getMyDir() + "Revision runs.docx");

// When we edit the document while the "Track Changes" option, found in via Review -&gt; Tracking,
// is turned on in Microsoft Word, the changes we apply count as revisions.
// When editing a document using Aspose.Words, we can begin tracking revisions by
// invoking the document's "StartTrackRevisions" method and stop tracking by using the "StopTrackRevisions" method.
// We can either accept revisions to assimilate them into the document
// or reject them to change the proposed change effectively.
Assert.assertEquals(6, doc.getRevisions().getCount());

// The parent node of a revision is the run that the revision concerns. A Run is an Inline node.
Run run = (Run) doc.getRevisions().get(0).getParentNode();

Paragraph firstParagraph = run.getParentParagraph();
RunCollection runs = firstParagraph.getRuns();

Assert.assertEquals(runs.getCount(), 6);

// Below are five types of revisions that can flag an Inline node.
// 1 -  An "insert" revision:
// This revision occurs when we insert text while tracking changes.
Assert.assertTrue(runs.get(2).isInsertRevision());

// 2 -  A "format" revision:
// This revision occurs when we change the formatting of text while tracking changes.
Assert.assertTrue(runs.get(2).isFormatRevision());

// 3 -  A "move from" revision:
// When we highlight text in Microsoft Word, and then drag it to a different place in the document
// while tracking changes, two revisions appear.
// The "move from" revision is a copy of the text originally before we moved it.
Assert.assertTrue(runs.get(4).isMoveFromRevision());

// 4 -  A "move to" revision:
// The "move to" revision is the text that we moved in its new position in the document.
// "Move from" and "move to" revisions appear in pairs for every move revision we carry out.
// Accepting a move revision deletes the "move from" revision and its text,
// and keeps the text from the "move to" revision.
// Rejecting a move revision conversely keeps the "move from" revision and deletes the "move to" revision.
Assert.assertTrue(runs.get(1).isMoveToRevision());

// 5 -  A "delete" revision:
// This revision occurs when we delete text while tracking changes. When we delete text like this,
// it will stay in the document as a revision until we either accept the revision,
// which will delete the text for good, or reject the revision, which will keep the text we deleted where it was.
Assert.assertTrue(runs.get(5).isDeleteRevision());</pre></example>
</DL>
<HR>

<A NAME="IsInsertRevision"><!-- --></A><A NAME="isInsertRevision()"><!-- --></A><A NAME="isInsertRevision--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isInsertRevision</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isInsertRevision</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
Returns true if this object was inserted in Microsoft Word while change tracking was enabled.
</summary><example><p><b>Example:</b></p>Shows how to determine the revision type of an inline node.<pre>
Document doc = new Document(getMyDir() + "Revision runs.docx");

// When we edit the document while the "Track Changes" option, found in via Review -&gt; Tracking,
// is turned on in Microsoft Word, the changes we apply count as revisions.
// When editing a document using Aspose.Words, we can begin tracking revisions by
// invoking the document's "StartTrackRevisions" method and stop tracking by using the "StopTrackRevisions" method.
// We can either accept revisions to assimilate them into the document
// or reject them to change the proposed change effectively.
Assert.assertEquals(6, doc.getRevisions().getCount());

// The parent node of a revision is the run that the revision concerns. A Run is an Inline node.
Run run = (Run) doc.getRevisions().get(0).getParentNode();

Paragraph firstParagraph = run.getParentParagraph();
RunCollection runs = firstParagraph.getRuns();

Assert.assertEquals(runs.getCount(), 6);

// Below are five types of revisions that can flag an Inline node.
// 1 -  An "insert" revision:
// This revision occurs when we insert text while tracking changes.
Assert.assertTrue(runs.get(2).isInsertRevision());

// 2 -  A "format" revision:
// This revision occurs when we change the formatting of text while tracking changes.
Assert.assertTrue(runs.get(2).isFormatRevision());

// 3 -  A "move from" revision:
// When we highlight text in Microsoft Word, and then drag it to a different place in the document
// while tracking changes, two revisions appear.
// The "move from" revision is a copy of the text originally before we moved it.
Assert.assertTrue(runs.get(4).isMoveFromRevision());

// 4 -  A "move to" revision:
// The "move to" revision is the text that we moved in its new position in the document.
// "Move from" and "move to" revisions appear in pairs for every move revision we carry out.
// Accepting a move revision deletes the "move from" revision and its text,
// and keeps the text from the "move to" revision.
// Rejecting a move revision conversely keeps the "move from" revision and deletes the "move to" revision.
Assert.assertTrue(runs.get(1).isMoveToRevision());

// 5 -  A "delete" revision:
// This revision occurs when we delete text while tracking changes. When we delete text like this,
// it will stay in the document as a revision until we either accept the revision,
// which will delete the text for good, or reject the revision, which will keep the text we deleted where it was.
Assert.assertTrue(runs.get(5).isDeleteRevision());</pre></example>
</DL>
<HR>

<A NAME="IsLocked"><!-- --></A><A NAME="isLocked()"><!-- --></A><A NAME="isLocked--"><!-- --></A><A NAME="isLocked(boolean)"><!-- --></A><A NAME="isLocked-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isLocked/isLocked</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isLocked</B>()&nbsp;/&nbsp;public void&nbsp;<B>isLocked</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets whether the parent field is locked (should not recalculate its result).
            </summary><example><p><b>Example:</b></p>Shows how to work with a FieldStart node.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

FieldDate field = (FieldDate) builder.insertField(FieldType.FIELD_DATE, true);
field.getFormat().setDateTimeFormat("dddd, MMMM dd, yyyy");
field.update();

FieldChar fieldStart = field.getStart();

Assert.assertEquals(FieldType.FIELD_DATE, fieldStart.getFieldType());
Assert.assertEquals(false, fieldStart.isDirty());
Assert.assertEquals(false, fieldStart.isLocked());

// Retrieve the facade object which represents the field in the document.
field = (FieldDate) fieldStart.getField();

Assert.assertEquals(false, field.isLocked());
Assert.assertEquals(" DATE  \\@ \"dddd, MMMM dd, yyyy\"", field.getFieldCode());

// Update the field to show the current date.
field.update();</pre></example>
</DL>
<HR>

<A NAME="IsMoveFromRevision"><!-- --></A><A NAME="isMoveFromRevision()"><!-- --></A><A NAME="isMoveFromRevision--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isMoveFromRevision</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isMoveFromRevision</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
Returns <code>true</code> if this object was moved (deleted) in Microsoft Word while change tracking was enabled.
</summary><example><p><b>Example:</b></p>Shows how to determine the revision type of an inline node.<pre>
Document doc = new Document(getMyDir() + "Revision runs.docx");

// When we edit the document while the "Track Changes" option, found in via Review -&gt; Tracking,
// is turned on in Microsoft Word, the changes we apply count as revisions.
// When editing a document using Aspose.Words, we can begin tracking revisions by
// invoking the document's "StartTrackRevisions" method and stop tracking by using the "StopTrackRevisions" method.
// We can either accept revisions to assimilate them into the document
// or reject them to change the proposed change effectively.
Assert.assertEquals(6, doc.getRevisions().getCount());

// The parent node of a revision is the run that the revision concerns. A Run is an Inline node.
Run run = (Run) doc.getRevisions().get(0).getParentNode();

Paragraph firstParagraph = run.getParentParagraph();
RunCollection runs = firstParagraph.getRuns();

Assert.assertEquals(runs.getCount(), 6);

// Below are five types of revisions that can flag an Inline node.
// 1 -  An "insert" revision:
// This revision occurs when we insert text while tracking changes.
Assert.assertTrue(runs.get(2).isInsertRevision());

// 2 -  A "format" revision:
// This revision occurs when we change the formatting of text while tracking changes.
Assert.assertTrue(runs.get(2).isFormatRevision());

// 3 -  A "move from" revision:
// When we highlight text in Microsoft Word, and then drag it to a different place in the document
// while tracking changes, two revisions appear.
// The "move from" revision is a copy of the text originally before we moved it.
Assert.assertTrue(runs.get(4).isMoveFromRevision());

// 4 -  A "move to" revision:
// The "move to" revision is the text that we moved in its new position in the document.
// "Move from" and "move to" revisions appear in pairs for every move revision we carry out.
// Accepting a move revision deletes the "move from" revision and its text,
// and keeps the text from the "move to" revision.
// Rejecting a move revision conversely keeps the "move from" revision and deletes the "move to" revision.
Assert.assertTrue(runs.get(1).isMoveToRevision());

// 5 -  A "delete" revision:
// This revision occurs when we delete text while tracking changes. When we delete text like this,
// it will stay in the document as a revision until we either accept the revision,
// which will delete the text for good, or reject the revision, which will keep the text we deleted where it was.
Assert.assertTrue(runs.get(5).isDeleteRevision());</pre></example>
</DL>
<HR>

<A NAME="IsMoveToRevision"><!-- --></A><A NAME="isMoveToRevision()"><!-- --></A><A NAME="isMoveToRevision--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>isMoveToRevision</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>isMoveToRevision</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
Returns <code>true</code> if this object was moved (inserted) in Microsoft Word while change tracking was enabled.
</summary><example><p><b>Example:</b></p>Shows how to determine the revision type of an inline node.<pre>
Document doc = new Document(getMyDir() + "Revision runs.docx");

// When we edit the document while the "Track Changes" option, found in via Review -&gt; Tracking,
// is turned on in Microsoft Word, the changes we apply count as revisions.
// When editing a document using Aspose.Words, we can begin tracking revisions by
// invoking the document's "StartTrackRevisions" method and stop tracking by using the "StopTrackRevisions" method.
// We can either accept revisions to assimilate them into the document
// or reject them to change the proposed change effectively.
Assert.assertEquals(6, doc.getRevisions().getCount());

// The parent node of a revision is the run that the revision concerns. A Run is an Inline node.
Run run = (Run) doc.getRevisions().get(0).getParentNode();

Paragraph firstParagraph = run.getParentParagraph();
RunCollection runs = firstParagraph.getRuns();

Assert.assertEquals(runs.getCount(), 6);

// Below are five types of revisions that can flag an Inline node.
// 1 -  An "insert" revision:
// This revision occurs when we insert text while tracking changes.
Assert.assertTrue(runs.get(2).isInsertRevision());

// 2 -  A "format" revision:
// This revision occurs when we change the formatting of text while tracking changes.
Assert.assertTrue(runs.get(2).isFormatRevision());

// 3 -  A "move from" revision:
// When we highlight text in Microsoft Word, and then drag it to a different place in the document
// while tracking changes, two revisions appear.
// The "move from" revision is a copy of the text originally before we moved it.
Assert.assertTrue(runs.get(4).isMoveFromRevision());

// 4 -  A "move to" revision:
// The "move to" revision is the text that we moved in its new position in the document.
// "Move from" and "move to" revisions appear in pairs for every move revision we carry out.
// Accepting a move revision deletes the "move from" revision and its text,
// and keeps the text from the "move to" revision.
// Rejecting a move revision conversely keeps the "move from" revision and deletes the "move to" revision.
Assert.assertTrue(runs.get(1).isMoveToRevision());

// 5 -  A "delete" revision:
// This revision occurs when we delete text while tracking changes. When we delete text like this,
// it will stay in the document as a revision until we either accept the revision,
// which will delete the text for good, or reject the revision, which will keep the text we deleted where it was.
Assert.assertTrue(runs.get(5).isDeleteRevision());</pre></example>
</DL>
<HR>

<A NAME="NextSibling"><!-- --></A><A NAME="getNextSibling()"><!-- --></A><A NAME="getNextSibling--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNextSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getNextSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately following this node.
            </summary><remarks>
            If there is no next node, a <code>null</code> is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to use a node's NextSibling property to enumerate through its immediate children.<pre>
Document doc = new Document(getMyDir() + "Paragraphs.docx");

for (Node node = doc.getFirstSection().getBody().getFirstChild(); node != null; node = node.getNextSibling()) {
    System.out.println(Node.nodeTypeToString(node.getNodeType()));
}</pre></example><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="NodeType"><!-- --></A><A NAME="getNodeType()"><!-- --></A><A NAME="getNodeType--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getNodeType</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getNodeType</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns <cref><A HREF="NodeType.html#FIELD_SEPARATOR" title="field in class com.aspose.words.NodeType">NodeType.FIELD_SEPARATOR</A></cref>.
            The value of the property is <A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A> integer constant.</summary><example><p><b>Example:</b></p>Shows how to traverse a composite node's tree of child nodes.<pre>
public void recurseChildren() throws Exception {
    Document doc = new Document(getMyDir() + "Paragraphs.docx");

    // Any node that can contain child nodes, such as the document itself, is composite.
    Assert.assertTrue(doc.isComposite());

    // Invoke the recursive function that will go through and print all the child nodes of a composite node.
    traverseAllNodes(doc, 0);
}

/// &lt;summary&gt;
/// Recursively traverses a node tree while printing the type of each node
/// with an indent depending on depth as well as the contents of all inline nodes.
/// &lt;/summary&gt;
public void traverseAllNodes(CompositeNode parentNode, int depth) {
    for (Node childNode = parentNode.getFirstChild(); childNode != null; childNode = childNode.getNextSibling()) {
        System.out.println(MessageFormat.format("{0}{1}", String.format("    ", depth), Node.nodeTypeToString(childNode.getNodeType())));

        // Recurse into the node if it is a composite node. Otherwise, print its contents if it is an inline node.
        if (childNode.isComposite()) {
            System.out.println();
            traverseAllNodes((CompositeNode) childNode, depth + 1);
        } else if (childNode instanceof Inline) {
            System.out.println(MessageFormat.format(" - \"{0}\"", childNode.getText().trim()));
        } else {
            System.out.println();
        }
    }
}</pre></example>
</DL>
<HR>

<A NAME="ParentNode"><!-- --></A><A NAME="getParentNode()"><!-- --></A><A NAME="getParentNode--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getParentNode</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getParentNode</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the immediate parent of this node.
            </summary><remarks><p>If a node has just been created and not yet added to the tree,
            or if it has been removed from the tree, the parent is <code>null</code>.</p></remarks><example><p><b>Example:</b></p>Shows how to access a node's parent node.<pre>
Document doc = new Document();
Paragraph para = doc.getFirstSection().getBody().getFirstParagraph();

// Append a child Run node to the document's first paragraph.
Run run = new Run(doc, "Hello world!");
para.appendChild(run);

// The paragraph is the parent node of the run node. We can trace this lineage
// all the way to the document node, which is the root of the document's node tree.
Assert.assertEquals(para, run.getParentNode());
Assert.assertEquals(doc.getFirstSection().getBody(), para.getParentNode());
Assert.assertEquals(doc.getFirstSection(), doc.getFirstSection().getBody().getParentNode());
Assert.assertEquals(doc, doc.getFirstSection().getParentNode());</pre></example><example><p><b>Example:</b></p>Shows how to create a node and set its owning document.<pre>
Document doc = new Document();
Paragraph para = new Paragraph(doc);
para.appendChild(new Run(doc, "Hello world!"));

// We have not yet appended this paragraph as a child to any composite node.
Assert.assertNull(para.getParentNode());

// If a node is an appropriate child node type of another composite node,
// we can attach it as a child only if both nodes have the same owner document.
// The owner document is the document we passed to the node's constructor.
// We have not attached this paragraph to the document, so the document does not contain its text.
Assert.assertEquals(para.getDocument(), doc);
Assert.assertEquals("", doc.getText().trim());

// Since the document owns this paragraph, we can apply one of its styles to the paragraph's contents.
para.getParagraphFormat().setStyleName("Heading 1");

// Add this node to the document, and then verify its contents.
doc.getFirstSection().getBody().appendChild(para);

Assert.assertEquals(doc.getFirstSection().getBody(), para.getParentNode());
Assert.assertEquals("Hello world!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="ParentParagraph"><!-- --></A><A NAME="getParentParagraph()"><!-- --></A><A NAME="getParentParagraph--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getParentParagraph</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Inline.html" title="class in com.aspose.words">Inline</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A>&nbsp;<B>getParentParagraph</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Retrieves the parent <cref><A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A></cref> of this node.
            </summary><example><p><b>Example:</b></p>Shows how to determine the revision type of an inline node.<pre>
Document doc = new Document(getMyDir() + "Revision runs.docx");

// When we edit the document while the "Track Changes" option, found in via Review -&gt; Tracking,
// is turned on in Microsoft Word, the changes we apply count as revisions.
// When editing a document using Aspose.Words, we can begin tracking revisions by
// invoking the document's "StartTrackRevisions" method and stop tracking by using the "StopTrackRevisions" method.
// We can either accept revisions to assimilate them into the document
// or reject them to change the proposed change effectively.
Assert.assertEquals(6, doc.getRevisions().getCount());

// The parent node of a revision is the run that the revision concerns. A Run is an Inline node.
Run run = (Run) doc.getRevisions().get(0).getParentNode();

Paragraph firstParagraph = run.getParentParagraph();
RunCollection runs = firstParagraph.getRuns();

Assert.assertEquals(runs.getCount(), 6);

// Below are five types of revisions that can flag an Inline node.
// 1 -  An "insert" revision:
// This revision occurs when we insert text while tracking changes.
Assert.assertTrue(runs.get(2).isInsertRevision());

// 2 -  A "format" revision:
// This revision occurs when we change the formatting of text while tracking changes.
Assert.assertTrue(runs.get(2).isFormatRevision());

// 3 -  A "move from" revision:
// When we highlight text in Microsoft Word, and then drag it to a different place in the document
// while tracking changes, two revisions appear.
// The "move from" revision is a copy of the text originally before we moved it.
Assert.assertTrue(runs.get(4).isMoveFromRevision());

// 4 -  A "move to" revision:
// The "move to" revision is the text that we moved in its new position in the document.
// "Move from" and "move to" revisions appear in pairs for every move revision we carry out.
// Accepting a move revision deletes the "move from" revision and its text,
// and keeps the text from the "move to" revision.
// Rejecting a move revision conversely keeps the "move from" revision and deletes the "move to" revision.
Assert.assertTrue(runs.get(1).isMoveToRevision());

// 5 -  A "delete" revision:
// This revision occurs when we delete text while tracking changes. When we delete text like this,
// it will stay in the document as a revision until we either accept the revision,
// which will delete the text for good, or reject the revision, which will keep the text we deleted where it was.
Assert.assertTrue(runs.get(5).isDeleteRevision());</pre></example>
</DL>
<HR>

<A NAME="PreviousSibling"><!-- --></A><A NAME="getPreviousSibling()"><!-- --></A><A NAME="getPreviousSibling--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getPreviousSibling</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>getPreviousSibling</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the node immediately preceding this node.
            </summary><remarks>
            If there is no preceding node, a <code>null</code> is returned.
            </remarks><example><p><b>Example:</b></p>Shows how to use of methods of Node and CompositeNode to remove a section before the last section in the document.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Section 1 text.");
builder.insertBreak(BreakType.SECTION_BREAK_CONTINUOUS);
builder.writeln("Section 2 text.");

// Both sections are siblings of each other.
Section lastSection = (Section) doc.getLastChild();
Section firstSection = (Section) lastSection.getPreviousSibling();

// Remove a section based on its sibling relationship with another section.
if (lastSection.getPreviousSibling() != null)
    doc.removeChild(firstSection);

// The section we removed was the first one, leaving the document with only the second.
Assert.assertEquals("Section 2 text.", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="Range"><!-- --></A><A NAME="getRange()"><!-- --></A><A NAME="getRange--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getRange</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Range.html" title="class in com.aspose.words">Range</A>&nbsp;<B>getRange</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a <cref><A HREF="Range.html" title="class in com.aspose.words">Range</A></cref> object that represents the portion of a document that is contained in this node.
            </summary><example><p><b>Example:</b></p>Shows how to delete all the nodes from a range.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Add text to the first section in the document, and then add another section.
builder.write("Section 1. ");
builder.insertBreak(BreakType.SECTION_BREAK_CONTINUOUS);
builder.write("Section 2.");

Assert.assertEquals("Section 1. \fSection 2.", doc.getText().trim());

// Remove the first section entirely by removing all the nodes
// within its range, including the section itself.
doc.getSections().get(0).getRange().delete();

Assert.assertEquals(1, doc.getSections().getCount());
Assert.assertEquals("Section 2.", doc.getText().trim());</pre></example>
</DL>
<HR>



<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="accept(com.aspose.words.DocumentVisitor)"><!-- --></A><A NAME="accept-com.aspose.words.DocumentVisitor-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>accept</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>accept</B>(<A HREF="DocumentVisitor.html" title="class in com.aspose.words">DocumentVisitor</A>&nbsp;visitor)
              throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Accepts a visitor.
            </summary><remarks><p>Calls <cref><A HREF="DocumentVisitor.html#visitFieldSeparator(com.aspose.words.FieldSeparator)" title="method in class com.aspose.words.DocumentVisitor">DocumentVisitor.visitFieldSeparator(com.aspose.words.FieldSeparator)</A></cref>.</p><p>For more info see the Visitor design pattern.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="visitor"><CODE>visitor</CODE> - The visitor that will visit the node.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns=""><b>False</b> if the visitor requested the enumeration to stop.</DD></DL><example><p><b>Example:</b></p>Shows how to work with a collection of fields.<pre>
public void fieldCollection() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    builder.insertField(" DATE \\@ \"dddd, d MMMM yyyy\" ");
    builder.insertField(" TIME ");
    builder.insertField(" REVNUM ");
    builder.insertField(" AUTHOR  \"John Doe\" ");
    builder.insertField(" SUBJECT \"My Subject\" ");
    builder.insertField(" QUOTE \"Hello world!\" ");
    doc.updateFields();

    FieldCollection fields = doc.getRange().getFields();

    Assert.assertEquals(6, fields.getCount());

    // Iterate over the field collection, and print contents and type
    // of every field using a custom visitor implementation.
    FieldVisitor fieldVisitor = new FieldVisitor();

    Iterator&lt;Field&gt; fieldEnumerator = fields.iterator();

    while (fieldEnumerator.hasNext()) {
        if (fieldEnumerator != null) {
            Field currentField = fieldEnumerator.next();

            currentField.getStart().accept(fieldVisitor);
            if (currentField.getSeparator() != null) {
                currentField.getSeparator().accept(fieldVisitor);
            }
            currentField.getEnd().accept(fieldVisitor);
        } else {
            System.out.println("There are no fields in the document.");
        }
    }

    System.out.println(fieldVisitor.getText());
}

/// &lt;summary&gt;
/// Document visitor implementation that prints field info.
/// &lt;/summary&gt;
public static class FieldVisitor extends DocumentVisitor {
    public FieldVisitor() {
        mBuilder = new StringBuilder();
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(final FieldStart fieldStart) {
        mBuilder.append("Found field: " + fieldStart.getFieldType() + "\r\n");
        mBuilder.append("\tField code: " + fieldStart.getField().getFieldCode() + "\r\n");
        mBuilder.append("\tDisplayed as: " + fieldStart.getField().getResult() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(final FieldSeparator fieldSeparator) {
        mBuilder.append("\tFound separator: " + fieldSeparator.getText() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(final FieldEnd fieldEnd) {
        mBuilder.append("End of field: " + fieldEnd.getFieldType() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    private final /*final*/ StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="deepClone(boolean)"><!-- --></A><A NAME="deepClone-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>deepClone</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>deepClone</B>(boolean&nbsp;isCloneChildren)</PRE></TD></TR></TABLE>
<DL><DD><summary>
Creates a duplicate of the node.
</summary><remarks><p>This method serves as a copy constructor for nodes. 
The cloned node has no parent, but belongs to the same document as the original node.</p><p>This method always performs a deep copy of the node. The <i>isCloneChildren</i> parameter
specifies whether to perform copy all child nodes as well.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="isCloneChildren"><CODE>isCloneChildren</CODE> - True to recursively clone the subtree under the specified node; 
false to clone only the node itself.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The cloned node.</DD></DL><example><p><b>Example:</b></p>Shows how to clone a composite node.<pre>
Document doc = new Document();
Paragraph para = doc.getFirstSection().getBody().getFirstParagraph();
para.appendChild(new Run(doc, "Hello world!"));

// Below are two ways of cloning a composite node.
// 1 -  Create a clone of a node, and create a clone of each of its child nodes as well.
Node cloneWithChildren = para.deepClone(true);

Assert.assertTrue(((CompositeNode) cloneWithChildren).hasChildNodes());
Assert.assertEquals("Hello world!", cloneWithChildren.getText().trim());

// 2 -  Create a clone of a node just by itself without any children.
Node cloneWithoutChildren = para.deepClone(false);

Assert.assertFalse(((CompositeNode) cloneWithoutChildren).hasChildNodes());
Assert.assertEquals("", cloneWithoutChildren.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="getAncestor(int)"><!-- --></A><A NAME="getAncestor-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(int&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref>.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - A <cref><A HREF="NodeType.html" title="Utility class in com.aspose.words">NodeType</A></cref> value. The node type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or <code>null</code> if no ancestor of this type was found.</DD></DL><example><p><b>Example:</b></p>Shows how to find out if a tables are nested.<pre>
public void calculateDepthOfNestedTables() throws Exception {
    Document doc = new Document(getMyDir() + "Nested tables.docx");
    NodeCollection tables = doc.getChildNodes(NodeType.TABLE, true);
    for (int i = 0; i &lt; tables.getCount(); i++) {
        Table table = (Table) tables.get(i);

        // Find out if any cells in the table have other tables as children.
        int count = getChildTableCount(table);
        System.out.print(MessageFormat.format("Table #{0} has {1} tables directly within its cells", i, count));

        // Find out if the table is nested inside another table, and, if so, at what depth.
        int tableDepth = getNestedDepthOfTable(table);

        if (tableDepth &gt; 0)
            System.out.println(MessageFormat.format("Table #{0} is nested inside another table at depth of {1}", i, tableDepth));
        else
            System.out.println(MessageFormat.format("Table #{0} is a non nested table (is not a child of another table)", i));
    }
}

// Calculates what level a table is nested inside other tables.
//
// Returns An integer containing the level the table is nested at.
// 0 = Table is not nested inside any other table
// 1 = Table is nested within one parent table
// 2 = Table is nested within two parent tables etc..
private static int getNestedDepthOfTable(final Table table) {
    int depth = 0;
    Node parent = table.getAncestor(table.getNodeType());

    while (parent != null) {
        depth++;
        parent = parent.getAncestor(Table.class);
    }

    return depth;
}

// Determines if a table contains any immediate child table within its cells.
// Does not recursively traverse through those tables to check for further tables.
//
// Returns true if at least one child cell contains a table.
// Returns false if no cells in the table contains a table.
private static int getChildTableCount(final Table table) {
    int childTableCount = 0;

    for (Row row : table.getRows()) {
        for (Cell cell : row.getCells()) {
            TableCollection childTables = cell.getTables();

            if (childTables.getCount() &gt; 0) childTableCount++;
        }
    }

    return childTableCount;
}</pre></example>
</DL>
<HR>

<A NAME="getAncestor(java.lang.Class)"><!-- --></A><A NAME="getAncestor-java.lang.Class-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getAncestor</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="CompositeNode.html" title="class in com.aspose.words">CompositeNode</A>&nbsp;<B>getAncestor</B>(java.lang.Class&nbsp;ancestorType)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the first ancestor of the specified object type.
            </summary><remarks><p>The ancestor type matches if it is equal to <i>ancestorType</i> or derived from <i>ancestorType</i>.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="ancestorType"><CODE>ancestorType</CODE> - The object type of the ancestor to retrieve.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The ancestor of the specified type or <code>null</code> if no ancestor of this type was found.</DD></DL><example><p><b>Example:</b></p>Shows how to find out if a tables are nested.<pre>
public void calculateDepthOfNestedTables() throws Exception {
    Document doc = new Document(getMyDir() + "Nested tables.docx");
    NodeCollection tables = doc.getChildNodes(NodeType.TABLE, true);
    for (int i = 0; i &lt; tables.getCount(); i++) {
        Table table = (Table) tables.get(i);

        // Find out if any cells in the table have other tables as children.
        int count = getChildTableCount(table);
        System.out.print(MessageFormat.format("Table #{0} has {1} tables directly within its cells", i, count));

        // Find out if the table is nested inside another table, and, if so, at what depth.
        int tableDepth = getNestedDepthOfTable(table);

        if (tableDepth &gt; 0)
            System.out.println(MessageFormat.format("Table #{0} is nested inside another table at depth of {1}", i, tableDepth));
        else
            System.out.println(MessageFormat.format("Table #{0} is a non nested table (is not a child of another table)", i));
    }
}

// Calculates what level a table is nested inside other tables.
//
// Returns An integer containing the level the table is nested at.
// 0 = Table is not nested inside any other table
// 1 = Table is nested within one parent table
// 2 = Table is nested within two parent tables etc..
private static int getNestedDepthOfTable(final Table table) {
    int depth = 0;
    Node parent = table.getAncestor(table.getNodeType());

    while (parent != null) {
        depth++;
        parent = parent.getAncestor(Table.class);
    }

    return depth;
}

// Determines if a table contains any immediate child table within its cells.
// Does not recursively traverse through those tables to check for further tables.
//
// Returns true if at least one child cell contains a table.
// Returns false if no cells in the table contains a table.
private static int getChildTableCount(final Table table) {
    int childTableCount = 0;

    for (Row row : table.getRows()) {
        for (Cell cell : row.getCells()) {
            TableCollection childTables = cell.getTables();

            if (childTables.getCount() &gt; 0) childTableCount++;
        }
    }

    return childTableCount;
}</pre></example>
</DL>
<HR>

<A NAME="getField()"><!-- --></A><A NAME="getField--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getField</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="FieldChar.html" title="class in com.aspose.words">FieldChar</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Field.html" title="class in com.aspose.words">Field</A>&nbsp;<B>getField</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Returns a field for the field char.
            </summary><remarks>
            A new <cref><A HREF="Field.html" title="class in com.aspose.words">Field</A></cref> object is created each time the method is called.
            </remarks><DL><DT><B>Returns:</B></DT><DD returns="">A field for the field char.</DD></DL><example><p><b>Example:</b></p>Shows how to work with a FieldStart node.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

FieldDate field = (FieldDate) builder.insertField(FieldType.FIELD_DATE, true);
field.getFormat().setDateTimeFormat("dddd, MMMM dd, yyyy");
field.update();

FieldChar fieldStart = field.getStart();

Assert.assertEquals(FieldType.FIELD_DATE, fieldStart.getFieldType());
Assert.assertEquals(false, fieldStart.isDirty());
Assert.assertEquals(false, fieldStart.isLocked());

// Retrieve the facade object which represents the field in the document.
field = (FieldDate) fieldStart.getField();

Assert.assertEquals(false, field.isLocked());
Assert.assertEquals(" DATE  \\@ \"dddd, MMMM dd, yyyy\"", field.getFieldCode());

// Update the field to show the current date.
field.update();</pre></example>
</DL>
<HR>

<A NAME="getText()"><!-- --></A><A NAME="getText--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getText</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>getText</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the special character that this node represents.
            </summary><DL><DT><B>Returns:</B></DT><DD returns="">The string that contains the character that this node represents.</DD></DL><example><p><b>Example:</b></p>Shows how to use a DocumentVisitor implementation to remove all hidden content from a document.<pre>
public void removeHiddenContentFromDocument() throws Exception {
    Document doc = new Document(getMyDir() + "Hidden content.docx");
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // Below are three types of fields which can accept a document visitor,
    // which will allow it to visit the accepting node, and then traverse its child nodes in a depth-first manner.
    // 1 -  Paragraph node:
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // 2 -  Table node:
    Table table = doc.getFirstSection().getBody().getTables().get(0);
    table.accept(hiddenContentRemover);

    // 3 -  Document node:
    doc.accept(hiddenContentRemover);

    doc.save(getArtifactsDir() + "Font.RemoveHiddenContentFromDocument.docx");
}

/// &lt;summary&gt;
/// Removes all visited nodes marked as "hidden content".
/// &lt;/summary&gt;
public static class RemoveHiddenContentVisitor extends DocumentVisitor {
    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(FieldStart fieldStart) {
        if (fieldStart.getFont().getHidden())
            fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(FieldEnd fieldEnd) {
        if (fieldEnd.getFont().getHidden())
            fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(FieldSeparator fieldSeparator) {
        if (fieldSeparator.getFont().getHidden())
            fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(Run run) {
        if (run.getFont().getHidden())
            run.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(Paragraph paragraph) {
        if (paragraph.getParagraphBreakFont().getHidden())
            paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FormField is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFormField(FormField formField) {
        if (formField.getFont().getHidden())
            formField.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a GroupShape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitGroupShapeStart(GroupShape groupShape) {
        if (groupShape.getFont().getHidden())
            groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Shape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitShapeStart(Shape shape) {
        if (shape.getFont().getHidden())
            shape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(Comment comment) {
        if (comment.getFont().getHidden())
            comment.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Footnote is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFootnoteStart(Footnote footnote) {
        if (footnote.getFont().getHidden())
            footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SpecialCharacter is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSpecialChar(SpecialChar specialChar) {
        if (specialChar.getFont().getHidden())
            specialChar.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Table node is ended in the document.
    /// &lt;/summary&gt;
    public int visitTableEnd(Table table) {
        // The content inside table cells may have the hidden content flag, but the tables themselves cannot.
        // If this table had nothing but hidden content, this visitor would have removed all of it,
        // and there would be no child nodes left.
        // Thus, we can also treat the table itself as hidden content and remove it.
        // Tables which are empty but do not have hidden content will have cells with empty paragraphs inside,
        // which this visitor will not remove.
        if (!table.hasChildNodes())
            table.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Cell node is ended in the document.
    /// &lt;/summary&gt;
    public int visitCellEnd(Cell cell) {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null)
            cell.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Row node is ended in the document.
    /// &lt;/summary&gt;
    public int visitRowEnd(Row row) {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null)
            row.remove();

        return VisitorAction.CONTINUE;
    }
}</pre></example>
</DL>
<HR>

<A NAME="nextPreOrder(com.aspose.words.Node)"><!-- --></A><A NAME="nextPreOrder-com.aspose.words.Node-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>nextPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>nextPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets next node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Next node in pre-order order. Null if reached the <i>rootNode</i>.</DD></DL><example><p><b>Example:</b></p>Shows how to traverse the document's node tree using the pre-order traversal algorithm, and delete any encountered shape with an image.<pre>
Document doc = new Document(getMyDir() + "Images.docx");
ArrayList&lt;Shape&gt; shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(9, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));

Node curNode = doc;
while (curNode != null) {
    Node nextNode = curNode.nextPreOrder(doc);

    if (curNode.previousPreOrder(doc) != null &amp;&amp; nextNode != null)
        Assert.assertEquals(curNode, nextNode.previousPreOrder(doc));

    if (curNode.getNodeType() == NodeType.SHAPE &amp;&amp; ((Shape) curNode).hasImage())
        curNode.remove();

    curNode = nextNode;
}

shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(0, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));</pre></example>
</DL>
<HR>

<A NAME="previousPreOrder(com.aspose.words.Node)"><!-- --></A><A NAME="previousPreOrder-com.aspose.words.Node-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>previousPreOrder</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;<B>previousPreOrder</B>(<A HREF="Node.html" title="class in com.aspose.words">Node</A>&nbsp;rootNode)</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets the previous node according to the pre-order tree traversal algorithm.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="rootNode"><CODE>rootNode</CODE> - The top node (limit) of traversal.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">Previous node in pre-order order. Null if reached the <i>rootNode</i>.</DD></DL><example><p><b>Example:</b></p>Shows how to traverse the document's node tree using the pre-order traversal algorithm, and delete any encountered shape with an image.<pre>
Document doc = new Document(getMyDir() + "Images.docx");
ArrayList&lt;Shape&gt; shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(9, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));

Node curNode = doc;
while (curNode != null) {
    Node nextNode = curNode.nextPreOrder(doc);

    if (curNode.previousPreOrder(doc) != null &amp;&amp; nextNode != null)
        Assert.assertEquals(curNode, nextNode.previousPreOrder(doc));

    if (curNode.getNodeType() == NodeType.SHAPE &amp;&amp; ((Shape) curNode).hasImage())
        curNode.remove();

    curNode = nextNode;
}

shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(0, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));</pre></example>
</DL>
<HR>

<A NAME="remove()"><!-- --></A><A NAME="remove--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>remove</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public void&nbsp;<B>remove</B>()</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Removes itself from the parent.
            </summary><example><p><b>Example:</b></p>Shows how to delete all shapes with images from a document.<pre>
Document doc = new Document(getMyDir() + "Images.docx");
ArrayList&lt;Shape&gt; shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(9, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));

for (Shape shape : shapes)
    if (shape.hasImage())
        shape.remove();

shapes = (ArrayList&lt;Shape&gt;) IterableUtils.toList(doc.getChildNodes(NodeType.SHAPE, true));

Assert.assertEquals(0, IterableUtils.countMatches(shapes, s -&gt; {
    try {
        return s.hasImage();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}));</pre></example><example><p><b>Example:</b></p>Shows how to remove all child nodes of a specific type from a composite node.<pre>
Document doc = new Document(getMyDir() + "Tables.docx");

Assert.assertEquals(2, doc.getChildNodes(NodeType.TABLE, true).getCount());

Node curNode = doc.getFirstSection().getBody().getFirstChild();

while (curNode != null) {
    // Save the next sibling node as a variable in case we want to move to it after deleting this node.
    Node nextNode = curNode.getNextSibling();

    // A section body can contain Paragraph and Table nodes.
    // If the node is a Table, remove it from the parent.
    if (curNode.getNodeType() == NodeType.TABLE) {
        curNode.remove();
    }

    curNode = nextNode;
}

Assert.assertEquals(0, doc.getChildNodes(NodeType.TABLE, true).getCount());</pre></example>
</DL>
<HR>

<A NAME="toString(com.aspose.words.SaveOptions)"><!-- --></A><A NAME="toString-com.aspose.words.SaveOptions-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(<A HREF="SaveOptions.html" title="class in com.aspose.words">SaveOptions</A>&nbsp;saveOptions)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string using the specified save options.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="saveOptions"><CODE>saveOptions</CODE> - Specifies the options that control how the node is saved.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><example><p><b>Example:</b></p>Exports the content of a node to String in HTML format.<pre>
Document doc = new Document(getMyDir() + "Document.docx");

Node node = doc.getLastSection().getBody().getLastParagraph();

// When we call the ToString method using the html SaveFormat overload,
// it converts the node's contents to their raw html representation.
Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%; font-size:12pt\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(SaveFormat.HTML));

// We can also modify the result of this conversion using a SaveOptions object.
HtmlSaveOptions saveOptions = new HtmlSaveOptions();
saveOptions.setExportRelativeFontSize(true);

Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(saveOptions));</pre></example>
</DL>
<HR>

<A NAME="toString(int)"><!-- --></A><A NAME="toString-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>toString</H3></TD><TD ALIGN="right" VALIGN="top"><CODE><B>&rarr;&nbsp;inherited&nbsp;from&nbsp;<A HREF="Node.html" title="class in com.aspose.words">Node</A></B></CODE></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public java.lang.String&nbsp;<B>toString</B>(int&nbsp;saveFormat)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Exports the content of the node into a string in the specified format.
            </summary><DL><DT><B>Returns:</B></DT><DD returns="">The content of the node in the specified format.</DD></DL><DL><DT><B>Parameters:</B></DT><DD><CODE>saveFormat</CODE> - A <A HREF="SaveFormat.html" title="Utility class in com.aspose.words">SaveFormat</A> value.</DD></DL><example><p><b>Example:</b></p>Shows how to extract the list labels of all paragraphs that are list items.<pre>
Document doc = new Document(getMyDir() + "Rendering.docx");
doc.updateListLabels();
int listParaCount = 1;

for (Paragraph paragraph : (Iterable&lt;Paragraph&gt;) doc.getChildNodes(NodeType.PARAGRAPH, true)) {
    // Find if we have the paragraph list. In our document, our list uses plain Arabic numbers,
    // which start at three and ends at six.
    if (paragraph.getListFormat().isListItem()) {
        System.out.println(MessageFormat.format("List item paragraph #{0}", listParaCount));

        // This is the text we get when getting when we output this node to text format.
        // This text output will omit list labels. Trim any paragraph formatting characters. 
        String paragraphText = paragraph.toString(SaveFormat.TEXT).trim();
        System.out.println("Exported Text: " + paragraphText);

        ListLabel label = paragraph.getListLabel();

        // This gets the position of the paragraph in the current level of the list. If we have a list with multiple levels,
        // this will tell us what position it is on that level.
        System.out.println("\tNumerical Id: {label.LabelValue}");

        // Combine them together to include the list label with the text in the output.
        System.out.println("\tList label combined with text: {label.LabelString} {paragraphText}");
    }</pre></example><example><p><b>Example:</b></p>Exports the content of a node to String in HTML format.<pre>
Document doc = new Document(getMyDir() + "Document.docx");

Node node = doc.getLastSection().getBody().getLastParagraph();

// When we call the ToString method using the html SaveFormat overload,
// it converts the node's contents to their raw html representation.
Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%; font-size:12pt\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(SaveFormat.HTML));

// We can also modify the result of this conversion using a SaveOptions object.
HtmlSaveOptions saveOptions = new HtmlSaveOptions();
saveOptions.setExportRelativeFontSize(true);

Assert.assertEquals("&lt;p style=\"margin-top:0pt; margin-bottom:8pt; line-height:108%\"&gt;" +
        "&lt;span style=\"font-family:'Times New Roman'\"&gt;Hello World!&lt;/span&gt;" +
        "&lt;/p&gt;", node.toString(saveOptions));</pre></example><example><p><b>Example:</b></p>Shows the difference between calling the GetText and ToString methods on a node.<pre>
Document doc = new Document();

DocumentBuilder builder = new DocumentBuilder(doc);
builder.insertField("MERGEFIELD Field");

// GetText will retrieve the visible text as well as field codes and special characters.
Assert.assertEquals("\u0013MERGEFIELD Field\u0014Field\u0015\f", doc.getText());

// ToString will give us the document's appearance if saved to a passed save format.
Assert.assertEquals("Field\r\n", doc.toString(SaveFormat.TEXT));</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>