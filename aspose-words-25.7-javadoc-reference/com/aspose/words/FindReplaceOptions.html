<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 19 Jul 2025 -->
<TITLE>FindReplaceOptions</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class FindReplaceOptions</H2>
<PRE>
java.lang.Object
    <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.FindReplaceOptions</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>FindReplaceOptions </B><DT>extends java.lang.Object</DL>
</PRE>

<P>

<summary>
            Specifies options for find/replace operations.
            <p>To learn more, visit the <a href="https://docs.aspose.com/words/net/find-and-replace/">Find and Replace</a> documentation article.</p></summary><example><p><b>Example:</b></p>Shows how to toggle case sensitivity when performing a find-and-replace operation.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Ruby bought a ruby necklace.");

// We can use a "FindReplaceOptions" object to modify the find-and-replace process.
FindReplaceOptions options = new FindReplaceOptions();

// Set the "MatchCase" flag to "true" to apply case sensitivity while finding strings to replace.
// Set the "MatchCase" flag to "false" to ignore character case while searching for text to replace.
options.setMatchCase(matchCase);

doc.getRange().replace("Ruby", "Jade", options);

Assert.assertEquals(matchCase ? "Jade bought a ruby necklace." : "Jade bought a Jade necklace.",
        doc.getText().trim());</pre></example><example><p><b>Example:</b></p>Shows how to toggle standalone word-only find-and-replace operations.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Jackson will meet you in Jacksonville.");

// We can use a "FindReplaceOptions" object to modify the find-and-replace process.
FindReplaceOptions options = new FindReplaceOptions();

// Set the "FindWholeWordsOnly" flag to "true" to replace the found text if it is not a part of another word.
// Set the "FindWholeWordsOnly" flag to "false" to replace all text regardless of its surroundings.
options.setFindWholeWordsOnly(findWholeWordsOnly);

doc.getRange().replace("Jackson", "Louis", options);

Assert.assertEquals(
        findWholeWordsOnly ? "Louis will meet you in Jacksonville." : "Louis will meet you in Louisville.",
        doc.getText().trim());</pre></example>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" ><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="#FindReplaceOptions()">FindReplaceOptions</A></B>()</CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Initializes a new instance of the FindReplaceOptions class with default settings.
            </TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="#FindReplaceOptions(int)">FindReplaceOptions</A></B>(int&nbsp;direction)</CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Initializes a new instance of the FindReplaceOptions class with the specified direction.
            </TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="#FindReplaceOptions(com.aspose.words.IReplacingCallback)">FindReplaceOptions</A></B>(<A HREF="IReplacingCallback.html" title="interface in com.aspose.words">IReplacingCallback</A>&nbsp;replacingCallback)</CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Initializes a new instance of the FindReplaceOptions class with the specified replacing callback.
            </TD>
</TR>

<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="#FindReplaceOptions(int,com.aspose.words.IReplacingCallback)">FindReplaceOptions</A></B>(int&nbsp;direction, <A HREF="IReplacingCallback.html" title="interface in com.aspose.words">IReplacingCallback</A>&nbsp;replacingCallback)</CODE>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Initializes a new instance of the FindReplaceOptions class with the specified direction and replacing callback.
            </TD>
</TR>
</TABLE>&nbsp;

<!-- ========== PROPERTY SUMMARY =========== -->

<A NAME="property_summary"><!-- --></A>
<TABLE RULES="GROUPS" BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Property Getters/Setters Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="Font.html" title="class in com.aspose.words">Font</A></CODE></TD><TD><CODE><B><A HREF="#ApplyFont">getApplyFont</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Text formatting applied to new content.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="ParagraphFormat.html" title="class in com.aspose.words">ParagraphFormat</A></CODE></TD><TD><CODE><B><A HREF="#ApplyParagraphFormat">getApplyParagraphFormat</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Paragraph formatting applied to new content.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#Direction">getDirection</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#Direction">setDirection</A></B>(int&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Selects direction for replace. Default value is <cref><A HREF="FindReplaceDirection.html#FORWARD" title="field in class com.aspose.words.FindReplaceDirection">FindReplaceDirection.FORWARD</A></cref>.
            The value of the property is <A HREF="FindReplaceDirection.html" title="Utility class in com.aspose.words">FindReplaceDirection</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#FindWholeWordsOnly">getFindWholeWordsOnly</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#FindWholeWordsOnly">setFindWholeWordsOnly</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            True indicates the oldValue must be a standalone word.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IgnoreDeleted">getIgnoreDeleted</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#IgnoreDeleted">setIgnoreDeleted</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a boolean value indicating either to ignore text inside delete revisions.
            The default value is <code>false</code>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IgnoreFieldCodes">getIgnoreFieldCodes</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#IgnoreFieldCodes">setIgnoreFieldCodes</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a boolean value indicating either to ignore text inside field codes.
            The default value is <code>false</code>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IgnoreFields">getIgnoreFields</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#IgnoreFields">setIgnoreFields</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a boolean value indicating either to ignore text inside fields.
            The default value is <code>false</code>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IgnoreFootnotes">getIgnoreFootnotes</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#IgnoreFootnotes">setIgnoreFootnotes</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a boolean value indicating either to ignore footnotes.
            The default value is <code>false</code>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IgnoreInserted">getIgnoreInserted</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#IgnoreInserted">setIgnoreInserted</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a boolean value indicating either to ignore text inside insert revisions.
            The default value is <code>false</code>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IgnoreShapes">getIgnoreShapes</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#IgnoreShapes">setIgnoreShapes</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<p>Gets or sets a boolean value indicating either to ignore shapes within a text.</p><p>The default value is <code>false</code>.</p></TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#IgnoreStructuredDocumentTags">getIgnoreStructuredDocumentTags</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#IgnoreStructuredDocumentTags">setIgnoreStructuredDocumentTags</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a boolean value indicating either to ignore content of <cref><A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A></cref>.
            The default value is <code>false</code>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#LegacyMode">getLegacyMode</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#LegacyMode">setLegacyMode</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a boolean value indicating that old find/replace algorithm is used.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#MatchCase">getMatchCase</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#MatchCase">setMatchCase</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            True indicates case-sensitive comparison, false indicates case-insensitive comparison.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>int</CODE></TD><TD><CODE><B><A HREF="#ReplacementFormat">getReplacementFormat</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#ReplacementFormat">setReplacementFormat</A></B>(int&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Specifies format of the replacement. Default is <cref><A HREF="ReplacementFormat.html#TEXT" title="field in class com.aspose.words.ReplacementFormat">ReplacementFormat.TEXT</A></cref>.
            The value of the property is <A HREF="ReplacementFormat.html" title="Utility class in com.aspose.words">ReplacementFormat</A> integer constant.</TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE><A HREF="IReplacingCallback.html" title="interface in com.aspose.words">IReplacingCallback</A></CODE></TD><TD><CODE><B><A HREF="#ReplacingCallback">getReplacingCallback</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#ReplacingCallback">setReplacingCallback</A></B>(<A HREF="IReplacingCallback.html" title="interface in com.aspose.words">IReplacingCallback</A>&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            The user-defined method which is called before every replace occurrence.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#SmartParagraphBreakReplacement">getSmartParagraphBreakReplacement</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#SmartParagraphBreakReplacement">setSmartParagraphBreakReplacement</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<p>Gets or sets a boolean value indicating either it is allowed to replace paragraph break
            when there is no next sibling paragraph.</p><p>The default value is <code>false</code>.</p></TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#UseLegacyOrder">getUseLegacyOrder</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#UseLegacyOrder">setUseLegacyOrder</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            True indicates that a text search is performed sequentially from top to bottom considering the text boxes.
            Default value is <code>false</code>.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>boolean</CODE></TD><TD><CODE><B><A HREF="#UseSubstitutions">getUseSubstitutions</A></B>()</CODE></TD><TD ALIGN="right" ></TD></TR><TR><TD ALIGN="right" VALIGN="top" WIDTH="1%"><CODE>void</CODE></TD><TD><CODE><B><A HREF="#UseSubstitutions">setUseSubstitutions</A></B>(boolean&nbsp;value)</CODE></TD><TD></TD>
</TR><TR><TD></TD><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Gets or sets a boolean value indicating whether to recognize and use substitutions within replacement patterns.
            The default value is <code>false</code>.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="FindReplaceOptions()"><!-- --></A><A NAME="FindReplaceOptions--"><!-- --></A><H3>
FindReplaceOptions</H3>
<PRE>
public <B>FindReplaceOptions</B>()</PRE>
<DL><DD><summary>
            Initializes a new instance of the FindReplaceOptions class with default settings.
            </summary><example><p><b>Example:</b></p>Shows how to recognize and use substitutions within replacement patterns.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.write("Jason gave money to Paul.");

String regex = "([A-z]+) gave money to ([A-z]+)";

FindReplaceOptions options = new FindReplaceOptions();
options.setUseSubstitutions(true);

// Using legacy mode does not support many advanced features, so we need to set it to 'false'.
options.setLegacyMode(false);

doc.getRange().replace(Pattern.compile(regex), "$2 took money from $1", options);

Assert.assertEquals(doc.getText(), "Paul took money from Jason.\f");</pre></example>
</DL>
<HR>

<A NAME="FindReplaceOptions(int)"><!-- --></A><A NAME="FindReplaceOptions-int-"><!-- --></A><H3>
FindReplaceOptions</H3>
<PRE>
public <B>FindReplaceOptions</B>(int&nbsp;direction)</PRE>
<DL><DD><summary>
            Initializes a new instance of the FindReplaceOptions class with the specified direction.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="direction"><CODE>direction</CODE> - A <cref><A HREF="FindReplaceDirection.html" title="Utility class in com.aspose.words">FindReplaceDirection</A></cref> value. The direction of the find and replace operation.</DD></DL>
</DL>
<HR>

<A NAME="FindReplaceOptions(com.aspose.words.IReplacingCallback)"><!-- --></A><A NAME="FindReplaceOptions-com.aspose.words.IReplacingCallback-"><!-- --></A><H3>
FindReplaceOptions</H3>
<PRE>
public <B>FindReplaceOptions</B>(<A HREF="IReplacingCallback.html" title="interface in com.aspose.words">IReplacingCallback</A>&nbsp;replacingCallback)</PRE>
<DL><DD><summary>
            Initializes a new instance of the FindReplaceOptions class with the specified replacing callback.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="replacingCallback"><CODE>replacingCallback</CODE> - The callback to use for replacing found text.</DD></DL><example><p><b>Example:</b></p>Shows how to track the order in which a text replacement operation traverses nodes.<pre>
public void order(boolean differentFirstPageHeaderFooter) throws Exception {
    Document doc = new Document(getMyDir() + "Header and footer types.docx");

    Section firstPageSection = doc.getFirstSection();

    ReplaceLog logger = new ReplaceLog();
    FindReplaceOptions options = new FindReplaceOptions();
    {
        options.setReplacingCallback(logger);
    }

    // Using a different header/footer for the first page will affect the search order.
    firstPageSection.getPageSetup().setDifferentFirstPageHeaderFooter(differentFirstPageHeaderFooter);
    doc.getRange().replace(Pattern.compile("(header|footer)"), "", options);

    if (differentFirstPageHeaderFooter)
        Assert.assertEquals("First headerFirst footerSecond headerSecond footerThird headerThird footer",
                logger.Text().replace("\r", ""));
    else
        Assert.assertEquals("Third headerFirst headerThird footerFirst footerSecond headerSecond footer",
                logger.Text().replace("\r", ""));
}

public static Object[][] orderDataProvider() throws Exception {
    return new Object[][]
            {
                    {false},
                    {true},
            };
}

/// &lt;summary&gt;
/// During a find-and-replace operation, records the contents of every node that has text that the operation 'finds',
/// in the state it is in before the replacement takes place.
/// This will display the order in which the text replacement operation traverses nodes.
/// &lt;/summary&gt;
private static class ReplaceLog implements IReplacingCallback {
    public int replacing(ReplacingArgs args) {
        mTextBuilder.append(args.getMatchNode().getText());
        return ReplaceAction.SKIP;
    }

    public String Text() {
        return mTextBuilder.toString();
    }

    private final StringBuilder mTextBuilder = new StringBuilder();
}</pre></example>
</DL>
<HR>

<A NAME="FindReplaceOptions(int,com.aspose.words.IReplacingCallback)"><!-- --></A><A NAME="FindReplaceOptions-int-com.aspose.words.IReplacingCallback-"><!-- --></A><H3>
FindReplaceOptions</H3>
<PRE>
public <B>FindReplaceOptions</B>(int&nbsp;direction, <A HREF="IReplacingCallback.html" title="interface in com.aspose.words">IReplacingCallback</A>&nbsp;replacingCallback)</PRE>
<DL><DD><summary>
            Initializes a new instance of the FindReplaceOptions class with the specified direction and replacing callback.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="direction"><CODE>direction</CODE> - A <cref><A HREF="FindReplaceDirection.html" title="Utility class in com.aspose.words">FindReplaceDirection</A></cref> value. The direction of the find and replace operation.</DD><DD param="replacingCallback"><CODE>replacingCallback</CODE> - The callback to use for replacing found text.</DD></DL>
</DL>
<HR>



<!-- ============ PROPERTY DETAIL ========== -->

<A NAME="property_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Property Getters/Setters Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ApplyFont"><!-- --></A><A NAME="getApplyFont()"><!-- --></A><A NAME="getApplyFont--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getApplyFont</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="Font.html" title="class in com.aspose.words">Font</A>&nbsp;<B>getApplyFont</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Text formatting applied to new content.
            </summary><example><p><b>Example:</b></p>Shows how to apply a different font to new content via FindReplaceOptions.<pre>
public void convertNumbersToHexadecimal() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    builder.getFont().setName("Arial");
    builder.writeln("Numbers that the find-and-replace operation will convert to hexadecimal and highlight:\n" +
            "123, 456, 789 and 17379.");

    // We can use a "FindReplaceOptions" object to modify the find-and-replace process.
    FindReplaceOptions options = new FindReplaceOptions();

    // Set the "HighlightColor" property to a background color that we want to apply to the operation's resulting text.
    options.getApplyFont().setHighlightColor(Color.GRAY);

    NumberHexer numberHexer = new NumberHexer();
    options.setReplacingCallback(numberHexer);

    int replacementCount = doc.getRange().replace(Pattern.compile("[0-9]+"), "", options);

    System.out.println(numberHexer.getLog());

    Assert.assertEquals(4, replacementCount);
    Assert.assertEquals("Numbers that the find-and-replace operation will convert to hexadecimal and highlight:\r" +
            "0x123, 0x456, 0x789 and 0x17,379.", doc.getText().trim());
}

/// &lt;summary&gt;
/// Replaces numeric find-and-replacement matches with their hexadecimal equivalents.
/// Maintains a log of every replacement.
/// &lt;/summary&gt;
private static class NumberHexer implements IReplacingCallback {
    public int replacing(ReplacingArgs args) {
        mCurrentReplacementNumber++;

        int number = Integer.parseInt(args.getMatch().group(0));

        args.setReplacement(MessageFormat.format("0x{0}", number));

        mLog.append(MessageFormat.format("Match #{0}", mCurrentReplacementNumber));
        mLog.append(MessageFormat.format("\tOriginal value:\t{0}", args.getMatch().group(0)));
        mLog.append(MessageFormat.format("\tReplacement:\t{0}", args.getReplacement()));
        mLog.append(MessageFormat.format("\tOffset in parent {0} node:\t{1}", args.getMatchNode().getNodeType(), args.getMatchOffset()));

        return ReplaceAction.REPLACE;
    }

    public String getLog() {
        return mLog.toString();
    }

    private int mCurrentReplacementNumber;
    private final StringBuilder mLog = new StringBuilder();
}</pre></example>
</DL>
<HR>

<A NAME="ApplyParagraphFormat"><!-- --></A><A NAME="getApplyParagraphFormat()"><!-- --></A><A NAME="getApplyParagraphFormat--"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getApplyParagraphFormat</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="ParagraphFormat.html" title="class in com.aspose.words">ParagraphFormat</A>&nbsp;<B>getApplyParagraphFormat</B>()
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Paragraph formatting applied to new content.
            </summary><example><p><b>Example:</b></p>Shows how to add formatting to paragraphs in which a find-and-replace operation has found matches.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Every paragraph that ends with a full stop like this one will be right aligned.");
builder.writeln("This one will not!");
builder.write("This one also will.");

ParagraphCollection paragraphs = doc.getFirstSection().getBody().getParagraphs();

Assert.assertEquals(ParagraphAlignment.LEFT, paragraphs.get(0).getParagraphFormat().getAlignment());
Assert.assertEquals(ParagraphAlignment.LEFT, paragraphs.get(1).getParagraphFormat().getAlignment());
Assert.assertEquals(ParagraphAlignment.LEFT, paragraphs.get(2).getParagraphFormat().getAlignment());

// We can use a "FindReplaceOptions" object to modify the find-and-replace process.
FindReplaceOptions options = new FindReplaceOptions();

// Set the "Alignment" property to "ParagraphAlignment.Right" to right-align every paragraph
// that contains a match that the find-and-replace operation finds.
options.getApplyParagraphFormat().setAlignment(ParagraphAlignment.RIGHT);

// Replace every full stop that is right before a paragraph break with an exclamation point.
int count = doc.getRange().replace(".&amp;p", "!&amp;p", options);

Assert.assertEquals(2, count);
Assert.assertEquals(ParagraphAlignment.RIGHT, paragraphs.get(0).getParagraphFormat().getAlignment());
Assert.assertEquals(ParagraphAlignment.LEFT, paragraphs.get(1).getParagraphFormat().getAlignment());
Assert.assertEquals(ParagraphAlignment.RIGHT, paragraphs.get(2).getParagraphFormat().getAlignment());
Assert.assertEquals("Every paragraph that ends with a full stop like this one will be right aligned!\r" +
        "This one will not!\r" +
        "This one also will!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="Direction"><!-- --></A><A NAME="getDirection()"><!-- --></A><A NAME="getDirection--"><!-- --></A><A NAME="setDirection(int)"><!-- --></A><A NAME="setDirection-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getDirection/setDirection</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getDirection</B>()&nbsp;/&nbsp;public void&nbsp;<B>setDirection</B>(int&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Selects direction for replace. Default value is <cref><A HREF="FindReplaceDirection.html#FORWARD" title="field in class com.aspose.words.FindReplaceDirection">FindReplaceDirection.FORWARD</A></cref>.
            The value of the property is <A HREF="FindReplaceDirection.html" title="Utility class in com.aspose.words">FindReplaceDirection</A> integer constant.</summary><example><p><b>Example:</b></p>Shows how to determine which direction a find-and-replace operation traverses the document in.<pre>
public void direction(int findReplaceDirection) throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Insert three runs which we can search for using a regex pattern.
    // Place one of those runs inside a text box.
    builder.writeln("Match 1.");
    builder.writeln("Match 2.");
    builder.writeln("Match 3.");
    builder.writeln("Match 4.");

    // We can use a "FindReplaceOptions" object to modify the find-and-replace process.
    FindReplaceOptions options = new FindReplaceOptions();

    // Assign a custom callback to the "ReplacingCallback" property.
    TextReplacementRecorder callback = new TextReplacementRecorder();
    options.setReplacingCallback(callback);

    // Set the "Direction" property to "FindReplaceDirection.Backward" to get the find-and-replace
    // operation to start from the end of the range, and traverse back to the beginning.
    // Set the "Direction" property to "FindReplaceDirection.Forward" to get the find-and-replace
    // operation to start from the beginning of the range, and traverse to the end.
    options.setDirection(findReplaceDirection);

    doc.getRange().replace(Pattern.compile("Match \\d*"), "Replacement", options);

    Assert.assertEquals("Replacement.\r" +
            "Replacement.\r" +
            "Replacement.\r" +
            "Replacement.", doc.getText().trim());

    switch (findReplaceDirection) {
        case FindReplaceDirection.FORWARD:
            Assert.assertEquals(new String[]{"Match 1", "Match 2", "Match 3", "Match 4"}, callback.getMatches().toArray());
            break;
        case FindReplaceDirection.BACKWARD:
            Assert.assertEquals(new String[]{"Match 4", "Match 3", "Match 2", "Match 1"}, callback.getMatches().toArray());
            break;
    }
}

public static Object[][] directionDataProvider() {
    return new Object[][]
            {
                    {FindReplaceDirection.BACKWARD},
                    {FindReplaceDirection.FORWARD},
            };
}

/// &lt;summary&gt;
/// Records all matches that occur during a find-and-replace operation in the order that they take place.
/// &lt;/summary&gt;
private static class TextReplacementRecorder implements IReplacingCallback {
    public int replacing(ReplacingArgs e) {
        mMatches.add(e.getMatch().group(0));
        return ReplaceAction.REPLACE;
    }

    public ArrayList&lt;String&gt; getMatches() {
        return mMatches;
    }
    private ArrayList&lt;String&gt; mMatches = new ArrayList&lt;&gt;();
}</pre></example>
</DL>
<HR>

<A NAME="FindWholeWordsOnly"><!-- --></A><A NAME="getFindWholeWordsOnly()"><!-- --></A><A NAME="getFindWholeWordsOnly--"><!-- --></A><A NAME="setFindWholeWordsOnly(boolean)"><!-- --></A><A NAME="setFindWholeWordsOnly-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getFindWholeWordsOnly/setFindWholeWordsOnly</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getFindWholeWordsOnly</B>()&nbsp;/&nbsp;public void&nbsp;<B>setFindWholeWordsOnly</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            True indicates the oldValue must be a standalone word.
            </summary><example><p><b>Example:</b></p>Shows how to toggle standalone word-only find-and-replace operations.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Jackson will meet you in Jacksonville.");

// We can use a "FindReplaceOptions" object to modify the find-and-replace process.
FindReplaceOptions options = new FindReplaceOptions();

// Set the "FindWholeWordsOnly" flag to "true" to replace the found text if it is not a part of another word.
// Set the "FindWholeWordsOnly" flag to "false" to replace all text regardless of its surroundings.
options.setFindWholeWordsOnly(findWholeWordsOnly);

doc.getRange().replace("Jackson", "Louis", options);

Assert.assertEquals(
        findWholeWordsOnly ? "Louis will meet you in Jacksonville." : "Louis will meet you in Louisville.",
        doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="IgnoreDeleted"><!-- --></A><A NAME="getIgnoreDeleted()"><!-- --></A><A NAME="getIgnoreDeleted--"><!-- --></A><A NAME="setIgnoreDeleted(boolean)"><!-- --></A><A NAME="setIgnoreDeleted-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getIgnoreDeleted/setIgnoreDeleted</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getIgnoreDeleted</B>()&nbsp;/&nbsp;public void&nbsp;<B>setIgnoreDeleted</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a boolean value indicating either to ignore text inside delete revisions.
            The default value is <code>false</code>.
            </summary><example><p><b>Example:</b></p>Shows how to include or ignore text inside delete revisions during a find-and-replace operation.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Hello world!");
builder.writeln("Hello again!");

// Start tracking revisions and remove the second paragraph, which will create a delete revision.
// That paragraph will persist in the document until we accept the delete revision.
doc.startTrackRevisions("John Doe", new Date());
doc.getFirstSection().getBody().getParagraphs().get(1).remove();
doc.stopTrackRevisions();

Assert.assertTrue(doc.getFirstSection().getBody().getParagraphs().get(1).isDeleteRevision());

// We can use a "FindReplaceOptions" object to modify the find and replace process.
FindReplaceOptions options = new FindReplaceOptions();

// Set the "IgnoreDeleted" flag to "true" to get the find-and-replace
// operation to ignore paragraphs that are delete revisions.
// Set the "IgnoreDeleted" flag to "false" to get the find-and-replace
// operation to also search for text inside delete revisions.
options.setIgnoreDeleted(ignoreTextInsideDeleteRevisions);

doc.getRange().replace("Hello", "Greetings", options);

Assert.assertEquals(
        ignoreTextInsideDeleteRevisions
                ? "Greetings world!\rHello again!"
                : "Greetings world!\rGreetings again!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="IgnoreFieldCodes"><!-- --></A><A NAME="getIgnoreFieldCodes()"><!-- --></A><A NAME="getIgnoreFieldCodes--"><!-- --></A><A NAME="setIgnoreFieldCodes(boolean)"><!-- --></A><A NAME="setIgnoreFieldCodes-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getIgnoreFieldCodes/setIgnoreFieldCodes</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getIgnoreFieldCodes</B>()&nbsp;/&nbsp;public void&nbsp;<B>setIgnoreFieldCodes</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a boolean value indicating either to ignore text inside field codes.
            The default value is <code>false</code>.
            </summary><remarks><p>This option affects only field codes (it does not ignore nodes between
            <cref><A HREF="NodeType.html#FIELD_SEPARATOR" title="field in class com.aspose.words.NodeType">NodeType.FIELD_SEPARATOR</A></cref> and <cref><A HREF="NodeType.html#FIELD_END" title="field in class com.aspose.words.NodeType">NodeType.FIELD_END</A></cref>).</p><p>To ignore whole field, please use corresponding option <cref><A HREF="#IgnoreFields" title="property in class com.aspose.words.FindReplaceOptions">IgnoreFields</A></cref>.</p></remarks><example><p><b>Example:</b></p>Shows how to ignore text inside field codes.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.insertField("INCLUDETEXT", "Test IT!");

FindReplaceOptions options = new FindReplaceOptions(); {options.setIgnoreFieldCodes(ignoreFieldCodes);}

// Replace 'T' in document ignoring text inside field code or not.
doc.getRange().replace(Pattern.compile("T"), "*", options);
System.out.println(doc.getText());

Assert.assertEquals(
        ignoreFieldCodes
                ? "INCLUDETEXT\u0014*est I*!"
                : "INCLUDE*EX*\u0014*est I*!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="IgnoreFields"><!-- --></A><A NAME="getIgnoreFields()"><!-- --></A><A NAME="getIgnoreFields--"><!-- --></A><A NAME="setIgnoreFields(boolean)"><!-- --></A><A NAME="setIgnoreFields-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getIgnoreFields/setIgnoreFields</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getIgnoreFields</B>()&nbsp;/&nbsp;public void&nbsp;<B>setIgnoreFields</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a boolean value indicating either to ignore text inside fields.
            The default value is <code>false</code>.
            </summary><remarks><p>This option affects whole field (all nodes between
            <cref><A HREF="NodeType.html#FIELD_START" title="field in class com.aspose.words.NodeType">NodeType.FIELD_START</A></cref> and <cref><A HREF="NodeType.html#FIELD_END" title="field in class com.aspose.words.NodeType">NodeType.FIELD_END</A></cref>).</p><p>To ignore only field codes, please use corresponding option <cref><A HREF="#IgnoreFieldCodes" title="property in class com.aspose.words.FindReplaceOptions">IgnoreFieldCodes</A></cref>.</p></remarks><example><p><b>Example:</b></p>Shows how to ignore text inside fields.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Hello world!");
builder.insertField("QUOTE", "Hello again!");

// We can use a "FindReplaceOptions" object to modify the find-and-replace process.
FindReplaceOptions options = new FindReplaceOptions();

// Set the "IgnoreFields" flag to "true" to get the find-and-replace
// operation to ignore text inside fields.
// Set the "IgnoreFields" flag to "false" to get the find-and-replace
// operation to also search for text inside fields.
options.setIgnoreFields(ignoreTextInsideFields);

doc.getRange().replace("Hello", "Greetings", options);

Assert.assertEquals(
        ignoreTextInsideFields
                ? "Greetings world!\r\u0013QUOTE\u0014Hello again!"
                : "Greetings world!\r\u0013QUOTE\u0014Greetings again!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="IgnoreFootnotes"><!-- --></A><A NAME="getIgnoreFootnotes()"><!-- --></A><A NAME="getIgnoreFootnotes--"><!-- --></A><A NAME="setIgnoreFootnotes(boolean)"><!-- --></A><A NAME="setIgnoreFootnotes-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getIgnoreFootnotes/setIgnoreFootnotes</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getIgnoreFootnotes</B>()&nbsp;/&nbsp;public void&nbsp;<B>setIgnoreFootnotes</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a boolean value indicating either to ignore footnotes.
            The default value is <code>false</code>.
            </summary><example><p><b>Example:</b></p>Shows how to ignore footnotes during a find-and-replace operation.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.write("Lorem ipsum dolor sit amet, consectetur adipiscing elit.");
builder.insertFootnote(FootnoteType.FOOTNOTE, "Lorem ipsum dolor sit amet, consectetur adipiscing elit.");

builder.insertParagraph();

builder.write("Lorem ipsum dolor sit amet, consectetur adipiscing elit.");
builder.insertFootnote(FootnoteType.ENDNOTE, "Lorem ipsum dolor sit amet, consectetur adipiscing elit.");

// Set the "IgnoreFootnotes" flag to "true" to get the find-and-replace
// operation to ignore text inside footnotes.
// Set the "IgnoreFootnotes" flag to "false" to get the find-and-replace
// operation to also search for text inside footnotes.
FindReplaceOptions options = new FindReplaceOptions();
{
    options.setIgnoreFootnotes(isIgnoreFootnotes);
}
doc.getRange().replace("Lorem ipsum", "Replaced Lorem ipsum", options);</pre></example>
</DL>
<HR>

<A NAME="IgnoreInserted"><!-- --></A><A NAME="getIgnoreInserted()"><!-- --></A><A NAME="getIgnoreInserted--"><!-- --></A><A NAME="setIgnoreInserted(boolean)"><!-- --></A><A NAME="setIgnoreInserted-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getIgnoreInserted/setIgnoreInserted</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getIgnoreInserted</B>()&nbsp;/&nbsp;public void&nbsp;<B>setIgnoreInserted</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a boolean value indicating either to ignore text inside insert revisions.
            The default value is <code>false</code>.
            </summary><example><p><b>Example:</b></p>Shows how to include or ignore text inside insert revisions during a find-and-replace operation.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Hello world!");

// Start tracking revisions and insert a paragraph. That paragraph will be an insert revision.
doc.startTrackRevisions("John Doe", new Date());
builder.writeln("Hello again!");
doc.stopTrackRevisions();

Assert.assertTrue(doc.getFirstSection().getBody().getParagraphs().get(1).isInsertRevision());

// We can use a "FindReplaceOptions" object to modify the find-and-replace process.
FindReplaceOptions options = new FindReplaceOptions();

// Set the "IgnoreInserted" flag to "true" to get the find-and-replace
// operation to ignore paragraphs that are insert revisions.
// Set the "IgnoreInserted" flag to "false" to get the find-and-replace
// operation to also search for text inside insert revisions.
options.setIgnoreInserted(ignoreTextInsideInsertRevisions);

doc.getRange().replace("Hello", "Greetings", options);

Assert.assertEquals(
        ignoreTextInsideInsertRevisions
                ? "Greetings world!\rHello again!"
                : "Greetings world!\rGreetings again!", doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="IgnoreShapes"><!-- --></A><A NAME="getIgnoreShapes()"><!-- --></A><A NAME="getIgnoreShapes--"><!-- --></A><A NAME="setIgnoreShapes(boolean)"><!-- --></A><A NAME="setIgnoreShapes-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getIgnoreShapes/setIgnoreShapes</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getIgnoreShapes</B>()&nbsp;/&nbsp;public void&nbsp;<B>setIgnoreShapes</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary><p>Gets or sets a boolean value indicating either to ignore shapes within a text.</p><p>The default value is <code>false</code>.</p></summary><example><p><b>Example:</b></p>Shows how to ignore shapes while replacing text.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.write("Lorem ipsum dolor sit amet, consectetur adipiscing elit.");
builder.insertShape(ShapeType.BALLOON, 200.0, 200.0);
builder.write("Lorem ipsum dolor sit amet, consectetur adipiscing elit.");

FindReplaceOptions findReplaceOptions = new FindReplaceOptions(); { findReplaceOptions.setIgnoreShapes(true); }
builder.getDocument().getRange().replace("Lorem ipsum dolor sit amet, consectetur adipiscing elit.Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit.", findReplaceOptions);
Assert.assertEquals("Lorem ipsum dolor sit amet, consectetur adipiscing elit.", builder.getDocument().getText().trim());</pre></example>
</DL>
<HR>

<A NAME="IgnoreStructuredDocumentTags"><!-- --></A><A NAME="getIgnoreStructuredDocumentTags()"><!-- --></A><A NAME="getIgnoreStructuredDocumentTags--"><!-- --></A><A NAME="setIgnoreStructuredDocumentTags(boolean)"><!-- --></A><A NAME="setIgnoreStructuredDocumentTags-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getIgnoreStructuredDocumentTags/setIgnoreStructuredDocumentTags</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getIgnoreStructuredDocumentTags</B>()&nbsp;/&nbsp;public void&nbsp;<B>setIgnoreStructuredDocumentTags</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a boolean value indicating either to ignore content of <cref><A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A></cref>.
            The default value is <code>false</code>.
            </summary><remarks><p>
            When this option is set to <code>true</code>, the content of <cref><A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A></cref>
            will be treated as a simple text.
            </p><p>
            Otherwise, <cref><A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A></cref> will be processed as standalone Story
            and replacing pattern will be searched separately for each <cref><A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A></cref>,
            so that if pattern crosses a <cref><A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A></cref>, then replacement will not
            be performed for such pattern.
            </p></remarks><example><p><b>Example:</b></p>Shows how to ignore content of tags from replacement.<pre>
Document doc = new Document(getMyDir() + "Structured document tags.docx");

// This paragraph contains SDT.
Paragraph p = (Paragraph)doc.getFirstSection().getBody().getChild(NodeType.PARAGRAPH, 2, true);
String textToSearch = p.toString(SaveFormat.TEXT).trim();

FindReplaceOptions options = new FindReplaceOptions();
options.setIgnoreStructuredDocumentTags(true);
doc.getRange().replace(textToSearch, "replacement", options);

doc.save(getArtifactsDir() + "StructuredDocumentTag.IgnoreStructuredDocumentTags.docx");</pre></example>
</DL>
<HR>

<A NAME="LegacyMode"><!-- --></A><A NAME="getLegacyMode()"><!-- --></A><A NAME="getLegacyMode--"><!-- --></A><A NAME="setLegacyMode(boolean)"><!-- --></A><A NAME="setLegacyMode-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getLegacyMode/setLegacyMode</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getLegacyMode</B>()&nbsp;/&nbsp;public void&nbsp;<B>setLegacyMode</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a boolean value indicating that old find/replace algorithm is used.
            </summary><remarks>
            Use this flag if you need exactly the same behavior as before advanced find/replace feature was introduced.
            Note that old algorithm does not support advanced features such as replace with breaks, apply formatting and so on.
            </remarks><example><p><b>Example:</b></p>Shows how to recognize and use substitutions within replacement patterns.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.write("Jason gave money to Paul.");

String regex = "([A-z]+) gave money to ([A-z]+)";

FindReplaceOptions options = new FindReplaceOptions();
options.setUseSubstitutions(true);

// Using legacy mode does not support many advanced features, so we need to set it to 'false'.
options.setLegacyMode(false);

doc.getRange().replace(Pattern.compile(regex), "$2 took money from $1", options);

Assert.assertEquals(doc.getText(), "Paul took money from Jason.\f");</pre></example>
</DL>
<HR>

<A NAME="MatchCase"><!-- --></A><A NAME="getMatchCase()"><!-- --></A><A NAME="getMatchCase--"><!-- --></A><A NAME="setMatchCase(boolean)"><!-- --></A><A NAME="setMatchCase-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getMatchCase/setMatchCase</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getMatchCase</B>()&nbsp;/&nbsp;public void&nbsp;<B>setMatchCase</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            True indicates case-sensitive comparison, false indicates case-insensitive comparison.
            </summary><example><p><b>Example:</b></p>Shows how to toggle case sensitivity when performing a find-and-replace operation.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("Ruby bought a ruby necklace.");

// We can use a "FindReplaceOptions" object to modify the find-and-replace process.
FindReplaceOptions options = new FindReplaceOptions();

// Set the "MatchCase" flag to "true" to apply case sensitivity while finding strings to replace.
// Set the "MatchCase" flag to "false" to ignore character case while searching for text to replace.
options.setMatchCase(matchCase);

doc.getRange().replace("Ruby", "Jade", options);

Assert.assertEquals(matchCase ? "Jade bought a ruby necklace." : "Jade bought a Jade necklace.",
        doc.getText().trim());</pre></example>
</DL>
<HR>

<A NAME="ReplacementFormat"><!-- --></A><A NAME="getReplacementFormat()"><!-- --></A><A NAME="getReplacementFormat--"><!-- --></A><A NAME="setReplacementFormat(int)"><!-- --></A><A NAME="setReplacementFormat-int-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getReplacementFormat/setReplacementFormat</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>getReplacementFormat</B>()&nbsp;/&nbsp;public void&nbsp;<B>setReplacementFormat</B>(int&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Specifies format of the replacement. Default is <cref><A HREF="ReplacementFormat.html#TEXT" title="field in class com.aspose.words.ReplacementFormat">ReplacementFormat.TEXT</A></cref>.
            The value of the property is <A HREF="ReplacementFormat.html" title="Utility class in com.aspose.words">ReplacementFormat</A> integer constant.</summary><remarks>
            Has effect only when using in <cref><A HREF="Replacer.html" title="class in com.aspose.words">Replacer</A></cref></remarks>
</DL>
<HR>

<A NAME="ReplacingCallback"><!-- --></A><A NAME="getReplacingCallback()"><!-- --></A><A NAME="getReplacingCallback--"><!-- --></A><A NAME="setReplacingCallback(com.aspose.words.IReplacingCallback)"><!-- --></A><A NAME="setReplacingCallback-com.aspose.words.IReplacingCallback-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getReplacingCallback/setReplacingCallback</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public <A HREF="IReplacingCallback.html" title="interface in com.aspose.words">IReplacingCallback</A>&nbsp;<B>getReplacingCallback</B>()&nbsp;/&nbsp;public void&nbsp;<B>setReplacingCallback</B>(<A HREF="IReplacingCallback.html" title="interface in com.aspose.words">IReplacingCallback</A>&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            The user-defined method which is called before every replace occurrence.
            </summary><example><p><b>Example:</b></p>Shows how to replace all occurrences of a regular expression pattern with another string, while tracking all such replacements.<pre>
public void replaceWithCallback() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    builder.writeln("Our new location in New York City is opening tomorrow. " +
            "Hope to see all our NYC-based customers at the opening!");

    // We can use a "FindReplaceOptions" object to modify the find-and-replace process.
    FindReplaceOptions options = new FindReplaceOptions();

    // Set a callback that tracks any replacements that the "Replace" method will make.
    TextFindAndReplacementLogger logger = new TextFindAndReplacementLogger();
    options.setReplacingCallback(logger);

    doc.getRange().replace(Pattern.compile("New York City|NYC"), "Washington", options);

    Assert.assertEquals("Our new location in (Old value:\"New York City\") Washington is opening tomorrow. " +
            "Hope to see all our (Old value:\"NYC\") Washington-based customers at the opening!", doc.getText().trim());

    Assert.assertEquals("\"New York City\" converted to \"Washington\" 20 characters into a 21 node." +
            "\"NYC\" converted to \"Washington\" 42 characters into a 21 node.", logger.getLog().trim());
}

/// &lt;summary&gt;
/// Maintains a log of every text replacement done by a find-and-replace operation
/// and notes the original matched text's value.
/// &lt;/summary&gt;
private static class TextFindAndReplacementLogger implements IReplacingCallback {
    public int replacing(ReplacingArgs args) {
        mLog.append(MessageFormat.format("\"{0}\" converted to \"{1}\" {2} characters into a {3} node.", args.getMatch().group(0), args.getReplacement(), args.getMatchOffset(), args.getMatchNode().getNodeType()));

        args.setReplacement(MessageFormat.format("(Old value:\"{0}\") {1}", args.getMatch().group(0), args.getReplacement()));
        return ReplaceAction.REPLACE;
    }

    public String getLog() {
        return mLog.toString();
    }

    private final StringBuilder mLog = new StringBuilder();
}</pre></example><example><p><b>Example:</b></p>Shows how to apply a different font to new content via FindReplaceOptions.<pre>
public void convertNumbersToHexadecimal() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    builder.getFont().setName("Arial");
    builder.writeln("Numbers that the find-and-replace operation will convert to hexadecimal and highlight:\n" +
            "123, 456, 789 and 17379.");

    // We can use a "FindReplaceOptions" object to modify the find-and-replace process.
    FindReplaceOptions options = new FindReplaceOptions();

    // Set the "HighlightColor" property to a background color that we want to apply to the operation's resulting text.
    options.getApplyFont().setHighlightColor(Color.GRAY);

    NumberHexer numberHexer = new NumberHexer();
    options.setReplacingCallback(numberHexer);

    int replacementCount = doc.getRange().replace(Pattern.compile("[0-9]+"), "", options);

    System.out.println(numberHexer.getLog());

    Assert.assertEquals(4, replacementCount);
    Assert.assertEquals("Numbers that the find-and-replace operation will convert to hexadecimal and highlight:\r" +
            "0x123, 0x456, 0x789 and 0x17,379.", doc.getText().trim());
}

/// &lt;summary&gt;
/// Replaces numeric find-and-replacement matches with their hexadecimal equivalents.
/// Maintains a log of every replacement.
/// &lt;/summary&gt;
private static class NumberHexer implements IReplacingCallback {
    public int replacing(ReplacingArgs args) {
        mCurrentReplacementNumber++;

        int number = Integer.parseInt(args.getMatch().group(0));

        args.setReplacement(MessageFormat.format("0x{0}", number));

        mLog.append(MessageFormat.format("Match #{0}", mCurrentReplacementNumber));
        mLog.append(MessageFormat.format("\tOriginal value:\t{0}", args.getMatch().group(0)));
        mLog.append(MessageFormat.format("\tReplacement:\t{0}", args.getReplacement()));
        mLog.append(MessageFormat.format("\tOffset in parent {0} node:\t{1}", args.getMatchNode().getNodeType(), args.getMatchOffset()));

        return ReplaceAction.REPLACE;
    }

    public String getLog() {
        return mLog.toString();
    }

    private int mCurrentReplacementNumber;
    private final StringBuilder mLog = new StringBuilder();
}</pre></example>
</DL>
<HR>

<A NAME="SmartParagraphBreakReplacement"><!-- --></A><A NAME="getSmartParagraphBreakReplacement()"><!-- --></A><A NAME="getSmartParagraphBreakReplacement--"><!-- --></A><A NAME="setSmartParagraphBreakReplacement(boolean)"><!-- --></A><A NAME="setSmartParagraphBreakReplacement-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getSmartParagraphBreakReplacement/setSmartParagraphBreakReplacement</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getSmartParagraphBreakReplacement</B>()&nbsp;/&nbsp;public void&nbsp;<B>setSmartParagraphBreakReplacement</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary><p>Gets or sets a boolean value indicating either it is allowed to replace paragraph break
            when there is no next sibling paragraph.</p><p>The default value is <code>false</code>.</p></summary><remarks>
            This option allows to replace paragraph break when there is no next sibling paragraph to which all child
            nodes can be moved, by finding any (not necessarily sibling) next paragraph after the paragraph being replaced.
            </remarks><example><p><b>Example:</b></p>Shows how to remove paragraph from a table cell with a nested table.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

// Create table with paragraph and inner table in first cell.
builder.startTable();
builder.insertCell();
builder.write("TEXT1");
builder.startTable();
builder.insertCell();
builder.endTable();
builder.endTable();
builder.writeln();

FindReplaceOptions options = new FindReplaceOptions();
// When the following option is set to 'true', Aspose.Words will remove paragraph's text
// completely with its paragraph mark. Otherwise, Aspose.Words will mimic Word and remove
// only paragraph's text and leaves the paragraph mark intact (when a table follows the text).
options.setSmartParagraphBreakReplacement(isSmartParagraphBreakReplacement);
doc.getRange().replace("TEXT1&amp;p", "", options);

doc.save(getArtifactsDir() + "Table.RemoveParagraphTextAndMark.docx");</pre></example>
</DL>
<HR>

<A NAME="UseLegacyOrder"><!-- --></A><A NAME="getUseLegacyOrder()"><!-- --></A><A NAME="getUseLegacyOrder--"><!-- --></A><A NAME="setUseLegacyOrder(boolean)"><!-- --></A><A NAME="setUseLegacyOrder-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getUseLegacyOrder/setUseLegacyOrder</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getUseLegacyOrder</B>()&nbsp;/&nbsp;public void&nbsp;<B>setUseLegacyOrder</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            True indicates that a text search is performed sequentially from top to bottom considering the text boxes.
            Default value is <code>false</code>.
            </summary><example><p><b>Example:</b></p>Shows how to change the searching order of nodes when performing a find-and-replace text operation.<pre>
public void useLegacyOrder(boolean useLegacyOrder) throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // Insert three runs which we can search for using a regex pattern.
    // Place one of those runs inside a text box.
    builder.writeln("[tag 1]");
    Shape textBox = builder.insertShape(ShapeType.TEXT_BOX, 100.0, 50.0);
    builder.writeln("[tag 2]");
    builder.moveTo(textBox.getFirstParagraph());
    builder.write("[tag 3]");

    // We can use a "FindReplaceOptions" object to modify the find-and-replace process.
    FindReplaceOptions options = new FindReplaceOptions();

    // Assign a custom callback to the "ReplacingCallback" property.
    TextReplacementTracker callback = new TextReplacementTracker();
    options.setReplacingCallback(callback);

    // If we set the "UseLegacyOrder" property to "true", the
    // find-and-replace operation will go through all the runs outside of a text box
    // before going through the ones inside a text box.
    // If we set the "UseLegacyOrder" property to "false", the
    // find-and-replace operation will go over all the runs in a range in sequential order.
    options.setUseLegacyOrder(useLegacyOrder);

    doc.getRange().replace("\\[tag d*\\]", "", options);
}

public static Object[][] useLegacyOrderDataProvider() {
    return new Object[][]
            {
                    {true},
                    {false},
            };
}

/// &lt;summary&gt;
/// Records the order of all matches that occur during a find-and-replace operation.
/// &lt;/summary&gt;
private static class TextReplacementTracker implements IReplacingCallback {
    public int replacing(ReplacingArgs e) {
        mMatches.add(e.getMatch().group(1));
        return ReplaceAction.REPLACE;
    }

    public ArrayList&lt;String&gt; getMatches() {
        return mMatches;
    }

    private ArrayList&lt;String&gt; mMatches;
}</pre></example>
</DL>
<HR>

<A NAME="UseSubstitutions"><!-- --></A><A NAME="getUseSubstitutions()"><!-- --></A><A NAME="getUseSubstitutions--"><!-- --></A><A NAME="setUseSubstitutions(boolean)"><!-- --></A><A NAME="setUseSubstitutions-boolean-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>getUseSubstitutions/setUseSubstitutions</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public boolean&nbsp;<B>getUseSubstitutions</B>()&nbsp;/&nbsp;public void&nbsp;<B>setUseSubstitutions</B>(boolean&nbsp;value)
</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Gets or sets a boolean value indicating whether to recognize and use substitutions within replacement patterns.
            The default value is <code>false</code>.
            </summary><remarks>
            For the details on substitution elements please refer to:
            https://docs.microsoft.com/en-us/dotnet/standard/base-types/substitutions-in-regular-expressions.
            </remarks><example><p><b>Example:</b></p>Shows how to recognize and use substitutions within replacement patterns.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.write("Jason gave money to Paul.");

String regex = "([A-z]+) gave money to ([A-z]+)";

FindReplaceOptions options = new FindReplaceOptions();
options.setUseSubstitutions(true);

// Using legacy mode does not support many advanced features, so we need to set it to 'false'.
options.setLegacyMode(false);

doc.getRange().replace(Pattern.compile(regex), "$2 took money from $1", options);

Assert.assertEquals(doc.getText(), "Paul took money from Jason.\f");</pre></example><example><p><b>Example:</b></p>Shows how to replace the text with substitutions.<pre>
Document doc = new Document();
DocumentBuilder builder = new DocumentBuilder(doc);

builder.writeln("John sold a car to Paul.");
builder.writeln("Jane sold a house to Joe.");

// We can use a "FindReplaceOptions" object to modify the find-and-replace process.
FindReplaceOptions options = new FindReplaceOptions();

// Set the "UseSubstitutions" property to "true" to get
// the find-and-replace operation to recognize substitution elements.
// Set the "UseSubstitutions" property to "false" to ignore substitution elements.
options.setUseSubstitutions(useSubstitutions);

doc.getRange().replace(Pattern.compile("([A-z]+) sold a ([A-z]+) to ([A-z]+)"), "$3 bought a $2 from $1", options);

Assert.assertEquals(
        useSubstitutions
                ? "Paul bought a car from John.\rJoe bought a house from Jane."
                : "$3 bought a $2 from $1.\r$3 bought a $2 from $1.", doc.getText().trim());</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>