<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"
><HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<!-- Generated by javadoc - compatibility string-->
<!-- Generated by Aspose.JavaDoc 19 Jul 2025 -->
<TITLE>DocumentVisitor</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style"></HEAD>
<BODY BGCOLOR="white">
<!-- ======== START OF CLASS DATA ======== -->
<H2><a href="package-summary.html"><FONT SIZE="-1">
com.aspose.words
</FONT></a><BR>Class DocumentVisitor</H2>
<PRE>
java.lang.Object
    <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>com.aspose.words.DocumentVisitor</B>
</PRE>
<HR>
<DL>
<DT><PRE>public abstract class <B>DocumentVisitor </B><DT>extends java.lang.Object</DL>
</PRE>

<P>

<summary>
            Base class for custom document visitors.
            <p>To learn more, visit the <a href="https://docs.aspose.com/words/net/aspose-words-document-object-model/">Aspose.Words Document Object Model (DOM)</a> documentation article.</p></summary><remarks><p>With <cref><i>DocumentVisitor</i></cref> you can define and execute custom operations
            that require enumeration over the document tree.</p><p>For example, Aspose.Words uses <cref><i>DocumentVisitor</i></cref> internally for saving <cref><A HREF="Document.html" title="class in com.aspose.words">Document</A></cref>
            in various formats and for other operations like finding fields or bookmarks over
            a fragment of a document.</p><p>To use <cref><i>DocumentVisitor</i></cref>:</p><ol><li>Create a class derived from <cref><i>DocumentVisitor</i></cref>.</li><li>Override and provide implementations for some or all of the VisitXXX methods
            to perform some custom operations.</li><li>Call <cref><A HREF="Node.html#accept(com.aspose.words.DocumentVisitor)" title="method in class com.aspose.words.Node">Node.accept(com.aspose.words.DocumentVisitor)</A></cref> on the <cref><A HREF="Node.html" title="class in com.aspose.words">Node</A></cref> that
            you want to start the enumeration from.</li></ol><p><cref><i>DocumentVisitor</i></cref> provides default implementations for all of the VisitXXX methods 
            to make it easier to create new document visitors as only the methods required for the particular
            visitor need to be overridden. It is not necessary to override all of the visitor methods.</p><p>For more information see the Visitor design pattern.</p></remarks><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
<HR>
<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" RULES="GROUPS" FRAME="BOX" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<COLGROUP></COLGROUP><COLGROUP SPAN="2"></COLGROUP><THEAD><TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR></THEAD>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitAbsolutePositionTab(com.aspose.words.AbsolutePositionTab)">visitAbsolutePositionTab</A></B>(<A HREF="AbsolutePositionTab.html" title="class in com.aspose.words">AbsolutePositionTab</A>&nbsp;tab)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a <cref><A HREF="AbsolutePositionTab.html" title="class in com.aspose.words">AbsolutePositionTab</A></cref> node is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitBodyEnd(com.aspose.words.Body)">visitBodyEnd</A></B>(<A HREF="Body.html" title="class in com.aspose.words">Body</A>&nbsp;body)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of the main text story in a section has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitBodyStart(com.aspose.words.Body)">visitBodyStart</A></B>(<A HREF="Body.html" title="class in com.aspose.words">Body</A>&nbsp;body)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of the main text story in a section has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitBookmarkEnd(com.aspose.words.BookmarkEnd)">visitBookmarkEnd</A></B>(<A HREF="BookmarkEnd.html" title="class in com.aspose.words">BookmarkEnd</A>&nbsp;bookmarkEnd)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when an end of a bookmark is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitBookmarkStart(com.aspose.words.BookmarkStart)">visitBookmarkStart</A></B>(<A HREF="BookmarkStart.html" title="class in com.aspose.words">BookmarkStart</A>&nbsp;bookmarkStart)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a start of a bookmark is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitBuildingBlockEnd(com.aspose.words.BuildingBlock)">visitBuildingBlockEnd</A></B>(<A HREF="BuildingBlock.html" title="class in com.aspose.words">BuildingBlock</A>&nbsp;block)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a building block has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitBuildingBlockStart(com.aspose.words.BuildingBlock)">visitBuildingBlockStart</A></B>(<A HREF="BuildingBlock.html" title="class in com.aspose.words">BuildingBlock</A>&nbsp;block)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a building block has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitCellEnd(com.aspose.words.Cell)">visitCellEnd</A></B>(<A HREF="Cell.html" title="class in com.aspose.words">Cell</A>&nbsp;cell)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a table cell has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitCellStart(com.aspose.words.Cell)">visitCellStart</A></B>(<A HREF="Cell.html" title="class in com.aspose.words">Cell</A>&nbsp;cell)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a table cell has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitCommentEnd(com.aspose.words.Comment)">visitCommentEnd</A></B>(<A HREF="Comment.html" title="class in com.aspose.words">Comment</A>&nbsp;comment)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a comment text has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitCommentRangeEnd(com.aspose.words.CommentRangeEnd)">visitCommentRangeEnd</A></B>(<A HREF="CommentRangeEnd.html" title="class in com.aspose.words">CommentRangeEnd</A>&nbsp;commentRangeEnd)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when the end of a commented range of text is encountered.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitCommentRangeStart(com.aspose.words.CommentRangeStart)">visitCommentRangeStart</A></B>(<A HREF="CommentRangeStart.html" title="class in com.aspose.words">CommentRangeStart</A>&nbsp;commentRangeStart)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when the start of a commented range of text is encountered.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitCommentStart(com.aspose.words.Comment)">visitCommentStart</A></B>(<A HREF="Comment.html" title="class in com.aspose.words">Comment</A>&nbsp;comment)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a comment text has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitDocumentEnd(com.aspose.words.Document)">visitDocumentEnd</A></B>(<A HREF="Document.html" title="class in com.aspose.words">Document</A>&nbsp;doc)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of the document has finished.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitDocumentStart(com.aspose.words.Document)">visitDocumentStart</A></B>(<A HREF="Document.html" title="class in com.aspose.words">Document</A>&nbsp;doc)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of the document has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitEditableRangeEnd(com.aspose.words.EditableRangeEnd)">visitEditableRangeEnd</A></B>(<A HREF="EditableRangeEnd.html" title="class in com.aspose.words">EditableRangeEnd</A>&nbsp;editableRangeEnd)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when an end of an editable range is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitEditableRangeStart(com.aspose.words.EditableRangeStart)">visitEditableRangeStart</A></B>(<A HREF="EditableRangeStart.html" title="class in com.aspose.words">EditableRangeStart</A>&nbsp;editableRangeStart)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a start of an editable range is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitFieldEnd(com.aspose.words.FieldEnd)">visitFieldEnd</A></B>(<A HREF="FieldEnd.html" title="class in com.aspose.words">FieldEnd</A>&nbsp;fieldEnd)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a field ends in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitFieldSeparator(com.aspose.words.FieldSeparator)">visitFieldSeparator</A></B>(<A HREF="FieldSeparator.html" title="class in com.aspose.words">FieldSeparator</A>&nbsp;fieldSeparator)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a field separator is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitFieldStart(com.aspose.words.FieldStart)">visitFieldStart</A></B>(<A HREF="FieldStart.html" title="class in com.aspose.words">FieldStart</A>&nbsp;fieldStart)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a field starts in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitFootnoteEnd(com.aspose.words.Footnote)">visitFootnoteEnd</A></B>(<A HREF="Footnote.html" title="class in com.aspose.words">Footnote</A>&nbsp;footnote)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a footnote or endnote text has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitFootnoteStart(com.aspose.words.Footnote)">visitFootnoteStart</A></B>(<A HREF="Footnote.html" title="class in com.aspose.words">Footnote</A>&nbsp;footnote)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a footnote or endnote text has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitFormField(com.aspose.words.FormField)">visitFormField</A></B>(<A HREF="FormField.html" title="class in com.aspose.words">FormField</A>&nbsp;formField)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a form field is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitGlossaryDocumentEnd(com.aspose.words.GlossaryDocument)">visitGlossaryDocumentEnd</A></B>(<A HREF="GlossaryDocument.html" title="class in com.aspose.words">GlossaryDocument</A>&nbsp;glossary)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a glossary document has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitGlossaryDocumentStart(com.aspose.words.GlossaryDocument)">visitGlossaryDocumentStart</A></B>(<A HREF="GlossaryDocument.html" title="class in com.aspose.words">GlossaryDocument</A>&nbsp;glossary)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a glossary document has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitGroupShapeEnd(com.aspose.words.GroupShape)">visitGroupShapeEnd</A></B>(<A HREF="GroupShape.html" title="class in com.aspose.words">GroupShape</A>&nbsp;groupShape)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a group shape has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitGroupShapeStart(com.aspose.words.GroupShape)">visitGroupShapeStart</A></B>(<A HREF="GroupShape.html" title="class in com.aspose.words">GroupShape</A>&nbsp;groupShape)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a group shape has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitHeaderFooterEnd(com.aspose.words.HeaderFooter)">visitHeaderFooterEnd</A></B>(<A HREF="HeaderFooter.html" title="class in com.aspose.words">HeaderFooter</A>&nbsp;headerFooter)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a header or footer in a section has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitHeaderFooterStart(com.aspose.words.HeaderFooter)">visitHeaderFooterStart</A></B>(<A HREF="HeaderFooter.html" title="class in com.aspose.words">HeaderFooter</A>&nbsp;headerFooter)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a header or footer in a section has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitOfficeMathEnd(com.aspose.words.OfficeMath)">visitOfficeMathEnd</A></B>(<A HREF="OfficeMath.html" title="class in com.aspose.words">OfficeMath</A>&nbsp;officeMath)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a Office Math object has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitOfficeMathStart(com.aspose.words.OfficeMath)">visitOfficeMathStart</A></B>(<A HREF="OfficeMath.html" title="class in com.aspose.words">OfficeMath</A>&nbsp;officeMath)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a Office Math object has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitParagraphEnd(com.aspose.words.Paragraph)">visitParagraphEnd</A></B>(<A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A>&nbsp;paragraph)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a paragraph has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitParagraphStart(com.aspose.words.Paragraph)">visitParagraphStart</A></B>(<A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A>&nbsp;paragraph)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a paragraph has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitRowEnd(com.aspose.words.Row)">visitRowEnd</A></B>(<A HREF="Row.html" title="class in com.aspose.words">Row</A>&nbsp;row)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a table row has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitRowStart(com.aspose.words.Row)">visitRowStart</A></B>(<A HREF="Row.html" title="class in com.aspose.words">Row</A>&nbsp;row)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a table row has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitRun(com.aspose.words.Run)">visitRun</A></B>(<A HREF="Run.html" title="class in com.aspose.words">Run</A>&nbsp;run)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a run of text in the is encountered.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitSectionEnd(com.aspose.words.Section)">visitSectionEnd</A></B>(<A HREF="Section.html" title="class in com.aspose.words">Section</A>&nbsp;section)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a section has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitSectionStart(com.aspose.words.Section)">visitSectionStart</A></B>(<A HREF="Section.html" title="class in com.aspose.words">Section</A>&nbsp;section)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a section has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitShapeEnd(com.aspose.words.Shape)">visitShapeEnd</A></B>(<A HREF="Shape.html" title="class in com.aspose.words">Shape</A>&nbsp;shape)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a shape has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitShapeStart(com.aspose.words.Shape)">visitShapeStart</A></B>(<A HREF="Shape.html" title="class in com.aspose.words">Shape</A>&nbsp;shape)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a shape has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitSmartTagEnd(com.aspose.words.SmartTag)">visitSmartTagEnd</A></B>(<A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A>&nbsp;smartTag)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a smart tag has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitSmartTagStart(com.aspose.words.SmartTag)">visitSmartTagStart</A></B>(<A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A>&nbsp;smartTag)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a smart tag has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitSpecialChar(com.aspose.words.SpecialChar)">visitSpecialChar</A></B>(<A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A>&nbsp;specialChar)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a <cref><A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A></cref> node is encountered in the document.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitStructuredDocumentTagEnd(com.aspose.words.StructuredDocumentTag)">visitStructuredDocumentTagEnd</A></B>(<A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A>&nbsp;sdt)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a structured document tag has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitStructuredDocumentTagRangeEnd(com.aspose.words.StructuredDocumentTagRangeEnd)">visitStructuredDocumentTagRangeEnd</A></B>(<A HREF="StructuredDocumentTagRangeEnd.html" title="class in com.aspose.words">StructuredDocumentTagRangeEnd</A>&nbsp;sdtRangeEnd)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a StructuredDocumentTagRangeEnd is encountered.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitStructuredDocumentTagRangeStart(com.aspose.words.StructuredDocumentTagRangeStart)">visitStructuredDocumentTagRangeStart</A></B>(<A HREF="StructuredDocumentTagRangeStart.html" title="class in com.aspose.words">StructuredDocumentTagRangeStart</A>&nbsp;sdtRangeStart)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a StructuredDocumentTagRangeStart is encountered.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitStructuredDocumentTagStart(com.aspose.words.StructuredDocumentTag)">visitStructuredDocumentTagStart</A></B>(<A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A>&nbsp;sdt)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a structured document tag has started.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitSubDocument(com.aspose.words.SubDocument)">visitSubDocument</A></B>(<A HREF="SubDocument.html" title="class in com.aspose.words">SubDocument</A>&nbsp;subDocument)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when a sub-document is encountered.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitTableEnd(com.aspose.words.Table)">visitTableEnd</A></B>(<A HREF="Table.html" title="class in com.aspose.words">Table</A>&nbsp;table)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a table has ended.
            </TD>
</TR></TBODY>

<TBODY><TR BGCOLOR="white" CLASS="TableRowColor">
<TD ROWSPAN="2" ALIGN="right" VALIGN="top" WIDTH="1%">
<CODE>int</CODE></TD><TD><CODE><B><A HREF="#visitTableStart(com.aspose.words.Table)">visitTableStart</A></B>(<A HREF="Table.html" title="class in com.aspose.words">Table</A>&nbsp;table)</CODE></TD><TD ALIGN="right" ></TD>
</TR><TR><TD COLSPAN="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            Called when enumeration of a table has started.
            </TD>
</TR></TBODY>
</TABLE>&nbsp;<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="visitAbsolutePositionTab(com.aspose.words.AbsolutePositionTab)"><!-- --></A><A NAME="visitAbsolutePositionTab-com.aspose.words.AbsolutePositionTab-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitAbsolutePositionTab</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitAbsolutePositionTab</B>(<A HREF="AbsolutePositionTab.html" title="class in com.aspose.words">AbsolutePositionTab</A>&nbsp;tab)
                            throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a <cref><A HREF="AbsolutePositionTab.html" title="class in com.aspose.words">AbsolutePositionTab</A></cref> node is encountered in the document.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="tab"><CODE>tab</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to process absolute position tab characters with a document visitor.<pre>
public void documentToTxt() throws Exception {
    Document doc = new Document(getMyDir() + "Absolute position tab.docx");

    // Extract the text contents of our document by accepting this custom document visitor.
    DocTextExtractor myDocTextExtractor = new DocTextExtractor();
    Section fisrtSection = doc.getFirstSection();
    fisrtSection.getBody().accept(myDocTextExtractor);
    // Visit only start of the document body.
    fisrtSection.getBody().acceptStart(myDocTextExtractor);
    // Visit only end of the document body.
    fisrtSection.getBody().acceptEnd(myDocTextExtractor);

    // The absolute position tab, which has no equivalent in string form, has been explicitly converted to a tab character.
    Assert.assertEquals("Before AbsolutePositionTab\tAfter AbsolutePositionTab", myDocTextExtractor.getText());

    // An AbsolutePositionTab can accept a DocumentVisitor by itself too.
    AbsolutePositionTab absPositionTab = (AbsolutePositionTab) doc.getFirstSection().getBody().getFirstParagraph().getChild(NodeType.SPECIAL_CHAR, 0, true);

    myDocTextExtractor = new DocTextExtractor();
    absPositionTab.accept(myDocTextExtractor);

    Assert.assertEquals("\t", myDocTextExtractor.getText());
}

/// &lt;summary&gt;
/// Collects the text contents of all runs in the visited document. Replaces all absolute tab characters with ordinary tabs.
/// &lt;/summary&gt;
public static class DocTextExtractor extends DocumentVisitor {
    public DocTextExtractor() {
        mBuilder = new StringBuilder();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        appendText(run.getText());
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when an AbsolutePositionTab node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitAbsolutePositionTab(final AbsolutePositionTab tab) {
        mBuilder.append("\t");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Adds text to the current output. Honors the enabled/disabled output flag.
    /// &lt;/summary&gt;
    public void appendText(final String text) {
        mBuilder.append(text);
    }

    /// &lt;summary&gt;
    /// Plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitBodyEnd(com.aspose.words.Body)"><!-- --></A><A NAME="visitBodyEnd-com.aspose.words.Body-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitBodyEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitBodyEnd</B>(<A HREF="Body.html" title="class in com.aspose.words">Body</A>&nbsp;body)
                throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of the main text story in a section has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="body"><CODE>body</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
</DL>
<HR>

<A NAME="visitBodyStart(com.aspose.words.Body)"><!-- --></A><A NAME="visitBodyStart-com.aspose.words.Body-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitBodyStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitBodyStart</B>(<A HREF="Body.html" title="class in com.aspose.words">Body</A>&nbsp;body)
                  throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of the main text story in a section has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="body"><CODE>body</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
</DL>
<HR>

<A NAME="visitBookmarkEnd(com.aspose.words.BookmarkEnd)"><!-- --></A><A NAME="visitBookmarkEnd-com.aspose.words.BookmarkEnd-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitBookmarkEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitBookmarkEnd</B>(<A HREF="BookmarkEnd.html" title="class in com.aspose.words">BookmarkEnd</A>&nbsp;bookmarkEnd)
                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when an end of a bookmark is encountered in the document.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="bookmarkEnd"><CODE>bookmarkEnd</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to add bookmarks and update their contents.<pre>
public void createUpdateAndPrintBookmarks() throws Exception {
    // Create a document with three bookmarks, then use a custom document visitor implementation to print their contents.
    Document doc = createDocumentWithBookmarks(3);
    BookmarkCollection bookmarks = doc.getRange().getBookmarks();
    printAllBookmarkInfo(bookmarks);

    // Bookmarks can be accessed in the bookmark collection by index or name, and their names can be updated.
    bookmarks.get(0).setName("{bookmarks[0].Name}_NewName");
    bookmarks.get("MyBookmark_2").setText("Updated text contents of {bookmarks[1].Name}");

    // Print all bookmarks again to see updated values.
    printAllBookmarkInfo(bookmarks);
}

/// &lt;summary&gt;
/// Create a document with a given number of bookmarks.
/// &lt;/summary&gt;
private static Document createDocumentWithBookmarks(int numberOfBookmarks) throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    for (int i = 1; i &lt;= numberOfBookmarks; i++) {
        String bookmarkName = "MyBookmark_" + i;

        builder.write("Text before bookmark.");
        builder.startBookmark(bookmarkName);
        builder.write(MessageFormat.format("Text inside {0}.", bookmarkName));
        builder.endBookmark(bookmarkName);
        builder.writeln("Text after bookmark.");
    }

    return doc;
}

/// &lt;summary&gt;
/// Use an iterator and a visitor to print info of every bookmark in the collection.
/// &lt;/summary&gt;
private static void printAllBookmarkInfo(BookmarkCollection bookmarks) throws Exception {
    BookmarkInfoPrinter bookmarkVisitor = new BookmarkInfoPrinter();

    // Get each bookmark in the collection to accept a visitor that will print its contents.
    Iterator&lt;Bookmark&gt; enumerator = bookmarks.iterator();

    while (enumerator.hasNext()) {
        Bookmark currentBookmark = enumerator.next();

        if (currentBookmark != null) {
            currentBookmark.getBookmarkStart().accept(bookmarkVisitor);
            currentBookmark.getBookmarkEnd().accept(bookmarkVisitor);

            System.out.println(currentBookmark.getBookmarkStart().getText());
        }
    }
}

/// &lt;summary&gt;
/// Prints contents of every visited bookmark to the console.
/// &lt;/summary&gt;
public static class BookmarkInfoPrinter extends DocumentVisitor {
    public int visitBookmarkStart(BookmarkStart bookmarkStart) throws Exception {
        System.out.println(MessageFormat.format("BookmarkStart name: \"{0}\", Content: \"{1}\"", bookmarkStart.getName(),
                bookmarkStart.getBookmark().getText()));
        return VisitorAction.CONTINUE;
    }

    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd) {
        System.out.println(MessageFormat.format("BookmarkEnd name: \"{0}\"", bookmarkEnd.getName()));
        return VisitorAction.CONTINUE;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitBookmarkStart(com.aspose.words.BookmarkStart)"><!-- --></A><A NAME="visitBookmarkStart-com.aspose.words.BookmarkStart-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitBookmarkStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitBookmarkStart</B>(<A HREF="BookmarkStart.html" title="class in com.aspose.words">BookmarkStart</A>&nbsp;bookmarkStart)
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a start of a bookmark is encountered in the document.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="bookmarkStart"><CODE>bookmarkStart</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to add bookmarks and update their contents.<pre>
public void createUpdateAndPrintBookmarks() throws Exception {
    // Create a document with three bookmarks, then use a custom document visitor implementation to print their contents.
    Document doc = createDocumentWithBookmarks(3);
    BookmarkCollection bookmarks = doc.getRange().getBookmarks();
    printAllBookmarkInfo(bookmarks);

    // Bookmarks can be accessed in the bookmark collection by index or name, and their names can be updated.
    bookmarks.get(0).setName("{bookmarks[0].Name}_NewName");
    bookmarks.get("MyBookmark_2").setText("Updated text contents of {bookmarks[1].Name}");

    // Print all bookmarks again to see updated values.
    printAllBookmarkInfo(bookmarks);
}

/// &lt;summary&gt;
/// Create a document with a given number of bookmarks.
/// &lt;/summary&gt;
private static Document createDocumentWithBookmarks(int numberOfBookmarks) throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    for (int i = 1; i &lt;= numberOfBookmarks; i++) {
        String bookmarkName = "MyBookmark_" + i;

        builder.write("Text before bookmark.");
        builder.startBookmark(bookmarkName);
        builder.write(MessageFormat.format("Text inside {0}.", bookmarkName));
        builder.endBookmark(bookmarkName);
        builder.writeln("Text after bookmark.");
    }

    return doc;
}

/// &lt;summary&gt;
/// Use an iterator and a visitor to print info of every bookmark in the collection.
/// &lt;/summary&gt;
private static void printAllBookmarkInfo(BookmarkCollection bookmarks) throws Exception {
    BookmarkInfoPrinter bookmarkVisitor = new BookmarkInfoPrinter();

    // Get each bookmark in the collection to accept a visitor that will print its contents.
    Iterator&lt;Bookmark&gt; enumerator = bookmarks.iterator();

    while (enumerator.hasNext()) {
        Bookmark currentBookmark = enumerator.next();

        if (currentBookmark != null) {
            currentBookmark.getBookmarkStart().accept(bookmarkVisitor);
            currentBookmark.getBookmarkEnd().accept(bookmarkVisitor);

            System.out.println(currentBookmark.getBookmarkStart().getText());
        }
    }
}

/// &lt;summary&gt;
/// Prints contents of every visited bookmark to the console.
/// &lt;/summary&gt;
public static class BookmarkInfoPrinter extends DocumentVisitor {
    public int visitBookmarkStart(BookmarkStart bookmarkStart) throws Exception {
        System.out.println(MessageFormat.format("BookmarkStart name: \"{0}\", Content: \"{1}\"", bookmarkStart.getName(),
                bookmarkStart.getBookmark().getText()));
        return VisitorAction.CONTINUE;
    }

    public int visitBookmarkEnd(BookmarkEnd bookmarkEnd) {
        System.out.println(MessageFormat.format("BookmarkEnd name: \"{0}\"", bookmarkEnd.getName()));
        return VisitorAction.CONTINUE;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitBuildingBlockEnd(com.aspose.words.BuildingBlock)"><!-- --></A><A NAME="visitBuildingBlockEnd-com.aspose.words.BuildingBlock-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitBuildingBlockEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitBuildingBlockEnd</B>(<A HREF="BuildingBlock.html" title="class in com.aspose.words">BuildingBlock</A>&nbsp;block)
                         throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a building block has ended.
            </summary><remarks><p>
Note: A building block node and its children are not visited when you execute a
Visitor over a <cref><A HREF="Document.html" title="class in com.aspose.words">Document</A></cref>. If you want to execute a Visitor over a
building block, you need to execute the visitor over <cref><A HREF="GlossaryDocument.html" title="class in com.aspose.words">GlossaryDocument</A></cref> or
call <cref><A HREF="BuildingBlock.html#accept(com.aspose.words.DocumentVisitor)" title="method in class com.aspose.words.BuildingBlock">BuildingBlock.accept(com.aspose.words.DocumentVisitor)</A></cref>.
</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="block"><CODE>block</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows ways of accessing building blocks in a glossary document.<pre>
public void glossaryDocument() throws Exception {
    Document doc = new Document();
    GlossaryDocument glossaryDoc = new GlossaryDocument();

    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 1"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 2"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 3"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 4"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 5"));

    Assert.assertEquals(glossaryDoc.getBuildingBlocks().getCount(), 5);

    doc.setGlossaryDocument(glossaryDoc);

    // There are various ways of accessing building blocks.
    // 1 -  Get the first/last building blocks in the collection:
    Assert.assertEquals("Block 1", glossaryDoc.getFirstBuildingBlock().getName());
    Assert.assertEquals("Block 5", glossaryDoc.getLastBuildingBlock().getName());

    // 2 -  Get a building block by index:
    Assert.assertEquals("Block 2", glossaryDoc.getBuildingBlocks().get(1).getName());
    Assert.assertEquals("Block 3", glossaryDoc.getBuildingBlocks().toArray()[2].getName());

    // 3 -  Get the first building block that matches a gallery, name and category:
    Assert.assertEquals("Block 4",
            glossaryDoc.getBuildingBlock(BuildingBlockGallery.ALL, "(Empty Category)", "Block 4").getName());

    // We will do that using a custom visitor,
    // which will give every BuildingBlock in the GlossaryDocument a unique GUID
    GlossaryDocVisitor visitor = new GlossaryDocVisitor();
    // Visit start/end of the Glossary document.
    glossaryDoc.accept(visitor);
    // Visit only start of the Glossary document.
    glossaryDoc.acceptStart(visitor);
    // Visit only end of the Glossary document.
    glossaryDoc.acceptEnd(visitor);
    System.out.println(visitor.getText());

    // In Microsoft Word, we can access the building blocks via "Insert" -&gt; "Quick Parts" -&gt; "Building Blocks Organizer".
    doc.save(getArtifactsDir() + "BuildingBlocks.GlossaryDocument.dotx");
}

public static BuildingBlock createNewBuildingBlock(final GlossaryDocument glossaryDoc, final String buildingBlockName) {
    BuildingBlock buildingBlock = new BuildingBlock(glossaryDoc);
    buildingBlock.setName(buildingBlockName);

    return buildingBlock;
}

/// &lt;summary&gt;
/// Gives each building block in a visited glossary document a unique GUID.
/// Stores the GUID-building block pairs in a dictionary.
/// &lt;/summary&gt;
public static class GlossaryDocVisitor extends DocumentVisitor {
    public GlossaryDocVisitor() {
        mBlocksByGuid = new HashMap&lt;&gt;();
        mBuilder = new StringBuilder();
    }

    public String getText() {
        return mBuilder.toString();
    }

    public HashMap&lt;UUID, BuildingBlock&gt; getDictionary() {
        return mBlocksByGuid;
    }

    public int visitGlossaryDocumentStart(final GlossaryDocument glossary) {
        mBuilder.append("Glossary document found!\n");
        return VisitorAction.CONTINUE;
    }

    public int visitGlossaryDocumentEnd(final GlossaryDocument glossary) {
        mBuilder.append("Reached end of glossary!\n");
        mBuilder.append("BuildingBlocks found: " + mBlocksByGuid.size() + "\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitBuildingBlockStart(final BuildingBlock block) {
        block.setGuid(UUID.randomUUID());
        mBlocksByGuid.put(block.getGuid(), block);
        return VisitorAction.CONTINUE;
    }

    public int visitBuildingBlockEnd(final BuildingBlock block) {
        mBuilder.append("\tVisited block \"" + block.getName() + "\"" + "\r\n");
        mBuilder.append("\t Type: " + block.getType() + "\r\n");
        mBuilder.append("\t Gallery: " + block.getGallery() + "\r\n");
        mBuilder.append("\t Behavior: " + block.getBehavior() + "\r\n");
        mBuilder.append("\t Description: " + block.getDescription() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    private final HashMap&lt;UUID, BuildingBlock&gt; mBlocksByGuid;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitBuildingBlockStart(com.aspose.words.BuildingBlock)"><!-- --></A><A NAME="visitBuildingBlockStart-com.aspose.words.BuildingBlock-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitBuildingBlockStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitBuildingBlockStart</B>(<A HREF="BuildingBlock.html" title="class in com.aspose.words">BuildingBlock</A>&nbsp;block)
                           throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a building block has started.
            </summary><remarks><p>
Note: A building block node and its children are not visited when you execute a
Visitor over a <cref><A HREF="Document.html" title="class in com.aspose.words">Document</A></cref>. If you want to execute a Visitor over a
building block, you need to execute the visitor over <cref><A HREF="GlossaryDocument.html" title="class in com.aspose.words">GlossaryDocument</A></cref> or
call <cref><A HREF="BuildingBlock.html#accept(com.aspose.words.DocumentVisitor)" title="method in class com.aspose.words.BuildingBlock">BuildingBlock.accept(com.aspose.words.DocumentVisitor)</A></cref>.
</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="block"><CODE>block</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows ways of accessing building blocks in a glossary document.<pre>
public void glossaryDocument() throws Exception {
    Document doc = new Document();
    GlossaryDocument glossaryDoc = new GlossaryDocument();

    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 1"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 2"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 3"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 4"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 5"));

    Assert.assertEquals(glossaryDoc.getBuildingBlocks().getCount(), 5);

    doc.setGlossaryDocument(glossaryDoc);

    // There are various ways of accessing building blocks.
    // 1 -  Get the first/last building blocks in the collection:
    Assert.assertEquals("Block 1", glossaryDoc.getFirstBuildingBlock().getName());
    Assert.assertEquals("Block 5", glossaryDoc.getLastBuildingBlock().getName());

    // 2 -  Get a building block by index:
    Assert.assertEquals("Block 2", glossaryDoc.getBuildingBlocks().get(1).getName());
    Assert.assertEquals("Block 3", glossaryDoc.getBuildingBlocks().toArray()[2].getName());

    // 3 -  Get the first building block that matches a gallery, name and category:
    Assert.assertEquals("Block 4",
            glossaryDoc.getBuildingBlock(BuildingBlockGallery.ALL, "(Empty Category)", "Block 4").getName());

    // We will do that using a custom visitor,
    // which will give every BuildingBlock in the GlossaryDocument a unique GUID
    GlossaryDocVisitor visitor = new GlossaryDocVisitor();
    // Visit start/end of the Glossary document.
    glossaryDoc.accept(visitor);
    // Visit only start of the Glossary document.
    glossaryDoc.acceptStart(visitor);
    // Visit only end of the Glossary document.
    glossaryDoc.acceptEnd(visitor);
    System.out.println(visitor.getText());

    // In Microsoft Word, we can access the building blocks via "Insert" -&gt; "Quick Parts" -&gt; "Building Blocks Organizer".
    doc.save(getArtifactsDir() + "BuildingBlocks.GlossaryDocument.dotx");
}

public static BuildingBlock createNewBuildingBlock(final GlossaryDocument glossaryDoc, final String buildingBlockName) {
    BuildingBlock buildingBlock = new BuildingBlock(glossaryDoc);
    buildingBlock.setName(buildingBlockName);

    return buildingBlock;
}

/// &lt;summary&gt;
/// Gives each building block in a visited glossary document a unique GUID.
/// Stores the GUID-building block pairs in a dictionary.
/// &lt;/summary&gt;
public static class GlossaryDocVisitor extends DocumentVisitor {
    public GlossaryDocVisitor() {
        mBlocksByGuid = new HashMap&lt;&gt;();
        mBuilder = new StringBuilder();
    }

    public String getText() {
        return mBuilder.toString();
    }

    public HashMap&lt;UUID, BuildingBlock&gt; getDictionary() {
        return mBlocksByGuid;
    }

    public int visitGlossaryDocumentStart(final GlossaryDocument glossary) {
        mBuilder.append("Glossary document found!\n");
        return VisitorAction.CONTINUE;
    }

    public int visitGlossaryDocumentEnd(final GlossaryDocument glossary) {
        mBuilder.append("Reached end of glossary!\n");
        mBuilder.append("BuildingBlocks found: " + mBlocksByGuid.size() + "\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitBuildingBlockStart(final BuildingBlock block) {
        block.setGuid(UUID.randomUUID());
        mBlocksByGuid.put(block.getGuid(), block);
        return VisitorAction.CONTINUE;
    }

    public int visitBuildingBlockEnd(final BuildingBlock block) {
        mBuilder.append("\tVisited block \"" + block.getName() + "\"" + "\r\n");
        mBuilder.append("\t Type: " + block.getType() + "\r\n");
        mBuilder.append("\t Gallery: " + block.getGallery() + "\r\n");
        mBuilder.append("\t Behavior: " + block.getBehavior() + "\r\n");
        mBuilder.append("\t Description: " + block.getDescription() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    private final HashMap&lt;UUID, BuildingBlock&gt; mBlocksByGuid;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitCellEnd(com.aspose.words.Cell)"><!-- --></A><A NAME="visitCellEnd-com.aspose.words.Cell-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitCellEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitCellEnd</B>(<A HREF="Cell.html" title="class in com.aspose.words">Cell</A>&nbsp;cell)
                throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a table cell has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="cell"><CODE>cell</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a DocumentVisitor implementation to remove all hidden content from a document.<pre>
public void removeHiddenContentFromDocument() throws Exception {
    Document doc = new Document(getMyDir() + "Hidden content.docx");
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // Below are three types of fields which can accept a document visitor,
    // which will allow it to visit the accepting node, and then traverse its child nodes in a depth-first manner.
    // 1 -  Paragraph node:
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // 2 -  Table node:
    Table table = doc.getFirstSection().getBody().getTables().get(0);
    table.accept(hiddenContentRemover);

    // 3 -  Document node:
    doc.accept(hiddenContentRemover);

    doc.save(getArtifactsDir() + "Font.RemoveHiddenContentFromDocument.docx");
}

/// &lt;summary&gt;
/// Removes all visited nodes marked as "hidden content".
/// &lt;/summary&gt;
public static class RemoveHiddenContentVisitor extends DocumentVisitor {
    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(FieldStart fieldStart) {
        if (fieldStart.getFont().getHidden())
            fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(FieldEnd fieldEnd) {
        if (fieldEnd.getFont().getHidden())
            fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(FieldSeparator fieldSeparator) {
        if (fieldSeparator.getFont().getHidden())
            fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(Run run) {
        if (run.getFont().getHidden())
            run.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(Paragraph paragraph) {
        if (paragraph.getParagraphBreakFont().getHidden())
            paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FormField is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFormField(FormField formField) {
        if (formField.getFont().getHidden())
            formField.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a GroupShape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitGroupShapeStart(GroupShape groupShape) {
        if (groupShape.getFont().getHidden())
            groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Shape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitShapeStart(Shape shape) {
        if (shape.getFont().getHidden())
            shape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(Comment comment) {
        if (comment.getFont().getHidden())
            comment.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Footnote is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFootnoteStart(Footnote footnote) {
        if (footnote.getFont().getHidden())
            footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SpecialCharacter is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSpecialChar(SpecialChar specialChar) {
        if (specialChar.getFont().getHidden())
            specialChar.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Table node is ended in the document.
    /// &lt;/summary&gt;
    public int visitTableEnd(Table table) {
        // The content inside table cells may have the hidden content flag, but the tables themselves cannot.
        // If this table had nothing but hidden content, this visitor would have removed all of it,
        // and there would be no child nodes left.
        // Thus, we can also treat the table itself as hidden content and remove it.
        // Tables which are empty but do not have hidden content will have cells with empty paragraphs inside,
        // which this visitor will not remove.
        if (!table.hasChildNodes())
            table.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Cell node is ended in the document.
    /// &lt;/summary&gt;
    public int visitCellEnd(Cell cell) {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null)
            cell.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Row node is ended in the document.
    /// &lt;/summary&gt;
    public int visitRowEnd(Row row) {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null)
            row.remove();

        return VisitorAction.CONTINUE;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<A NAME="visitCellStart(com.aspose.words.Cell)"><!-- --></A><A NAME="visitCellStart-com.aspose.words.Cell-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitCellStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitCellStart</B>(<A HREF="Cell.html" title="class in com.aspose.words">Cell</A>&nbsp;cell)
                  throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a table cell has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="cell"><CODE>cell</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<A NAME="visitCommentEnd(com.aspose.words.Comment)"><!-- --></A><A NAME="visitCommentEnd-com.aspose.words.Comment-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitCommentEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitCommentEnd</B>(<A HREF="Comment.html" title="class in com.aspose.words">Comment</A>&nbsp;comment)
                   throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a comment text has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="comment"><CODE>comment</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every comment and comment range in a document.<pre>
public void commentsToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    CommentStructurePrinter visitor = new CommentStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Comment/CommentRange nodes and their children.
/// &lt;/summary&gt;
public static class CommentStructurePrinter extends DocumentVisitor {
    public CommentStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideComment = false;
    }

    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// A Run is only recorded if it is a child of a Comment or CommentRange node.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideComment) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a CommentRangeStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentRangeStart(final CommentRangeStart commentRangeStart) {
        indentAndAppendLine("[Comment range start] ID: " + commentRangeStart.getId());
        mDocTraversalDepth++;
        mVisitorIsInsideComment = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a CommentRangeEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentRangeEnd(final CommentRangeEnd commentRangeEnd) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Comment range end]");
        mVisitorIsInsideComment = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(final Comment comment) {
        indentAndAppendLine(MessageFormat.format("[Comment start] For comment range ID {0}, By {1} on {2}", comment.getId(),
                comment.getAuthor(), comment.getDateTime()));
        mDocTraversalDepth++;
        mVisitorIsInsideComment = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Comment node have been visited.
    /// &lt;/summary&gt;
    public int visitCommentEnd(final Comment comment) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Comment end]");
        mVisitorIsInsideComment = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into a comment/comment range's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideComment;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitCommentRangeEnd(com.aspose.words.CommentRangeEnd)"><!-- --></A><A NAME="visitCommentRangeEnd-com.aspose.words.CommentRangeEnd-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitCommentRangeEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitCommentRangeEnd</B>(<A HREF="CommentRangeEnd.html" title="class in com.aspose.words">CommentRangeEnd</A>&nbsp;commentRangeEnd)
                        throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when the end of a commented range of text is encountered.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="commentRangeEnd"><CODE>commentRangeEnd</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every comment and comment range in a document.<pre>
public void commentsToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    CommentStructurePrinter visitor = new CommentStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Comment/CommentRange nodes and their children.
/// &lt;/summary&gt;
public static class CommentStructurePrinter extends DocumentVisitor {
    public CommentStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideComment = false;
    }

    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// A Run is only recorded if it is a child of a Comment or CommentRange node.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideComment) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a CommentRangeStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentRangeStart(final CommentRangeStart commentRangeStart) {
        indentAndAppendLine("[Comment range start] ID: " + commentRangeStart.getId());
        mDocTraversalDepth++;
        mVisitorIsInsideComment = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a CommentRangeEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentRangeEnd(final CommentRangeEnd commentRangeEnd) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Comment range end]");
        mVisitorIsInsideComment = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(final Comment comment) {
        indentAndAppendLine(MessageFormat.format("[Comment start] For comment range ID {0}, By {1} on {2}", comment.getId(),
                comment.getAuthor(), comment.getDateTime()));
        mDocTraversalDepth++;
        mVisitorIsInsideComment = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Comment node have been visited.
    /// &lt;/summary&gt;
    public int visitCommentEnd(final Comment comment) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Comment end]");
        mVisitorIsInsideComment = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into a comment/comment range's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideComment;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitCommentRangeStart(com.aspose.words.CommentRangeStart)"><!-- --></A><A NAME="visitCommentRangeStart-com.aspose.words.CommentRangeStart-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitCommentRangeStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitCommentRangeStart</B>(<A HREF="CommentRangeStart.html" title="class in com.aspose.words">CommentRangeStart</A>&nbsp;commentRangeStart)
                          throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when the start of a commented range of text is encountered.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="commentRangeStart"><CODE>commentRangeStart</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every comment and comment range in a document.<pre>
public void commentsToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    CommentStructurePrinter visitor = new CommentStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Comment/CommentRange nodes and their children.
/// &lt;/summary&gt;
public static class CommentStructurePrinter extends DocumentVisitor {
    public CommentStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideComment = false;
    }

    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// A Run is only recorded if it is a child of a Comment or CommentRange node.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideComment) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a CommentRangeStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentRangeStart(final CommentRangeStart commentRangeStart) {
        indentAndAppendLine("[Comment range start] ID: " + commentRangeStart.getId());
        mDocTraversalDepth++;
        mVisitorIsInsideComment = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a CommentRangeEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentRangeEnd(final CommentRangeEnd commentRangeEnd) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Comment range end]");
        mVisitorIsInsideComment = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(final Comment comment) {
        indentAndAppendLine(MessageFormat.format("[Comment start] For comment range ID {0}, By {1} on {2}", comment.getId(),
                comment.getAuthor(), comment.getDateTime()));
        mDocTraversalDepth++;
        mVisitorIsInsideComment = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Comment node have been visited.
    /// &lt;/summary&gt;
    public int visitCommentEnd(final Comment comment) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Comment end]");
        mVisitorIsInsideComment = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into a comment/comment range's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideComment;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitCommentStart(com.aspose.words.Comment)"><!-- --></A><A NAME="visitCommentStart-com.aspose.words.Comment-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitCommentStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitCommentStart</B>(<A HREF="Comment.html" title="class in com.aspose.words">Comment</A>&nbsp;comment)
                     throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a comment text has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="comment"><CODE>comment</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a DocumentVisitor implementation to remove all hidden content from a document.<pre>
public void removeHiddenContentFromDocument() throws Exception {
    Document doc = new Document(getMyDir() + "Hidden content.docx");
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // Below are three types of fields which can accept a document visitor,
    // which will allow it to visit the accepting node, and then traverse its child nodes in a depth-first manner.
    // 1 -  Paragraph node:
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // 2 -  Table node:
    Table table = doc.getFirstSection().getBody().getTables().get(0);
    table.accept(hiddenContentRemover);

    // 3 -  Document node:
    doc.accept(hiddenContentRemover);

    doc.save(getArtifactsDir() + "Font.RemoveHiddenContentFromDocument.docx");
}

/// &lt;summary&gt;
/// Removes all visited nodes marked as "hidden content".
/// &lt;/summary&gt;
public static class RemoveHiddenContentVisitor extends DocumentVisitor {
    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(FieldStart fieldStart) {
        if (fieldStart.getFont().getHidden())
            fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(FieldEnd fieldEnd) {
        if (fieldEnd.getFont().getHidden())
            fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(FieldSeparator fieldSeparator) {
        if (fieldSeparator.getFont().getHidden())
            fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(Run run) {
        if (run.getFont().getHidden())
            run.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(Paragraph paragraph) {
        if (paragraph.getParagraphBreakFont().getHidden())
            paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FormField is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFormField(FormField formField) {
        if (formField.getFont().getHidden())
            formField.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a GroupShape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitGroupShapeStart(GroupShape groupShape) {
        if (groupShape.getFont().getHidden())
            groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Shape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitShapeStart(Shape shape) {
        if (shape.getFont().getHidden())
            shape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(Comment comment) {
        if (comment.getFont().getHidden())
            comment.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Footnote is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFootnoteStart(Footnote footnote) {
        if (footnote.getFont().getHidden())
            footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SpecialCharacter is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSpecialChar(SpecialChar specialChar) {
        if (specialChar.getFont().getHidden())
            specialChar.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Table node is ended in the document.
    /// &lt;/summary&gt;
    public int visitTableEnd(Table table) {
        // The content inside table cells may have the hidden content flag, but the tables themselves cannot.
        // If this table had nothing but hidden content, this visitor would have removed all of it,
        // and there would be no child nodes left.
        // Thus, we can also treat the table itself as hidden content and remove it.
        // Tables which are empty but do not have hidden content will have cells with empty paragraphs inside,
        // which this visitor will not remove.
        if (!table.hasChildNodes())
            table.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Cell node is ended in the document.
    /// &lt;/summary&gt;
    public int visitCellEnd(Cell cell) {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null)
            cell.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Row node is ended in the document.
    /// &lt;/summary&gt;
    public int visitRowEnd(Row row) {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null)
            row.remove();

        return VisitorAction.CONTINUE;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to print the node structure of every comment and comment range in a document.<pre>
public void commentsToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    CommentStructurePrinter visitor = new CommentStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Comment/CommentRange nodes and their children.
/// &lt;/summary&gt;
public static class CommentStructurePrinter extends DocumentVisitor {
    public CommentStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideComment = false;
    }

    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// A Run is only recorded if it is a child of a Comment or CommentRange node.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideComment) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a CommentRangeStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentRangeStart(final CommentRangeStart commentRangeStart) {
        indentAndAppendLine("[Comment range start] ID: " + commentRangeStart.getId());
        mDocTraversalDepth++;
        mVisitorIsInsideComment = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a CommentRangeEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentRangeEnd(final CommentRangeEnd commentRangeEnd) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Comment range end]");
        mVisitorIsInsideComment = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(final Comment comment) {
        indentAndAppendLine(MessageFormat.format("[Comment start] For comment range ID {0}, By {1} on {2}", comment.getId(),
                comment.getAuthor(), comment.getDateTime()));
        mDocTraversalDepth++;
        mVisitorIsInsideComment = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Comment node have been visited.
    /// &lt;/summary&gt;
    public int visitCommentEnd(final Comment comment) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Comment end]");
        mVisitorIsInsideComment = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into a comment/comment range's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideComment;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitDocumentEnd(com.aspose.words.Document)"><!-- --></A><A NAME="visitDocumentEnd-com.aspose.words.Document-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitDocumentEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitDocumentEnd</B>(<A HREF="Document.html" title="class in com.aspose.words">Document</A>&nbsp;doc)
                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of the document has finished.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="doc"><CODE>doc</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
</DL>
<HR>

<A NAME="visitDocumentStart(com.aspose.words.Document)"><!-- --></A><A NAME="visitDocumentStart-com.aspose.words.Document-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitDocumentStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitDocumentStart</B>(<A HREF="Document.html" title="class in com.aspose.words">Document</A>&nbsp;doc)
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of the document has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="doc"><CODE>doc</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
</DL>
<HR>

<A NAME="visitEditableRangeEnd(com.aspose.words.EditableRangeEnd)"><!-- --></A><A NAME="visitEditableRangeEnd-com.aspose.words.EditableRangeEnd-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitEditableRangeEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitEditableRangeEnd</B>(<A HREF="EditableRangeEnd.html" title="class in com.aspose.words">EditableRangeEnd</A>&nbsp;editableRangeEnd)
                         throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when an end of an editable range is encountered in the document.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="editableRangeEnd"><CODE>editableRangeEnd</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every editable range in a document.<pre>
public void editableRangeToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    EditableRangeStructurePrinter visitor = new EditableRangeStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered EditableRange nodes and their children.
/// &lt;/summary&gt;
public static class EditableRangeStructurePrinter extends DocumentVisitor {
    public EditableRangeStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideEditableRange = false;
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        // We want to print the contents of runs, but only if they are inside shapes, as they would be in the case of text boxes.
        if (mVisitorIsInsideEditableRange) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when an EditableRange node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitEditableRangeStart(final EditableRangeStart editableRangeStart) {
        indentAndAppendLine("[EditableRange start] ID: " + editableRangeStart.getId() + " Owner: "
                + editableRangeStart.getEditableRange().getSingleUser());
        mDocTraversalDepth++;
        mVisitorIsInsideEditableRange = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when the visiting of a EditableRange node is ended.
    /// &lt;/summary&gt;
    public int visitEditableRangeEnd(final EditableRangeEnd editableRangeEnd) {
        mDocTraversalDepth--;
        indentAndAppendLine("[EditableRange end]");
        mVisitorIsInsideEditableRange = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideEditableRange;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitEditableRangeStart(com.aspose.words.EditableRangeStart)"><!-- --></A><A NAME="visitEditableRangeStart-com.aspose.words.EditableRangeStart-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitEditableRangeStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitEditableRangeStart</B>(<A HREF="EditableRangeStart.html" title="class in com.aspose.words">EditableRangeStart</A>&nbsp;editableRangeStart)
                           throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a start of an editable range is encountered in the document.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="editableRangeStart"><CODE>editableRangeStart</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every editable range in a document.<pre>
public void editableRangeToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    EditableRangeStructurePrinter visitor = new EditableRangeStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered EditableRange nodes and their children.
/// &lt;/summary&gt;
public static class EditableRangeStructurePrinter extends DocumentVisitor {
    public EditableRangeStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideEditableRange = false;
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        // We want to print the contents of runs, but only if they are inside shapes, as they would be in the case of text boxes.
        if (mVisitorIsInsideEditableRange) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when an EditableRange node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitEditableRangeStart(final EditableRangeStart editableRangeStart) {
        indentAndAppendLine("[EditableRange start] ID: " + editableRangeStart.getId() + " Owner: "
                + editableRangeStart.getEditableRange().getSingleUser());
        mDocTraversalDepth++;
        mVisitorIsInsideEditableRange = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when the visiting of a EditableRange node is ended.
    /// &lt;/summary&gt;
    public int visitEditableRangeEnd(final EditableRangeEnd editableRangeEnd) {
        mDocTraversalDepth--;
        indentAndAppendLine("[EditableRange end]");
        mVisitorIsInsideEditableRange = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideEditableRange;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitFieldEnd(com.aspose.words.FieldEnd)"><!-- --></A><A NAME="visitFieldEnd-com.aspose.words.FieldEnd-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitFieldEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitFieldEnd</B>(<A HREF="FieldEnd.html" title="class in com.aspose.words">FieldEnd</A>&nbsp;fieldEnd)
                 throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a field ends in the document.
            </summary><remarks><p>For more info see <cref><A HREF="#visitFieldStart(com.aspose.words.FieldStart)" title="method in class com.aspose.words.DocumentVisitor">visitFieldStart(com.aspose.words.FieldStart)</A></cref></p></remarks><DL><DT><B>Parameters:</B></DT><DD param="fieldEnd"><CODE>fieldEnd</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every field in a document.<pre>
public void fieldToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    FieldStructurePrinter visitor = new FieldStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Field nodes and their children.
/// &lt;/summary&gt;
public static class FieldStructurePrinter extends DocumentVisitor {
    public FieldStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideField = false;
    }

    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideField) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(final FieldStart fieldStart) {
        indentAndAppendLine("[Field start] FieldType: " + fieldStart.getFieldType());
        mDocTraversalDepth++;
        mVisitorIsInsideField = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(final FieldEnd fieldEnd) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Field end]");
        mVisitorIsInsideField = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(final FieldSeparator fieldSeparator) {
        indentAndAppendLine("[FieldSeparator]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the field's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideField;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitFieldSeparator(com.aspose.words.FieldSeparator)"><!-- --></A><A NAME="visitFieldSeparator-com.aspose.words.FieldSeparator-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitFieldSeparator</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitFieldSeparator</B>(<A HREF="FieldSeparator.html" title="class in com.aspose.words">FieldSeparator</A>&nbsp;fieldSeparator)
                       throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a field separator is encountered in the document.
            </summary><remarks><p>The field separator separates field code from field value in the document. Note that some 
            fields have only field code and do not have field separator and field value.</p><p>For more info see <cref><A HREF="#visitFieldStart(com.aspose.words.FieldStart)" title="method in class com.aspose.words.DocumentVisitor">visitFieldStart(com.aspose.words.FieldStart)</A></cref></p></remarks><DL><DT><B>Parameters:</B></DT><DD param="fieldSeparator"><CODE>fieldSeparator</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every field in a document.<pre>
public void fieldToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    FieldStructurePrinter visitor = new FieldStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Field nodes and their children.
/// &lt;/summary&gt;
public static class FieldStructurePrinter extends DocumentVisitor {
    public FieldStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideField = false;
    }

    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideField) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(final FieldStart fieldStart) {
        indentAndAppendLine("[Field start] FieldType: " + fieldStart.getFieldType());
        mDocTraversalDepth++;
        mVisitorIsInsideField = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(final FieldEnd fieldEnd) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Field end]");
        mVisitorIsInsideField = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(final FieldSeparator fieldSeparator) {
        indentAndAppendLine("[FieldSeparator]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the field's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideField;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitFieldStart(com.aspose.words.FieldStart)"><!-- --></A><A NAME="visitFieldStart-com.aspose.words.FieldStart-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitFieldStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitFieldStart</B>(<A HREF="FieldStart.html" title="class in com.aspose.words">FieldStart</A>&nbsp;fieldStart)
                   throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a field starts in the document.
            </summary><remarks><p>A field in a Word document consists of a field code and field value.</p><p>For example, a field that displays a page number can be represented as follows:</p><p>[FieldStart]PAGE[FieldSeparator]98[FieldEnd]</p><p>The field separator separates field code from field value in the document. Note that some 
            fields have only field code and do not have field separator and field value.</p><p>Fields can be nested.</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="fieldStart"><CODE>fieldStart</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every field in a document.<pre>
public void fieldToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    FieldStructurePrinter visitor = new FieldStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Field nodes and their children.
/// &lt;/summary&gt;
public static class FieldStructurePrinter extends DocumentVisitor {
    public FieldStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideField = false;
    }

    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideField) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(final FieldStart fieldStart) {
        indentAndAppendLine("[Field start] FieldType: " + fieldStart.getFieldType());
        mDocTraversalDepth++;
        mVisitorIsInsideField = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(final FieldEnd fieldEnd) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Field end]");
        mVisitorIsInsideField = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(final FieldSeparator fieldSeparator) {
        indentAndAppendLine("[FieldSeparator]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the field's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideField;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitFootnoteEnd(com.aspose.words.Footnote)"><!-- --></A><A NAME="visitFootnoteEnd-com.aspose.words.Footnote-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitFootnoteEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitFootnoteEnd</B>(<A HREF="Footnote.html" title="class in com.aspose.words">Footnote</A>&nbsp;footnote)
                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a footnote or endnote text has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="footnote"><CODE>footnote</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every footnote in a document.<pre>
public void footnoteToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    FootnoteStructurePrinter visitor = new FootnoteStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Footnote nodes and their children.
/// &lt;/summary&gt;
public static class FootnoteStructurePrinter extends DocumentVisitor {
    public FootnoteStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideFootnote = false;
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Footnote node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFootnoteStart(final Footnote footnote) {
        indentAndAppendLine("[Footnote start] Type: " + footnote.getFootnoteType());
        mDocTraversalDepth++;
        mVisitorIsInsideFootnote = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Footnote node have been visited.
    /// &lt;/summary&gt;
    public int visitFootnoteEnd(final Footnote footnote) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Footnote end]");
        mVisitorIsInsideFootnote = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideFootnote) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideFootnote;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitFootnoteStart(com.aspose.words.Footnote)"><!-- --></A><A NAME="visitFootnoteStart-com.aspose.words.Footnote-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitFootnoteStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitFootnoteStart</B>(<A HREF="Footnote.html" title="class in com.aspose.words">Footnote</A>&nbsp;footnote)
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a footnote or endnote text has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="footnote"><CODE>footnote</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a DocumentVisitor implementation to remove all hidden content from a document.<pre>
public void removeHiddenContentFromDocument() throws Exception {
    Document doc = new Document(getMyDir() + "Hidden content.docx");
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // Below are three types of fields which can accept a document visitor,
    // which will allow it to visit the accepting node, and then traverse its child nodes in a depth-first manner.
    // 1 -  Paragraph node:
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // 2 -  Table node:
    Table table = doc.getFirstSection().getBody().getTables().get(0);
    table.accept(hiddenContentRemover);

    // 3 -  Document node:
    doc.accept(hiddenContentRemover);

    doc.save(getArtifactsDir() + "Font.RemoveHiddenContentFromDocument.docx");
}

/// &lt;summary&gt;
/// Removes all visited nodes marked as "hidden content".
/// &lt;/summary&gt;
public static class RemoveHiddenContentVisitor extends DocumentVisitor {
    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(FieldStart fieldStart) {
        if (fieldStart.getFont().getHidden())
            fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(FieldEnd fieldEnd) {
        if (fieldEnd.getFont().getHidden())
            fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(FieldSeparator fieldSeparator) {
        if (fieldSeparator.getFont().getHidden())
            fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(Run run) {
        if (run.getFont().getHidden())
            run.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(Paragraph paragraph) {
        if (paragraph.getParagraphBreakFont().getHidden())
            paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FormField is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFormField(FormField formField) {
        if (formField.getFont().getHidden())
            formField.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a GroupShape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitGroupShapeStart(GroupShape groupShape) {
        if (groupShape.getFont().getHidden())
            groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Shape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitShapeStart(Shape shape) {
        if (shape.getFont().getHidden())
            shape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(Comment comment) {
        if (comment.getFont().getHidden())
            comment.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Footnote is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFootnoteStart(Footnote footnote) {
        if (footnote.getFont().getHidden())
            footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SpecialCharacter is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSpecialChar(SpecialChar specialChar) {
        if (specialChar.getFont().getHidden())
            specialChar.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Table node is ended in the document.
    /// &lt;/summary&gt;
    public int visitTableEnd(Table table) {
        // The content inside table cells may have the hidden content flag, but the tables themselves cannot.
        // If this table had nothing but hidden content, this visitor would have removed all of it,
        // and there would be no child nodes left.
        // Thus, we can also treat the table itself as hidden content and remove it.
        // Tables which are empty but do not have hidden content will have cells with empty paragraphs inside,
        // which this visitor will not remove.
        if (!table.hasChildNodes())
            table.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Cell node is ended in the document.
    /// &lt;/summary&gt;
    public int visitCellEnd(Cell cell) {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null)
            cell.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Row node is ended in the document.
    /// &lt;/summary&gt;
    public int visitRowEnd(Row row) {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null)
            row.remove();

        return VisitorAction.CONTINUE;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to print the node structure of every footnote in a document.<pre>
public void footnoteToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    FootnoteStructurePrinter visitor = new FootnoteStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Footnote nodes and their children.
/// &lt;/summary&gt;
public static class FootnoteStructurePrinter extends DocumentVisitor {
    public FootnoteStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideFootnote = false;
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Footnote node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFootnoteStart(final Footnote footnote) {
        indentAndAppendLine("[Footnote start] Type: " + footnote.getFootnoteType());
        mDocTraversalDepth++;
        mVisitorIsInsideFootnote = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Footnote node have been visited.
    /// &lt;/summary&gt;
    public int visitFootnoteEnd(final Footnote footnote) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Footnote end]");
        mVisitorIsInsideFootnote = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideFootnote) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideFootnote;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitFormField(com.aspose.words.FormField)"><!-- --></A><A NAME="visitFormField-com.aspose.words.FormField-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitFormField</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitFormField</B>(<A HREF="FormField.html" title="class in com.aspose.words">FormField</A>&nbsp;formField)
                  throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a form field is encountered in the document.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="formField"><CODE>formField</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a DocumentVisitor implementation to remove all hidden content from a document.<pre>
public void removeHiddenContentFromDocument() throws Exception {
    Document doc = new Document(getMyDir() + "Hidden content.docx");
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // Below are three types of fields which can accept a document visitor,
    // which will allow it to visit the accepting node, and then traverse its child nodes in a depth-first manner.
    // 1 -  Paragraph node:
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // 2 -  Table node:
    Table table = doc.getFirstSection().getBody().getTables().get(0);
    table.accept(hiddenContentRemover);

    // 3 -  Document node:
    doc.accept(hiddenContentRemover);

    doc.save(getArtifactsDir() + "Font.RemoveHiddenContentFromDocument.docx");
}

/// &lt;summary&gt;
/// Removes all visited nodes marked as "hidden content".
/// &lt;/summary&gt;
public static class RemoveHiddenContentVisitor extends DocumentVisitor {
    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(FieldStart fieldStart) {
        if (fieldStart.getFont().getHidden())
            fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(FieldEnd fieldEnd) {
        if (fieldEnd.getFont().getHidden())
            fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(FieldSeparator fieldSeparator) {
        if (fieldSeparator.getFont().getHidden())
            fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(Run run) {
        if (run.getFont().getHidden())
            run.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(Paragraph paragraph) {
        if (paragraph.getParagraphBreakFont().getHidden())
            paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FormField is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFormField(FormField formField) {
        if (formField.getFont().getHidden())
            formField.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a GroupShape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitGroupShapeStart(GroupShape groupShape) {
        if (groupShape.getFont().getHidden())
            groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Shape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitShapeStart(Shape shape) {
        if (shape.getFont().getHidden())
            shape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(Comment comment) {
        if (comment.getFont().getHidden())
            comment.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Footnote is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFootnoteStart(Footnote footnote) {
        if (footnote.getFont().getHidden())
            footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SpecialCharacter is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSpecialChar(SpecialChar specialChar) {
        if (specialChar.getFont().getHidden())
            specialChar.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Table node is ended in the document.
    /// &lt;/summary&gt;
    public int visitTableEnd(Table table) {
        // The content inside table cells may have the hidden content flag, but the tables themselves cannot.
        // If this table had nothing but hidden content, this visitor would have removed all of it,
        // and there would be no child nodes left.
        // Thus, we can also treat the table itself as hidden content and remove it.
        // Tables which are empty but do not have hidden content will have cells with empty paragraphs inside,
        // which this visitor will not remove.
        if (!table.hasChildNodes())
            table.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Cell node is ended in the document.
    /// &lt;/summary&gt;
    public int visitCellEnd(Cell cell) {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null)
            cell.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Row node is ended in the document.
    /// &lt;/summary&gt;
    public int visitRowEnd(Row row) {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null)
            row.remove();

        return VisitorAction.CONTINUE;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitGlossaryDocumentEnd(com.aspose.words.GlossaryDocument)"><!-- --></A><A NAME="visitGlossaryDocumentEnd-com.aspose.words.GlossaryDocument-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitGlossaryDocumentEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitGlossaryDocumentEnd</B>(<A HREF="GlossaryDocument.html" title="class in com.aspose.words">GlossaryDocument</A>&nbsp;glossary)
                            throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a glossary document has ended.
            </summary><remarks><p>
Note: A glossary document node and its children are not visited when you execute a
Visitor over a <cref><A HREF="Document.html" title="class in com.aspose.words">Document</A></cref>. If you want to execute a Visitor over a
glossary document, you need to call <cref><A HREF="GlossaryDocument.html#accept(com.aspose.words.DocumentVisitor)" title="method in class com.aspose.words.GlossaryDocument">GlossaryDocument.accept(com.aspose.words.DocumentVisitor)</A></cref>.
</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="glossary"><CODE>glossary</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows ways of accessing building blocks in a glossary document.<pre>
public void glossaryDocument() throws Exception {
    Document doc = new Document();
    GlossaryDocument glossaryDoc = new GlossaryDocument();

    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 1"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 2"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 3"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 4"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 5"));

    Assert.assertEquals(glossaryDoc.getBuildingBlocks().getCount(), 5);

    doc.setGlossaryDocument(glossaryDoc);

    // There are various ways of accessing building blocks.
    // 1 -  Get the first/last building blocks in the collection:
    Assert.assertEquals("Block 1", glossaryDoc.getFirstBuildingBlock().getName());
    Assert.assertEquals("Block 5", glossaryDoc.getLastBuildingBlock().getName());

    // 2 -  Get a building block by index:
    Assert.assertEquals("Block 2", glossaryDoc.getBuildingBlocks().get(1).getName());
    Assert.assertEquals("Block 3", glossaryDoc.getBuildingBlocks().toArray()[2].getName());

    // 3 -  Get the first building block that matches a gallery, name and category:
    Assert.assertEquals("Block 4",
            glossaryDoc.getBuildingBlock(BuildingBlockGallery.ALL, "(Empty Category)", "Block 4").getName());

    // We will do that using a custom visitor,
    // which will give every BuildingBlock in the GlossaryDocument a unique GUID
    GlossaryDocVisitor visitor = new GlossaryDocVisitor();
    // Visit start/end of the Glossary document.
    glossaryDoc.accept(visitor);
    // Visit only start of the Glossary document.
    glossaryDoc.acceptStart(visitor);
    // Visit only end of the Glossary document.
    glossaryDoc.acceptEnd(visitor);
    System.out.println(visitor.getText());

    // In Microsoft Word, we can access the building blocks via "Insert" -&gt; "Quick Parts" -&gt; "Building Blocks Organizer".
    doc.save(getArtifactsDir() + "BuildingBlocks.GlossaryDocument.dotx");
}

public static BuildingBlock createNewBuildingBlock(final GlossaryDocument glossaryDoc, final String buildingBlockName) {
    BuildingBlock buildingBlock = new BuildingBlock(glossaryDoc);
    buildingBlock.setName(buildingBlockName);

    return buildingBlock;
}

/// &lt;summary&gt;
/// Gives each building block in a visited glossary document a unique GUID.
/// Stores the GUID-building block pairs in a dictionary.
/// &lt;/summary&gt;
public static class GlossaryDocVisitor extends DocumentVisitor {
    public GlossaryDocVisitor() {
        mBlocksByGuid = new HashMap&lt;&gt;();
        mBuilder = new StringBuilder();
    }

    public String getText() {
        return mBuilder.toString();
    }

    public HashMap&lt;UUID, BuildingBlock&gt; getDictionary() {
        return mBlocksByGuid;
    }

    public int visitGlossaryDocumentStart(final GlossaryDocument glossary) {
        mBuilder.append("Glossary document found!\n");
        return VisitorAction.CONTINUE;
    }

    public int visitGlossaryDocumentEnd(final GlossaryDocument glossary) {
        mBuilder.append("Reached end of glossary!\n");
        mBuilder.append("BuildingBlocks found: " + mBlocksByGuid.size() + "\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitBuildingBlockStart(final BuildingBlock block) {
        block.setGuid(UUID.randomUUID());
        mBlocksByGuid.put(block.getGuid(), block);
        return VisitorAction.CONTINUE;
    }

    public int visitBuildingBlockEnd(final BuildingBlock block) {
        mBuilder.append("\tVisited block \"" + block.getName() + "\"" + "\r\n");
        mBuilder.append("\t Type: " + block.getType() + "\r\n");
        mBuilder.append("\t Gallery: " + block.getGallery() + "\r\n");
        mBuilder.append("\t Behavior: " + block.getBehavior() + "\r\n");
        mBuilder.append("\t Description: " + block.getDescription() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    private final HashMap&lt;UUID, BuildingBlock&gt; mBlocksByGuid;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitGlossaryDocumentStart(com.aspose.words.GlossaryDocument)"><!-- --></A><A NAME="visitGlossaryDocumentStart-com.aspose.words.GlossaryDocument-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitGlossaryDocumentStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitGlossaryDocumentStart</B>(<A HREF="GlossaryDocument.html" title="class in com.aspose.words">GlossaryDocument</A>&nbsp;glossary)
                              throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a glossary document has started.
            </summary><remarks><p>
Note: A glossary document node and its children are not visited when you execute a
Visitor over a <cref><A HREF="Document.html" title="class in com.aspose.words">Document</A></cref>. If you want to execute a Visitor over a
glossary document, you need to call <cref><A HREF="GlossaryDocument.html#accept(com.aspose.words.DocumentVisitor)" title="method in class com.aspose.words.GlossaryDocument">GlossaryDocument.accept(com.aspose.words.DocumentVisitor)</A></cref>.
</p></remarks><DL><DT><B>Parameters:</B></DT><DD param="glossary"><CODE>glossary</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows ways of accessing building blocks in a glossary document.<pre>
public void glossaryDocument() throws Exception {
    Document doc = new Document();
    GlossaryDocument glossaryDoc = new GlossaryDocument();

    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 1"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 2"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 3"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 4"));
    glossaryDoc.appendChild(createNewBuildingBlock(glossaryDoc, "Block 5"));

    Assert.assertEquals(glossaryDoc.getBuildingBlocks().getCount(), 5);

    doc.setGlossaryDocument(glossaryDoc);

    // There are various ways of accessing building blocks.
    // 1 -  Get the first/last building blocks in the collection:
    Assert.assertEquals("Block 1", glossaryDoc.getFirstBuildingBlock().getName());
    Assert.assertEquals("Block 5", glossaryDoc.getLastBuildingBlock().getName());

    // 2 -  Get a building block by index:
    Assert.assertEquals("Block 2", glossaryDoc.getBuildingBlocks().get(1).getName());
    Assert.assertEquals("Block 3", glossaryDoc.getBuildingBlocks().toArray()[2].getName());

    // 3 -  Get the first building block that matches a gallery, name and category:
    Assert.assertEquals("Block 4",
            glossaryDoc.getBuildingBlock(BuildingBlockGallery.ALL, "(Empty Category)", "Block 4").getName());

    // We will do that using a custom visitor,
    // which will give every BuildingBlock in the GlossaryDocument a unique GUID
    GlossaryDocVisitor visitor = new GlossaryDocVisitor();
    // Visit start/end of the Glossary document.
    glossaryDoc.accept(visitor);
    // Visit only start of the Glossary document.
    glossaryDoc.acceptStart(visitor);
    // Visit only end of the Glossary document.
    glossaryDoc.acceptEnd(visitor);
    System.out.println(visitor.getText());

    // In Microsoft Word, we can access the building blocks via "Insert" -&gt; "Quick Parts" -&gt; "Building Blocks Organizer".
    doc.save(getArtifactsDir() + "BuildingBlocks.GlossaryDocument.dotx");
}

public static BuildingBlock createNewBuildingBlock(final GlossaryDocument glossaryDoc, final String buildingBlockName) {
    BuildingBlock buildingBlock = new BuildingBlock(glossaryDoc);
    buildingBlock.setName(buildingBlockName);

    return buildingBlock;
}

/// &lt;summary&gt;
/// Gives each building block in a visited glossary document a unique GUID.
/// Stores the GUID-building block pairs in a dictionary.
/// &lt;/summary&gt;
public static class GlossaryDocVisitor extends DocumentVisitor {
    public GlossaryDocVisitor() {
        mBlocksByGuid = new HashMap&lt;&gt;();
        mBuilder = new StringBuilder();
    }

    public String getText() {
        return mBuilder.toString();
    }

    public HashMap&lt;UUID, BuildingBlock&gt; getDictionary() {
        return mBlocksByGuid;
    }

    public int visitGlossaryDocumentStart(final GlossaryDocument glossary) {
        mBuilder.append("Glossary document found!\n");
        return VisitorAction.CONTINUE;
    }

    public int visitGlossaryDocumentEnd(final GlossaryDocument glossary) {
        mBuilder.append("Reached end of glossary!\n");
        mBuilder.append("BuildingBlocks found: " + mBlocksByGuid.size() + "\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitBuildingBlockStart(final BuildingBlock block) {
        block.setGuid(UUID.randomUUID());
        mBlocksByGuid.put(block.getGuid(), block);
        return VisitorAction.CONTINUE;
    }

    public int visitBuildingBlockEnd(final BuildingBlock block) {
        mBuilder.append("\tVisited block \"" + block.getName() + "\"" + "\r\n");
        mBuilder.append("\t Type: " + block.getType() + "\r\n");
        mBuilder.append("\t Gallery: " + block.getGallery() + "\r\n");
        mBuilder.append("\t Behavior: " + block.getBehavior() + "\r\n");
        mBuilder.append("\t Description: " + block.getDescription() + "\r\n");

        return VisitorAction.CONTINUE;
    }

    private final HashMap&lt;UUID, BuildingBlock&gt; mBlocksByGuid;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitGroupShapeEnd(com.aspose.words.GroupShape)"><!-- --></A><A NAME="visitGroupShapeEnd-com.aspose.words.GroupShape-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitGroupShapeEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitGroupShapeEnd</B>(<A HREF="GroupShape.html" title="class in com.aspose.words">GroupShape</A>&nbsp;groupShape)
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a group shape has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="groupShape"><CODE>groupShape</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to create a group of shapes, and print its contents using a document visitor.<pre>
public void groupOfShapes() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // If you need to create "NonPrimitive" shapes, such as SingleCornerSnipped, TopCornersSnipped, DiagonalCornersSnipped,
    // TopCornersOneRoundedOneSnipped, SingleCornerRounded, TopCornersRounded, DiagonalCornersRounded
    // please use DocumentBuilder.InsertShape methods.
    Shape balloon = new Shape(doc, ShapeType.BALLOON);
    balloon.setWidth(200.0);
    balloon.setHeight(200.0);
    balloon.setStrokeColor(Color.RED);

    Shape cube = new Shape(doc, ShapeType.CUBE);
    cube.setWidth(100.0);
    cube.setHeight(100.0);
    cube.setStrokeColor(Color.BLUE);

    GroupShape group = new GroupShape(doc);
    group.appendChild(balloon);
    group.appendChild(cube);

    Assert.assertTrue(group.isGroup());
    builder.insertNode(group);

    ShapeInfoPrinter printer = new ShapeInfoPrinter();
    group.accept(printer);

    System.out.println(printer.getText());
}

/// &lt;summary&gt;
/// Prints the contents of a visited shape group to the console.
/// &lt;/summary&gt;
public static class ShapeInfoPrinter extends DocumentVisitor {
    public ShapeInfoPrinter() {
        mBuilder = new StringBuilder();
    }

    public String getText() {
        return mBuilder.toString();
    }

    public int visitGroupShapeStart(final GroupShape groupShape) {
        mBuilder.append("Shape group started:\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitGroupShapeEnd(final GroupShape groupShape) {
        mBuilder.append("End of shape group\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitShapeStart(final Shape shape) {
        mBuilder.append("\tShape - " + shape.getShapeType() + ":\r\n");
        mBuilder.append("\t\tWidth: " + shape.getWidth() + "\r\n");
        mBuilder.append("\t\tHeight: " + shape.getHeight() + "\r\n");
        mBuilder.append("\t\tStroke color: " + shape.getStroke().getColor() + "\r\n");
        mBuilder.append("\t\tFill color: " + shape.getFill().getForeColor() + "\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitShapeEnd(final Shape shape) {
        mBuilder.append("\tEnd of shape\r\n");
        return VisitorAction.CONTINUE;
    }

    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitGroupShapeStart(com.aspose.words.GroupShape)"><!-- --></A><A NAME="visitGroupShapeStart-com.aspose.words.GroupShape-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitGroupShapeStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitGroupShapeStart</B>(<A HREF="GroupShape.html" title="class in com.aspose.words">GroupShape</A>&nbsp;groupShape)
                        throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a group shape has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="groupShape"><CODE>groupShape</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a DocumentVisitor implementation to remove all hidden content from a document.<pre>
public void removeHiddenContentFromDocument() throws Exception {
    Document doc = new Document(getMyDir() + "Hidden content.docx");
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // Below are three types of fields which can accept a document visitor,
    // which will allow it to visit the accepting node, and then traverse its child nodes in a depth-first manner.
    // 1 -  Paragraph node:
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // 2 -  Table node:
    Table table = doc.getFirstSection().getBody().getTables().get(0);
    table.accept(hiddenContentRemover);

    // 3 -  Document node:
    doc.accept(hiddenContentRemover);

    doc.save(getArtifactsDir() + "Font.RemoveHiddenContentFromDocument.docx");
}

/// &lt;summary&gt;
/// Removes all visited nodes marked as "hidden content".
/// &lt;/summary&gt;
public static class RemoveHiddenContentVisitor extends DocumentVisitor {
    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(FieldStart fieldStart) {
        if (fieldStart.getFont().getHidden())
            fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(FieldEnd fieldEnd) {
        if (fieldEnd.getFont().getHidden())
            fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(FieldSeparator fieldSeparator) {
        if (fieldSeparator.getFont().getHidden())
            fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(Run run) {
        if (run.getFont().getHidden())
            run.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(Paragraph paragraph) {
        if (paragraph.getParagraphBreakFont().getHidden())
            paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FormField is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFormField(FormField formField) {
        if (formField.getFont().getHidden())
            formField.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a GroupShape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitGroupShapeStart(GroupShape groupShape) {
        if (groupShape.getFont().getHidden())
            groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Shape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitShapeStart(Shape shape) {
        if (shape.getFont().getHidden())
            shape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(Comment comment) {
        if (comment.getFont().getHidden())
            comment.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Footnote is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFootnoteStart(Footnote footnote) {
        if (footnote.getFont().getHidden())
            footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SpecialCharacter is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSpecialChar(SpecialChar specialChar) {
        if (specialChar.getFont().getHidden())
            specialChar.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Table node is ended in the document.
    /// &lt;/summary&gt;
    public int visitTableEnd(Table table) {
        // The content inside table cells may have the hidden content flag, but the tables themselves cannot.
        // If this table had nothing but hidden content, this visitor would have removed all of it,
        // and there would be no child nodes left.
        // Thus, we can also treat the table itself as hidden content and remove it.
        // Tables which are empty but do not have hidden content will have cells with empty paragraphs inside,
        // which this visitor will not remove.
        if (!table.hasChildNodes())
            table.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Cell node is ended in the document.
    /// &lt;/summary&gt;
    public int visitCellEnd(Cell cell) {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null)
            cell.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Row node is ended in the document.
    /// &lt;/summary&gt;
    public int visitRowEnd(Row row) {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null)
            row.remove();

        return VisitorAction.CONTINUE;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to create a group of shapes, and print its contents using a document visitor.<pre>
public void groupOfShapes() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // If you need to create "NonPrimitive" shapes, such as SingleCornerSnipped, TopCornersSnipped, DiagonalCornersSnipped,
    // TopCornersOneRoundedOneSnipped, SingleCornerRounded, TopCornersRounded, DiagonalCornersRounded
    // please use DocumentBuilder.InsertShape methods.
    Shape balloon = new Shape(doc, ShapeType.BALLOON);
    balloon.setWidth(200.0);
    balloon.setHeight(200.0);
    balloon.setStrokeColor(Color.RED);

    Shape cube = new Shape(doc, ShapeType.CUBE);
    cube.setWidth(100.0);
    cube.setHeight(100.0);
    cube.setStrokeColor(Color.BLUE);

    GroupShape group = new GroupShape(doc);
    group.appendChild(balloon);
    group.appendChild(cube);

    Assert.assertTrue(group.isGroup());
    builder.insertNode(group);

    ShapeInfoPrinter printer = new ShapeInfoPrinter();
    group.accept(printer);

    System.out.println(printer.getText());
}

/// &lt;summary&gt;
/// Prints the contents of a visited shape group to the console.
/// &lt;/summary&gt;
public static class ShapeInfoPrinter extends DocumentVisitor {
    public ShapeInfoPrinter() {
        mBuilder = new StringBuilder();
    }

    public String getText() {
        return mBuilder.toString();
    }

    public int visitGroupShapeStart(final GroupShape groupShape) {
        mBuilder.append("Shape group started:\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitGroupShapeEnd(final GroupShape groupShape) {
        mBuilder.append("End of shape group\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitShapeStart(final Shape shape) {
        mBuilder.append("\tShape - " + shape.getShapeType() + ":\r\n");
        mBuilder.append("\t\tWidth: " + shape.getWidth() + "\r\n");
        mBuilder.append("\t\tHeight: " + shape.getHeight() + "\r\n");
        mBuilder.append("\t\tStroke color: " + shape.getStroke().getColor() + "\r\n");
        mBuilder.append("\t\tFill color: " + shape.getFill().getForeColor() + "\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitShapeEnd(final Shape shape) {
        mBuilder.append("\tEnd of shape\r\n");
        return VisitorAction.CONTINUE;
    }

    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitHeaderFooterEnd(com.aspose.words.HeaderFooter)"><!-- --></A><A NAME="visitHeaderFooterEnd-com.aspose.words.HeaderFooter-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitHeaderFooterEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitHeaderFooterEnd</B>(<A HREF="HeaderFooter.html" title="class in com.aspose.words">HeaderFooter</A>&nbsp;headerFooter)
                        throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a header or footer in a section has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="headerFooter"><CODE>headerFooter</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every header and footer in a document.<pre>
public void headerFooterToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    HeaderFooterStructurePrinter visitor = new HeaderFooterStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());

    // An alternative way of accessing a document's header/footers section-by-section is by accessing the collection.
    HeaderFooter[] headerFooters = doc.getFirstSection().getHeadersFooters().toArray();
    Assert.assertEquals(3, headerFooters.length);
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered HeaderFooter nodes and their children.
/// &lt;/summary&gt;
public static class HeaderFooterStructurePrinter extends DocumentVisitor {
    public HeaderFooterStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideHeaderFooter = false;
    }

    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideHeaderFooter) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a HeaderFooter node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitHeaderFooterStart(final HeaderFooter headerFooter) {
        indentAndAppendLine("[HeaderFooter start] HeaderFooterType: " + headerFooter.getHeaderFooterType());
        mDocTraversalDepth++;
        mVisitorIsInsideHeaderFooter = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a HeaderFooter node have been visited.
    /// &lt;/summary&gt;
    public int visitHeaderFooterEnd(final HeaderFooter headerFooter) {
        mDocTraversalDepth--;
        indentAndAppendLine("[HeaderFooter end]");
        mVisitorIsInsideHeaderFooter = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideHeaderFooter;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitHeaderFooterStart(com.aspose.words.HeaderFooter)"><!-- --></A><A NAME="visitHeaderFooterStart-com.aspose.words.HeaderFooter-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitHeaderFooterStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitHeaderFooterStart</B>(<A HREF="HeaderFooter.html" title="class in com.aspose.words">HeaderFooter</A>&nbsp;headerFooter)
                          throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a header or footer in a section has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="headerFooter"><CODE>headerFooter</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every header and footer in a document.<pre>
public void headerFooterToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    HeaderFooterStructurePrinter visitor = new HeaderFooterStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());

    // An alternative way of accessing a document's header/footers section-by-section is by accessing the collection.
    HeaderFooter[] headerFooters = doc.getFirstSection().getHeadersFooters().toArray();
    Assert.assertEquals(3, headerFooters.length);
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered HeaderFooter nodes and their children.
/// &lt;/summary&gt;
public static class HeaderFooterStructurePrinter extends DocumentVisitor {
    public HeaderFooterStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideHeaderFooter = false;
    }

    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideHeaderFooter) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a HeaderFooter node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitHeaderFooterStart(final HeaderFooter headerFooter) {
        indentAndAppendLine("[HeaderFooter start] HeaderFooterType: " + headerFooter.getHeaderFooterType());
        mDocTraversalDepth++;
        mVisitorIsInsideHeaderFooter = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a HeaderFooter node have been visited.
    /// &lt;/summary&gt;
    public int visitHeaderFooterEnd(final HeaderFooter headerFooter) {
        mDocTraversalDepth--;
        indentAndAppendLine("[HeaderFooter end]");
        mVisitorIsInsideHeaderFooter = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideHeaderFooter;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitOfficeMathEnd(com.aspose.words.OfficeMath)"><!-- --></A><A NAME="visitOfficeMathEnd-com.aspose.words.OfficeMath-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitOfficeMathEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitOfficeMathEnd</B>(<A HREF="OfficeMath.html" title="class in com.aspose.words">OfficeMath</A>&nbsp;officeMath)
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a Office Math object has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="officeMath"><CODE>officeMath</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every office math node in a document.<pre>
public void officeMathToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    OfficeMathStructurePrinter visitor = new OfficeMathStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered OfficeMath nodes and their children.
/// &lt;/summary&gt;
public static class OfficeMathStructurePrinter extends DocumentVisitor {
    public OfficeMathStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideOfficeMath = false;
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideOfficeMath) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when an OfficeMath node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitOfficeMathStart(final OfficeMath officeMath) {
        indentAndAppendLine("[OfficeMath start] Math object type: " + officeMath.getMathObjectType());
        mDocTraversalDepth++;
        mVisitorIsInsideOfficeMath = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of an OfficeMath node have been visited.
    /// &lt;/summary&gt;
    public int visitOfficeMathEnd(final OfficeMath officeMath) {
        mDocTraversalDepth--;
        indentAndAppendLine("[OfficeMath end]");
        mVisitorIsInsideOfficeMath = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideOfficeMath;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitOfficeMathStart(com.aspose.words.OfficeMath)"><!-- --></A><A NAME="visitOfficeMathStart-com.aspose.words.OfficeMath-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitOfficeMathStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitOfficeMathStart</B>(<A HREF="OfficeMath.html" title="class in com.aspose.words">OfficeMath</A>&nbsp;officeMath)
                        throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a Office Math object has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="officeMath"><CODE>officeMath</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every office math node in a document.<pre>
public void officeMathToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    OfficeMathStructurePrinter visitor = new OfficeMathStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered OfficeMath nodes and their children.
/// &lt;/summary&gt;
public static class OfficeMathStructurePrinter extends DocumentVisitor {
    public OfficeMathStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideOfficeMath = false;
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideOfficeMath) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when an OfficeMath node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitOfficeMathStart(final OfficeMath officeMath) {
        indentAndAppendLine("[OfficeMath start] Math object type: " + officeMath.getMathObjectType());
        mDocTraversalDepth++;
        mVisitorIsInsideOfficeMath = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of an OfficeMath node have been visited.
    /// &lt;/summary&gt;
    public int visitOfficeMathEnd(final OfficeMath officeMath) {
        mDocTraversalDepth--;
        indentAndAppendLine("[OfficeMath end]");
        mVisitorIsInsideOfficeMath = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideOfficeMath;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitParagraphEnd(com.aspose.words.Paragraph)"><!-- --></A><A NAME="visitParagraphEnd-com.aspose.words.Paragraph-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitParagraphEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitParagraphEnd</B>(<A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A>&nbsp;paragraph)
                     throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a paragraph has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="paragraph"><CODE>paragraph</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
</DL>
<HR>

<A NAME="visitParagraphStart(com.aspose.words.Paragraph)"><!-- --></A><A NAME="visitParagraphStart-com.aspose.words.Paragraph-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitParagraphStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitParagraphStart</B>(<A HREF="Paragraph.html" title="class in com.aspose.words">Paragraph</A>&nbsp;paragraph)
                       throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a paragraph has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="paragraph"><CODE>paragraph</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a DocumentVisitor implementation to remove all hidden content from a document.<pre>
public void removeHiddenContentFromDocument() throws Exception {
    Document doc = new Document(getMyDir() + "Hidden content.docx");
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // Below are three types of fields which can accept a document visitor,
    // which will allow it to visit the accepting node, and then traverse its child nodes in a depth-first manner.
    // 1 -  Paragraph node:
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // 2 -  Table node:
    Table table = doc.getFirstSection().getBody().getTables().get(0);
    table.accept(hiddenContentRemover);

    // 3 -  Document node:
    doc.accept(hiddenContentRemover);

    doc.save(getArtifactsDir() + "Font.RemoveHiddenContentFromDocument.docx");
}

/// &lt;summary&gt;
/// Removes all visited nodes marked as "hidden content".
/// &lt;/summary&gt;
public static class RemoveHiddenContentVisitor extends DocumentVisitor {
    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(FieldStart fieldStart) {
        if (fieldStart.getFont().getHidden())
            fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(FieldEnd fieldEnd) {
        if (fieldEnd.getFont().getHidden())
            fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(FieldSeparator fieldSeparator) {
        if (fieldSeparator.getFont().getHidden())
            fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(Run run) {
        if (run.getFont().getHidden())
            run.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(Paragraph paragraph) {
        if (paragraph.getParagraphBreakFont().getHidden())
            paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FormField is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFormField(FormField formField) {
        if (formField.getFont().getHidden())
            formField.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a GroupShape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitGroupShapeStart(GroupShape groupShape) {
        if (groupShape.getFont().getHidden())
            groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Shape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitShapeStart(Shape shape) {
        if (shape.getFont().getHidden())
            shape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(Comment comment) {
        if (comment.getFont().getHidden())
            comment.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Footnote is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFootnoteStart(Footnote footnote) {
        if (footnote.getFont().getHidden())
            footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SpecialCharacter is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSpecialChar(SpecialChar specialChar) {
        if (specialChar.getFont().getHidden())
            specialChar.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Table node is ended in the document.
    /// &lt;/summary&gt;
    public int visitTableEnd(Table table) {
        // The content inside table cells may have the hidden content flag, but the tables themselves cannot.
        // If this table had nothing but hidden content, this visitor would have removed all of it,
        // and there would be no child nodes left.
        // Thus, we can also treat the table itself as hidden content and remove it.
        // Tables which are empty but do not have hidden content will have cells with empty paragraphs inside,
        // which this visitor will not remove.
        if (!table.hasChildNodes())
            table.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Cell node is ended in the document.
    /// &lt;/summary&gt;
    public int visitCellEnd(Cell cell) {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null)
            cell.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Row node is ended in the document.
    /// &lt;/summary&gt;
    public int visitRowEnd(Row row) {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null)
            row.remove();

        return VisitorAction.CONTINUE;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
</DL>
<HR>

<A NAME="visitRowEnd(com.aspose.words.Row)"><!-- --></A><A NAME="visitRowEnd-com.aspose.words.Row-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitRowEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitRowEnd</B>(<A HREF="Row.html" title="class in com.aspose.words">Row</A>&nbsp;row)
               throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a table row has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="row"><CODE>row</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a DocumentVisitor implementation to remove all hidden content from a document.<pre>
public void removeHiddenContentFromDocument() throws Exception {
    Document doc = new Document(getMyDir() + "Hidden content.docx");
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // Below are three types of fields which can accept a document visitor,
    // which will allow it to visit the accepting node, and then traverse its child nodes in a depth-first manner.
    // 1 -  Paragraph node:
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // 2 -  Table node:
    Table table = doc.getFirstSection().getBody().getTables().get(0);
    table.accept(hiddenContentRemover);

    // 3 -  Document node:
    doc.accept(hiddenContentRemover);

    doc.save(getArtifactsDir() + "Font.RemoveHiddenContentFromDocument.docx");
}

/// &lt;summary&gt;
/// Removes all visited nodes marked as "hidden content".
/// &lt;/summary&gt;
public static class RemoveHiddenContentVisitor extends DocumentVisitor {
    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(FieldStart fieldStart) {
        if (fieldStart.getFont().getHidden())
            fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(FieldEnd fieldEnd) {
        if (fieldEnd.getFont().getHidden())
            fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(FieldSeparator fieldSeparator) {
        if (fieldSeparator.getFont().getHidden())
            fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(Run run) {
        if (run.getFont().getHidden())
            run.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(Paragraph paragraph) {
        if (paragraph.getParagraphBreakFont().getHidden())
            paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FormField is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFormField(FormField formField) {
        if (formField.getFont().getHidden())
            formField.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a GroupShape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitGroupShapeStart(GroupShape groupShape) {
        if (groupShape.getFont().getHidden())
            groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Shape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitShapeStart(Shape shape) {
        if (shape.getFont().getHidden())
            shape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(Comment comment) {
        if (comment.getFont().getHidden())
            comment.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Footnote is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFootnoteStart(Footnote footnote) {
        if (footnote.getFont().getHidden())
            footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SpecialCharacter is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSpecialChar(SpecialChar specialChar) {
        if (specialChar.getFont().getHidden())
            specialChar.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Table node is ended in the document.
    /// &lt;/summary&gt;
    public int visitTableEnd(Table table) {
        // The content inside table cells may have the hidden content flag, but the tables themselves cannot.
        // If this table had nothing but hidden content, this visitor would have removed all of it,
        // and there would be no child nodes left.
        // Thus, we can also treat the table itself as hidden content and remove it.
        // Tables which are empty but do not have hidden content will have cells with empty paragraphs inside,
        // which this visitor will not remove.
        if (!table.hasChildNodes())
            table.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Cell node is ended in the document.
    /// &lt;/summary&gt;
    public int visitCellEnd(Cell cell) {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null)
            cell.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Row node is ended in the document.
    /// &lt;/summary&gt;
    public int visitRowEnd(Row row) {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null)
            row.remove();

        return VisitorAction.CONTINUE;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<A NAME="visitRowStart(com.aspose.words.Row)"><!-- --></A><A NAME="visitRowStart-com.aspose.words.Row-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitRowStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitRowStart</B>(<A HREF="Row.html" title="class in com.aspose.words">Row</A>&nbsp;row)
                 throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a table row has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="row"><CODE>row</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<A NAME="visitRun(com.aspose.words.Run)"><!-- --></A><A NAME="visitRun-com.aspose.words.Run-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitRun</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitRun</B>(<A HREF="Run.html" title="class in com.aspose.words">Run</A>&nbsp;run)
            throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a run of text in the is encountered.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="run"><CODE>run</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
</DL>
<HR>

<A NAME="visitSectionEnd(com.aspose.words.Section)"><!-- --></A><A NAME="visitSectionEnd-com.aspose.words.Section-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitSectionEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitSectionEnd</B>(<A HREF="Section.html" title="class in com.aspose.words">Section</A>&nbsp;section)
                   throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a section has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="section"><CODE>section</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
</DL>
<HR>

<A NAME="visitSectionStart(com.aspose.words.Section)"><!-- --></A><A NAME="visitSectionStart-com.aspose.words.Section-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitSectionStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitSectionStart</B>(<A HREF="Section.html" title="class in com.aspose.words">Section</A>&nbsp;section)
                     throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a section has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="section"><CODE>section</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
</DL>
<HR>

<A NAME="visitShapeEnd(com.aspose.words.Shape)"><!-- --></A><A NAME="visitShapeEnd-com.aspose.words.Shape-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitShapeEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitShapeEnd</B>(<A HREF="Shape.html" title="class in com.aspose.words">Shape</A>&nbsp;shape)
                 throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a shape has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="shape"><CODE>shape</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to create a group of shapes, and print its contents using a document visitor.<pre>
public void groupOfShapes() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // If you need to create "NonPrimitive" shapes, such as SingleCornerSnipped, TopCornersSnipped, DiagonalCornersSnipped,
    // TopCornersOneRoundedOneSnipped, SingleCornerRounded, TopCornersRounded, DiagonalCornersRounded
    // please use DocumentBuilder.InsertShape methods.
    Shape balloon = new Shape(doc, ShapeType.BALLOON);
    balloon.setWidth(200.0);
    balloon.setHeight(200.0);
    balloon.setStrokeColor(Color.RED);

    Shape cube = new Shape(doc, ShapeType.CUBE);
    cube.setWidth(100.0);
    cube.setHeight(100.0);
    cube.setStrokeColor(Color.BLUE);

    GroupShape group = new GroupShape(doc);
    group.appendChild(balloon);
    group.appendChild(cube);

    Assert.assertTrue(group.isGroup());
    builder.insertNode(group);

    ShapeInfoPrinter printer = new ShapeInfoPrinter();
    group.accept(printer);

    System.out.println(printer.getText());
}

/// &lt;summary&gt;
/// Prints the contents of a visited shape group to the console.
/// &lt;/summary&gt;
public static class ShapeInfoPrinter extends DocumentVisitor {
    public ShapeInfoPrinter() {
        mBuilder = new StringBuilder();
    }

    public String getText() {
        return mBuilder.toString();
    }

    public int visitGroupShapeStart(final GroupShape groupShape) {
        mBuilder.append("Shape group started:\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitGroupShapeEnd(final GroupShape groupShape) {
        mBuilder.append("End of shape group\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitShapeStart(final Shape shape) {
        mBuilder.append("\tShape - " + shape.getShapeType() + ":\r\n");
        mBuilder.append("\t\tWidth: " + shape.getWidth() + "\r\n");
        mBuilder.append("\t\tHeight: " + shape.getHeight() + "\r\n");
        mBuilder.append("\t\tStroke color: " + shape.getStroke().getColor() + "\r\n");
        mBuilder.append("\t\tFill color: " + shape.getFill().getForeColor() + "\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitShapeEnd(final Shape shape) {
        mBuilder.append("\tEnd of shape\r\n");
        return VisitorAction.CONTINUE;
    }

    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitShapeStart(com.aspose.words.Shape)"><!-- --></A><A NAME="visitShapeStart-com.aspose.words.Shape-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitShapeStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitShapeStart</B>(<A HREF="Shape.html" title="class in com.aspose.words">Shape</A>&nbsp;shape)
                   throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a shape has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="shape"><CODE>shape</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a DocumentVisitor implementation to remove all hidden content from a document.<pre>
public void removeHiddenContentFromDocument() throws Exception {
    Document doc = new Document(getMyDir() + "Hidden content.docx");
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // Below are three types of fields which can accept a document visitor,
    // which will allow it to visit the accepting node, and then traverse its child nodes in a depth-first manner.
    // 1 -  Paragraph node:
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // 2 -  Table node:
    Table table = doc.getFirstSection().getBody().getTables().get(0);
    table.accept(hiddenContentRemover);

    // 3 -  Document node:
    doc.accept(hiddenContentRemover);

    doc.save(getArtifactsDir() + "Font.RemoveHiddenContentFromDocument.docx");
}

/// &lt;summary&gt;
/// Removes all visited nodes marked as "hidden content".
/// &lt;/summary&gt;
public static class RemoveHiddenContentVisitor extends DocumentVisitor {
    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(FieldStart fieldStart) {
        if (fieldStart.getFont().getHidden())
            fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(FieldEnd fieldEnd) {
        if (fieldEnd.getFont().getHidden())
            fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(FieldSeparator fieldSeparator) {
        if (fieldSeparator.getFont().getHidden())
            fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(Run run) {
        if (run.getFont().getHidden())
            run.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(Paragraph paragraph) {
        if (paragraph.getParagraphBreakFont().getHidden())
            paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FormField is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFormField(FormField formField) {
        if (formField.getFont().getHidden())
            formField.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a GroupShape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitGroupShapeStart(GroupShape groupShape) {
        if (groupShape.getFont().getHidden())
            groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Shape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitShapeStart(Shape shape) {
        if (shape.getFont().getHidden())
            shape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(Comment comment) {
        if (comment.getFont().getHidden())
            comment.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Footnote is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFootnoteStart(Footnote footnote) {
        if (footnote.getFont().getHidden())
            footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SpecialCharacter is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSpecialChar(SpecialChar specialChar) {
        if (specialChar.getFont().getHidden())
            specialChar.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Table node is ended in the document.
    /// &lt;/summary&gt;
    public int visitTableEnd(Table table) {
        // The content inside table cells may have the hidden content flag, but the tables themselves cannot.
        // If this table had nothing but hidden content, this visitor would have removed all of it,
        // and there would be no child nodes left.
        // Thus, we can also treat the table itself as hidden content and remove it.
        // Tables which are empty but do not have hidden content will have cells with empty paragraphs inside,
        // which this visitor will not remove.
        if (!table.hasChildNodes())
            table.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Cell node is ended in the document.
    /// &lt;/summary&gt;
    public int visitCellEnd(Cell cell) {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null)
            cell.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Row node is ended in the document.
    /// &lt;/summary&gt;
    public int visitRowEnd(Row row) {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null)
            row.remove();

        return VisitorAction.CONTINUE;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to create a group of shapes, and print its contents using a document visitor.<pre>
public void groupOfShapes() throws Exception {
    Document doc = new Document();
    DocumentBuilder builder = new DocumentBuilder(doc);

    // If you need to create "NonPrimitive" shapes, such as SingleCornerSnipped, TopCornersSnipped, DiagonalCornersSnipped,
    // TopCornersOneRoundedOneSnipped, SingleCornerRounded, TopCornersRounded, DiagonalCornersRounded
    // please use DocumentBuilder.InsertShape methods.
    Shape balloon = new Shape(doc, ShapeType.BALLOON);
    balloon.setWidth(200.0);
    balloon.setHeight(200.0);
    balloon.setStrokeColor(Color.RED);

    Shape cube = new Shape(doc, ShapeType.CUBE);
    cube.setWidth(100.0);
    cube.setHeight(100.0);
    cube.setStrokeColor(Color.BLUE);

    GroupShape group = new GroupShape(doc);
    group.appendChild(balloon);
    group.appendChild(cube);

    Assert.assertTrue(group.isGroup());
    builder.insertNode(group);

    ShapeInfoPrinter printer = new ShapeInfoPrinter();
    group.accept(printer);

    System.out.println(printer.getText());
}

/// &lt;summary&gt;
/// Prints the contents of a visited shape group to the console.
/// &lt;/summary&gt;
public static class ShapeInfoPrinter extends DocumentVisitor {
    public ShapeInfoPrinter() {
        mBuilder = new StringBuilder();
    }

    public String getText() {
        return mBuilder.toString();
    }

    public int visitGroupShapeStart(final GroupShape groupShape) {
        mBuilder.append("Shape group started:\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitGroupShapeEnd(final GroupShape groupShape) {
        mBuilder.append("End of shape group\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitShapeStart(final Shape shape) {
        mBuilder.append("\tShape - " + shape.getShapeType() + ":\r\n");
        mBuilder.append("\t\tWidth: " + shape.getWidth() + "\r\n");
        mBuilder.append("\t\tHeight: " + shape.getHeight() + "\r\n");
        mBuilder.append("\t\tStroke color: " + shape.getStroke().getColor() + "\r\n");
        mBuilder.append("\t\tFill color: " + shape.getFill().getForeColor() + "\r\n");
        return VisitorAction.CONTINUE;
    }

    public int visitShapeEnd(final Shape shape) {
        mBuilder.append("\tEnd of shape\r\n");
        return VisitorAction.CONTINUE;
    }

    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitSmartTagEnd(com.aspose.words.SmartTag)"><!-- --></A><A NAME="visitSmartTagEnd-com.aspose.words.SmartTag-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitSmartTagEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitSmartTagEnd</B>(<A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A>&nbsp;smartTag)
                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a smart tag has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="smartTag"><CODE>smartTag</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every smart tag in a document.<pre>
public void smartTagToText() throws Exception {
    Document doc = new Document(getMyDir() + "Smart tags.doc");
    SmartTagStructurePrinter visitor = new SmartTagStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered SmartTag nodes and their children.
/// &lt;/summary&gt;
public static class SmartTagStructurePrinter extends DocumentVisitor {
    public SmartTagStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideSmartTag = false;
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideSmartTag) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SmartTag node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSmartTagStart(final SmartTag smartTag) {
        indentAndAppendLine("[SmartTag start] Name: " + smartTag.getElement());
        mDocTraversalDepth++;
        mVisitorIsInsideSmartTag = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a SmartTag node have been visited.
    /// &lt;/summary&gt;
    public int visitSmartTagEnd(final SmartTag smartTag) {
        mDocTraversalDepth--;
        indentAndAppendLine("[SmartTag end]");
        mVisitorIsInsideSmartTag = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideSmartTag;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitSmartTagStart(com.aspose.words.SmartTag)"><!-- --></A><A NAME="visitSmartTagStart-com.aspose.words.SmartTag-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitSmartTagStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitSmartTagStart</B>(<A HREF="SmartTag.html" title="class in com.aspose.words">SmartTag</A>&nbsp;smartTag)
                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a smart tag has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="smartTag"><CODE>smartTag</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every smart tag in a document.<pre>
public void smartTagToText() throws Exception {
    Document doc = new Document(getMyDir() + "Smart tags.doc");
    SmartTagStructurePrinter visitor = new SmartTagStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered SmartTag nodes and their children.
/// &lt;/summary&gt;
public static class SmartTagStructurePrinter extends DocumentVisitor {
    public SmartTagStructurePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideSmartTag = false;
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideSmartTag) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SmartTag node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSmartTagStart(final SmartTag smartTag) {
        indentAndAppendLine("[SmartTag start] Name: " + smartTag.getElement());
        mDocTraversalDepth++;
        mVisitorIsInsideSmartTag = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a SmartTag node have been visited.
    /// &lt;/summary&gt;
    public int visitSmartTagEnd(final SmartTag smartTag) {
        mDocTraversalDepth--;
        indentAndAppendLine("[SmartTag end]");
        mVisitorIsInsideSmartTag = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideSmartTag;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitSpecialChar(com.aspose.words.SpecialChar)"><!-- --></A><A NAME="visitSpecialChar-com.aspose.words.SpecialChar-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitSpecialChar</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitSpecialChar</B>(<A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A>&nbsp;specialChar)
                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a <cref><A HREF="SpecialChar.html" title="class in com.aspose.words">SpecialChar</A></cref> node is encountered in the document.
            </summary><remarks>
            This method is not be called for generic control characters (see <cref><A HREF="ControlChar.html" title="class in com.aspose.words">ControlChar</A></cref>) that can be present in the document.
            </remarks><DL><DT><B>Parameters:</B></DT><DD param="specialChar"><CODE>specialChar</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a DocumentVisitor implementation to remove all hidden content from a document.<pre>
public void removeHiddenContentFromDocument() throws Exception {
    Document doc = new Document(getMyDir() + "Hidden content.docx");
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // Below are three types of fields which can accept a document visitor,
    // which will allow it to visit the accepting node, and then traverse its child nodes in a depth-first manner.
    // 1 -  Paragraph node:
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // 2 -  Table node:
    Table table = doc.getFirstSection().getBody().getTables().get(0);
    table.accept(hiddenContentRemover);

    // 3 -  Document node:
    doc.accept(hiddenContentRemover);

    doc.save(getArtifactsDir() + "Font.RemoveHiddenContentFromDocument.docx");
}

/// &lt;summary&gt;
/// Removes all visited nodes marked as "hidden content".
/// &lt;/summary&gt;
public static class RemoveHiddenContentVisitor extends DocumentVisitor {
    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(FieldStart fieldStart) {
        if (fieldStart.getFont().getHidden())
            fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(FieldEnd fieldEnd) {
        if (fieldEnd.getFont().getHidden())
            fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(FieldSeparator fieldSeparator) {
        if (fieldSeparator.getFont().getHidden())
            fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(Run run) {
        if (run.getFont().getHidden())
            run.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(Paragraph paragraph) {
        if (paragraph.getParagraphBreakFont().getHidden())
            paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FormField is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFormField(FormField formField) {
        if (formField.getFont().getHidden())
            formField.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a GroupShape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitGroupShapeStart(GroupShape groupShape) {
        if (groupShape.getFont().getHidden())
            groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Shape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitShapeStart(Shape shape) {
        if (shape.getFont().getHidden())
            shape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(Comment comment) {
        if (comment.getFont().getHidden())
            comment.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Footnote is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFootnoteStart(Footnote footnote) {
        if (footnote.getFont().getHidden())
            footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SpecialCharacter is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSpecialChar(SpecialChar specialChar) {
        if (specialChar.getFont().getHidden())
            specialChar.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Table node is ended in the document.
    /// &lt;/summary&gt;
    public int visitTableEnd(Table table) {
        // The content inside table cells may have the hidden content flag, but the tables themselves cannot.
        // If this table had nothing but hidden content, this visitor would have removed all of it,
        // and there would be no child nodes left.
        // Thus, we can also treat the table itself as hidden content and remove it.
        // Tables which are empty but do not have hidden content will have cells with empty paragraphs inside,
        // which this visitor will not remove.
        if (!table.hasChildNodes())
            table.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Cell node is ended in the document.
    /// &lt;/summary&gt;
    public int visitCellEnd(Cell cell) {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null)
            cell.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Row node is ended in the document.
    /// &lt;/summary&gt;
    public int visitRowEnd(Row row) {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null)
            row.remove();

        return VisitorAction.CONTINUE;
    }
}</pre></example>
</DL>
<HR>

<A NAME="visitStructuredDocumentTagEnd(com.aspose.words.StructuredDocumentTag)"><!-- --></A><A NAME="visitStructuredDocumentTagEnd-com.aspose.words.StructuredDocumentTag-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitStructuredDocumentTagEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitStructuredDocumentTagEnd</B>(<A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A>&nbsp;sdt)
                                 throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a structured document tag has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="sdt"><CODE>sdt</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every structured document tag in a document.<pre>
public void structuredDocumentTagToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    StructuredDocumentTagNodePrinter visitor = new StructuredDocumentTagNodePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered StructuredDocumentTag nodes and their children.
/// &lt;/summary&gt;
public static class StructuredDocumentTagNodePrinter extends DocumentVisitor {
    public StructuredDocumentTagNodePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideStructuredDocumentTag = false;
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideStructuredDocumentTag) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a StructuredDocumentTag node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitStructuredDocumentTagStart(final StructuredDocumentTag sdt) {
        indentAndAppendLine("[StructuredDocumentTag start] Title: " + sdt.getTitle());
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a StructuredDocumentTag node have been visited.
    /// &lt;/summary&gt;
    public int visitStructuredDocumentTagEnd(final StructuredDocumentTag sdt) {
        mDocTraversalDepth--;
        indentAndAppendLine("[StructuredDocumentTag end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private final boolean mVisitorIsInsideStructuredDocumentTag;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitStructuredDocumentTagRangeEnd(com.aspose.words.StructuredDocumentTagRangeEnd)"><!-- --></A><A NAME="visitStructuredDocumentTagRangeEnd-com.aspose.words.StructuredDocumentTagRangeEnd-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitStructuredDocumentTagRangeEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitStructuredDocumentTagRangeEnd</B>(<A HREF="StructuredDocumentTagRangeEnd.html" title="class in com.aspose.words">StructuredDocumentTagRangeEnd</A>&nbsp;sdtRangeEnd)
                                      throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a StructuredDocumentTagRangeEnd is encountered.
            </summary><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
</DL>
<HR>

<A NAME="visitStructuredDocumentTagRangeStart(com.aspose.words.StructuredDocumentTagRangeStart)"><!-- --></A><A NAME="visitStructuredDocumentTagRangeStart-com.aspose.words.StructuredDocumentTagRangeStart-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitStructuredDocumentTagRangeStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitStructuredDocumentTagRangeStart</B>(<A HREF="StructuredDocumentTagRangeStart.html" title="class in com.aspose.words">StructuredDocumentTagRangeStart</A>&nbsp;sdtRangeStart)
                                        throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a StructuredDocumentTagRangeStart is encountered.
            </summary><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
</DL>
<HR>

<A NAME="visitStructuredDocumentTagStart(com.aspose.words.StructuredDocumentTag)"><!-- --></A><A NAME="visitStructuredDocumentTagStart-com.aspose.words.StructuredDocumentTag-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitStructuredDocumentTagStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitStructuredDocumentTagStart</B>(<A HREF="StructuredDocumentTag.html" title="class in com.aspose.words">StructuredDocumentTag</A>&nbsp;sdt)
                                   throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a structured document tag has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="sdt"><CODE>sdt</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every structured document tag in a document.<pre>
public void structuredDocumentTagToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    StructuredDocumentTagNodePrinter visitor = new StructuredDocumentTagNodePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered StructuredDocumentTag nodes and their children.
/// &lt;/summary&gt;
public static class StructuredDocumentTagNodePrinter extends DocumentVisitor {
    public StructuredDocumentTagNodePrinter() {
        mBuilder = new StringBuilder();
        mVisitorIsInsideStructuredDocumentTag = false;
    }

    /// &lt;summary&gt;
    /// Gets the plain text of the document that was accumulated by the visitor.
    /// &lt;/summary&gt;
    public String getText() {
        return mBuilder.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        if (mVisitorIsInsideStructuredDocumentTag) {
            indentAndAppendLine("[Run] \"" + run.getText() + "\"");
        }

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a StructuredDocumentTag node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitStructuredDocumentTagStart(final StructuredDocumentTag sdt) {
        indentAndAppendLine("[StructuredDocumentTag start] Title: " + sdt.getTitle());
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a StructuredDocumentTag node have been visited.
    /// &lt;/summary&gt;
    public int visitStructuredDocumentTagEnd(final StructuredDocumentTag sdt) {
        mDocTraversalDepth--;
        indentAndAppendLine("[StructuredDocumentTag end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mBuilder.append("|  ");
        }

        mBuilder.append(text + "\r\n");
    }

    private final boolean mVisitorIsInsideStructuredDocumentTag;
    private int mDocTraversalDepth;
    private final StringBuilder mBuilder;
}</pre></example>
</DL>
<HR>

<A NAME="visitSubDocument(com.aspose.words.SubDocument)"><!-- --></A><A NAME="visitSubDocument-com.aspose.words.SubDocument-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitSubDocument</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitSubDocument</B>(<A HREF="SubDocument.html" title="class in com.aspose.words">SubDocument</A>&nbsp;subDocument)
                    throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when a sub-document is encountered.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="subDocument"><CODE>subDocument</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a document visitor to print a document's node structure.<pre>
public void docStructureToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    DocStructurePrinter visitor = new DocStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's tree of child nodes.
/// Creates a map of this tree in the form of a string.
/// &lt;/summary&gt;
public static class DocStructurePrinter extends DocumentVisitor {
    public DocStructurePrinter() {
        mAcceptingNodeChildTree = new StringBuilder();
    }

    public String getText() {
        return mAcceptingNodeChildTree.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Document node is encountered.
    /// &lt;/summary&gt;
    public int visitDocumentStart(Document doc) {
        int childNodeCount = doc.getChildNodes(NodeType.ANY, true).getCount();

        indentAndAppendLine("[Document start] Child nodes: " + childNodeCount);
        mDocTraversalDepth++;

        // Allow the visitor to continue visiting other nodes.
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Document node have been visited.
    /// &lt;/summary&gt;
    public int visitDocumentEnd(Document doc) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Document end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Section node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSectionStart(final Section section) {
        // Get the index of our section within the document
        NodeCollection docSections = section.getDocument().getChildNodes(NodeType.SECTION, false);
        int sectionIndex = docSections.indexOf(section);

        indentAndAppendLine("[Section start] Section index: " + sectionIndex);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Section node have been visited.
    /// &lt;/summary&gt;
    public int visitSectionEnd(final Section section) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Section end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Body node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitBodyStart(final Body body) {
        int paragraphCount = body.getParagraphs().getCount();
        indentAndAppendLine("[Body start] Paragraphs: " + paragraphCount);
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Body node have been visited.
    /// &lt;/summary&gt;
    public int visitBodyEnd(final Body body) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Body end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(final Paragraph paragraph) {
        indentAndAppendLine("[Paragraph start]");
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Paragraph node have been visited.
    /// &lt;/summary&gt;
    public int visitParagraphEnd(final Paragraph paragraph) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Paragraph end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(final Run run) {
        indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSubDocument(final SubDocument subDocument) {
        indentAndAppendLine("[SubDocument]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeStart(StructuredDocumentTagRangeStart sdtRangeStart)
    {
        indentAndAppendLine("[SdtRangeStart]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SubDocument node is encountered in the document.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitStructuredDocumentTagRangeEnd(StructuredDocumentTagRangeEnd sdtRangeEnd)
    {
        indentAndAppendLine("[SdtRangeEnd]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder and indent it depending on how deep the visitor is into the document tree.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mAcceptingNodeChildTree.append("|  ");
        }

        mAcceptingNodeChildTree.append(text + "\r\n");
    }

    private int mDocTraversalDepth;
    private final StringBuilder mAcceptingNodeChildTree;
}</pre></example>
</DL>
<HR>

<A NAME="visitTableEnd(com.aspose.words.Table)"><!-- --></A><A NAME="visitTableEnd-com.aspose.words.Table-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitTableEnd</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitTableEnd</B>(<A HREF="Table.html" title="class in com.aspose.words">Table</A>&nbsp;table)
                 throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a table has ended.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="table"><CODE>table</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to use a DocumentVisitor implementation to remove all hidden content from a document.<pre>
public void removeHiddenContentFromDocument() throws Exception {
    Document doc = new Document(getMyDir() + "Hidden content.docx");
    RemoveHiddenContentVisitor hiddenContentRemover = new RemoveHiddenContentVisitor();

    // Below are three types of fields which can accept a document visitor,
    // which will allow it to visit the accepting node, and then traverse its child nodes in a depth-first manner.
    // 1 -  Paragraph node:
    Paragraph para = (Paragraph) doc.getChild(NodeType.PARAGRAPH, 4, true);
    para.accept(hiddenContentRemover);

    // 2 -  Table node:
    Table table = doc.getFirstSection().getBody().getTables().get(0);
    table.accept(hiddenContentRemover);

    // 3 -  Document node:
    doc.accept(hiddenContentRemover);

    doc.save(getArtifactsDir() + "Font.RemoveHiddenContentFromDocument.docx");
}

/// &lt;summary&gt;
/// Removes all visited nodes marked as "hidden content".
/// &lt;/summary&gt;
public static class RemoveHiddenContentVisitor extends DocumentVisitor {
    /// &lt;summary&gt;
    /// Called when a FieldStart node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldStart(FieldStart fieldStart) {
        if (fieldStart.getFont().getHidden())
            fieldStart.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldEnd node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldEnd(FieldEnd fieldEnd) {
        if (fieldEnd.getFont().getHidden())
            fieldEnd.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FieldSeparator node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFieldSeparator(FieldSeparator fieldSeparator) {
        if (fieldSeparator.getFont().getHidden())
            fieldSeparator.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRun(Run run) {
        if (run.getFont().getHidden())
            run.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Paragraph node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitParagraphStart(Paragraph paragraph) {
        if (paragraph.getParagraphBreakFont().getHidden())
            paragraph.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a FormField is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFormField(FormField formField) {
        if (formField.getFont().getHidden())
            formField.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a GroupShape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitGroupShapeStart(GroupShape groupShape) {
        if (groupShape.getFont().getHidden())
            groupShape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Shape is encountered in the document.
    /// &lt;/summary&gt;
    public int visitShapeStart(Shape shape) {
        if (shape.getFont().getHidden())
            shape.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Comment is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCommentStart(Comment comment) {
        if (comment.getFont().getHidden())
            comment.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Footnote is encountered in the document.
    /// &lt;/summary&gt;
    public int visitFootnoteStart(Footnote footnote) {
        if (footnote.getFont().getHidden())
            footnote.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a SpecialCharacter is encountered in the document.
    /// &lt;/summary&gt;
    public int visitSpecialChar(SpecialChar specialChar) {
        if (specialChar.getFont().getHidden())
            specialChar.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Table node is ended in the document.
    /// &lt;/summary&gt;
    public int visitTableEnd(Table table) {
        // The content inside table cells may have the hidden content flag, but the tables themselves cannot.
        // If this table had nothing but hidden content, this visitor would have removed all of it,
        // and there would be no child nodes left.
        // Thus, we can also treat the table itself as hidden content and remove it.
        // Tables which are empty but do not have hidden content will have cells with empty paragraphs inside,
        // which this visitor will not remove.
        if (!table.hasChildNodes())
            table.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Cell node is ended in the document.
    /// &lt;/summary&gt;
    public int visitCellEnd(Cell cell) {
        if (!cell.hasChildNodes() &amp;&amp; cell.getParentNode() != null)
            cell.remove();

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when visiting of a Row node is ended in the document.
    /// &lt;/summary&gt;
    public int visitRowEnd(Row row) {
        if (!row.hasChildNodes() &amp;&amp; row.getParentNode() != null)
            row.remove();

        return VisitorAction.CONTINUE;
    }
}</pre></example><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<A NAME="visitTableStart(com.aspose.words.Table)"><!-- --></A><A NAME="visitTableStart-com.aspose.words.Table-"><!-- --></A>
<TABLE WIDTH="100%" CELLPADDING="3" CELLSPACING="0" ><TR><TD><H3>visitTableStart</H3></TD><TD ALIGN="right" VALIGN="top"></TD></TR>
<TR><TD COLSPAN="2"><PRE>
public int&nbsp;<B>visitTableStart</B>(<A HREF="Table.html" title="class in com.aspose.words">Table</A>&nbsp;table)
                   throws java.lang.Exception</PRE></TD></TR></TABLE>
<DL><DD><summary>
            Called when enumeration of a table has started.
            </summary><DL><DT><B>Parameters:</B></DT><DD param="table"><CODE>table</CODE> - The object that is being visited.</DD></DL><DL><DT><B>Returns:</B></DT><DD returns="">A <cref><A HREF="VisitorAction.html" title="Utility class in com.aspose.words">VisitorAction</A></cref> value that specifies how to continue the enumeration.</DD></DL><example><p><b>Example:</b></p>Shows how to print the node structure of every table in a document.<pre>
public void tableToText() throws Exception {
    Document doc = new Document(getMyDir() + "DocumentVisitor-compatible features.docx");
    TableStructurePrinter visitor = new TableStructurePrinter();

    // When we get a composite node to accept a document visitor, the visitor visits the accepting node,
    // and then traverses all the node's children in a depth-first manner.
    // The visitor can read and modify each visited node.
    doc.accept(visitor);

    System.out.println(visitor.getText());
}

/// &lt;summary&gt;
/// Traverses a node's non-binary tree of child nodes.
/// Creates a map in the form of a string of all encountered Table nodes and their children.
/// &lt;/summary&gt;
public static class TableStructurePrinter extends DocumentVisitor {
    public TableStructurePrinter() {
        mVisitedTables = new StringBuilder();
        mVisitorIsInsideTable = false;
    }

    public String getText() {
        return mVisitedTables.toString();
    }

    /// &lt;summary&gt;
    /// Called when a Run node is encountered in the document.
    /// Runs that are not within tables are not recorded.
    /// &lt;/summary&gt;
    public /*override*/ /*VisitorAction*/int visitRun(Run run) {
        if (mVisitorIsInsideTable) indentAndAppendLine("[Run] \"" + run.getText() + "\"");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Table is encountered in the document.
    /// &lt;/summary&gt;
    public int visitTableStart(final Table table) {
        int rows = 0;
        int columns = 0;

        if (table.getRows().getCount() &gt; 0) {
            rows = table.getRows().getCount();
            columns = table.getFirstRow().getCount();
        }

        indentAndAppendLine("[Table start] Size: " + rows + "x" + columns);
        mDocTraversalDepth++;
        mVisitorIsInsideTable = true;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Table node have been visited.
    /// &lt;/summary&gt;
    public int visitTableEnd(final Table table) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Table end]");
        mVisitorIsInsideTable = false;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Row node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitRowStart(final Row row) {
        String rowContents = row.getText().replaceAll("\\u0007", ", ").replaceAll(", , ", "");
        int rowWidth = row.indexOf(row.getLastCell()) + 1;
        int rowIndex = row.getParentTable().indexOf(row);
        String rowStatusInTable = row.isFirstRow() &amp;&amp; row.isLastRow() ? "only" : row.isFirstRow() ? "first" : row.isLastRow() ? "last" : "";
        if (!"".equals(rowStatusInTable)) {
            rowStatusInTable = MessageFormat.format(", the {0} row in this table,", rowStatusInTable);
        }

        indentAndAppendLine(MessageFormat.format("[Row start] Row #{0}{1} width {2}, \"{3}\"", ++rowIndex, rowStatusInTable, rowWidth, rowContents));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Row node have been visited.
    /// &lt;/summary&gt;
    public int visitRowEnd(final Row row) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Row end]");

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called when a Cell node is encountered in the document.
    /// &lt;/summary&gt;
    public int visitCellStart(final Cell cell) {
        Row row = cell.getParentRow();
        Table table = row.getParentTable();
        String cellStatusInRow = cell.isFirstCell() &amp;&amp; cell.isLastCell() ? "only" : cell.isFirstCell() ? "first" : cell.isLastCell() ? "last" : "";
        if (!"".equals(cellStatusInRow)) {
            cellStatusInRow = MessageFormat.format(", the {0} cell in this row", cellStatusInRow);
        }

        indentAndAppendLine(MessageFormat.format("[Cell start] Row {0}, Col {1}{2}", table.indexOf(row) + 1, row.indexOf(cell) + 1, cellStatusInRow));
        mDocTraversalDepth++;

        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Called after all the child nodes of a Cell node have been visited.
    /// &lt;/summary&gt;
    public int visitCellEnd(final Cell cell) {
        mDocTraversalDepth--;
        indentAndAppendLine("[Cell end]");
        return VisitorAction.CONTINUE;
    }

    /// &lt;summary&gt;
    /// Append a line to the StringBuilder, and indent it depending on how deep the visitor is
    /// into the current table's tree of child nodes.
    /// &lt;/summary&gt;
    /// &lt;param name="text"&gt;&lt;/param&gt;
    private void indentAndAppendLine(final String text) {
        for (int i = 0; i &lt; mDocTraversalDepth; i++) {
            mVisitedTables.append("|  ");
        }

        mVisitedTables.append(text + "\r\n");
    }

    private boolean mVisitorIsInsideTable;
    private int mDocTraversalDepth;
    private final /*final*/ StringBuilder mVisitedTables;
}</pre></example>
</DL>
<HR>

<B>See Also:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Products/Aspose.Words/Api/index.html" TARGET="_blank">Aspose.Words Documentation</A> - the home page for the Aspose.Words Product Documentation.<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A href="http://www.aspose.com/Community/forums/ShowForum.aspx?ForumID=75" TARGET="_blank">Aspose.Words Support Forum</A> - our preferred method of support.<P>
<div class="footer"><hr><p><a href='http://www.aspose.com/Wiki/default.aspx/Aspose.Corporate/ContactAspose.html'>We guarantee a prompt response to any inquiry!</a></p><p>&copy; 2003-2007 Aspose Pty Ltd. All rights reserved.</p></div></BODY></HTML>